\section{State of a channel}
  Consider a channel between \alice{} and \bob. Each party holds some data
  locally that are enough to ensure ownership of some funds in the channel. This
  is the data \alice{} holds:

  \begin{itemize}
    \item keys:
    \begin{itemize}
      \item local funding secret key ($s_{\alice, F}$)
      \item remote funding public key ($p_{\bob, F}$)
      \item local payment ($sb_{\alice, \mathrm{pay}}$), htlc ($sb_{\alice,
      \mathrm{htlc}}$), delayed payment ($sb_{\alice, \mathrm{dpay}}$),
      revocation ($sb_{\alice, \mathrm{rev}}$) basepoint secrets
      \item remote payment ($pb_{\bob, \mathrm{pay}}$), htlc ($pb_{\bob,
      \mathrm{htlc}}$), delayed payment ($pb_{\bob, \mathrm{dpay}}$), revocation
      ($pb_{\bob, \mathrm{rev}}$) basepoints
      \item seed (for deriving local per commitment keypairs ($s_{\alice,
      \mathrm{com}, n}, p_{\alice, \mathrm{com}, n}$))
      \item one remote per commitment secret ($\forall i \in [1, \dots, n],
      s_{\bob, \mathrm{com}, i}$) for each \textsc{commitmentSigned} received
      \item the current and the next remote per commitment points ($p_{\bob,
      \mathrm{com}, n}$ and $p_{\bob, \mathrm{com}, n + 1}$)
    \end{itemize}
    \item \alice's coins (integer)
    \item \bob's coins (integer)
    \item every HTLC that is included in the latest irrevocably committed (local
    or remote) commitment:
      \begin{itemize}
        \item direction ($\alice \rightarrow \bob$ or $\bob \rightarrow \alice$)
        \item hash
        \item preimage (or $\bot$ if still unresolved)
        \item coins (integer)
        \item Is it included in latest $\mathtt{localCom}_n$? (boolean)
        \item HTLC number
      \end{itemize}
    \item signatures:
    \begin{itemize}
      \item $\forall i \in [1, \dots, n],$ signature of $\mathtt{localCom}_i$
      generated with $s_{\bob, F}$
      \item for every HTLC included in $\mathtt{localCom}_i$, if HTLC is
      outgoing, a signature for \texttt{HTLC-timeout}, else a signature for
      \texttt{HTLC-success} with $s_{\bob, \mathrm{htlc}, i}$
    \end{itemize}
  \end{itemize}
  Every other piece of data used in the protocol can be derived by the above.

  \ \\

  Representation of a channel's state (from the point of view of \alice):
  \begin{itemize}
    \item \alice's coins $c_{\alice}$
    \item \bob's coins $c_{\bob}$
    \item list of (coins, $\mathrm{state} \in \{\mathrm{proposed},
    \mathrm{committed}\}$) preimage, whether we have a signature),
    \texttt{HTLCs}
    \begin{itemize}
      \item negative coins are outgoing, positive are incoming
      \item HTLCs can either be simply proposed (not in an irrevocably committed
      remote transaction) or committed (the opposite). After the preimage is
      supplied (no matter the direction), the HTLC is considered settled and is
      discarded.
    \end{itemize}
  \end{itemize}

  I.e. $\mathrm{State}_{\alice, \textit{pchid}} = \left(c_{\alice}, c_{\bob},
  \left(\left(c_1, \mathrm{state}_1\right), \dots, \left(c_k,
  \mathrm{state}_k\right)\right)\right)$

  E.g. $\mathrm{State}_{\alice, \textit{pchid}} = \left(4, 5, \left(\left(0.1,
  \mathrm{proposed}\right), \left(-0.2, \mathrm{signed}\right)\right)\right)$

  We do not include in the state elements whose contents are irrelevant (e.g.
  sigs, keys, hashes).
