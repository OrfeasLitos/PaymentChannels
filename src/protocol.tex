\section{Lightning Protocol}
  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ (self is \alice{} always) - support}
      \begin{algorithmic}[1]
        \State Initialisation:
        \Indent
          \State $\mathtt{channels}, \mathtt{pendingOpen}, \mathtt{pendingPay},
          \mathtt{pendingClose} \gets \emptyset$
          \State $\mathtt{newChannels}, \mathtt{closedChannels},
          \mathtt{updatesToReport} \gets \emptyset$
          \State $\mathtt{unclaimedOfferedHTLCs},
          \mathtt{unclaimedReceivedHTLCs}, \mathtt{pendingGetPaid} \gets
          \emptyset$
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{register}, delay, relayDelay) from
        \environment:
        \Indent
          \State $\mathtt{delay} \gets \mathrm{delay}$ \Comment{Must check chain
          at least once every \texttt{delay} blocks}
          \label{alg:protocol:support:delay}
          \State $\mathtt{relayDelay} \gets \mathrm{relayDelay}$
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to \texttt{lastPoll} \TODO{maybe remove lastPoll from real
          world?}
          \label{alg:protocol:support:lastpoll}
          \State $\left(pk_{\alice}, sk_{\alice}\right) \gets
          \mathrm{KeyGen}\left(\right)$
          \label{alg:protocol:support:keygen}
          \State send (\textsc{register}, \alice, \texttt{delay},
          \texttt{relayDelay}, $pk_{\alice}$) to \environment
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{registered}) from \environment:
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State assign the sum of all output values that are exclusively
          spendable by \alice{} to \texttt{onChainBalance}
          \State send (\textsc{registered}) to \environment
        \EndIndent
        \Statex

        \State Upon receiving any message ($M$) except for
        $\left(\textsc{register}\right)$:
        \Indent
          \If{if haven't received (\textsc{register}) from \environment{}}
            \State send (\textsc{invalid}, $M$) to \environment{} and ignore
            message
          \EndIf
        \EndIndent
        \Statex

        \Function{GetKeys}{}
          \State $\left(p_F, s_F\right) \gets \mathrm{KeyGen}\left(\right)$
          \Comment{For $F$ output}
          \State $\left(p_{\mathrm{pay}}, s_{\mathrm{pay}}\right) \gets
          \mathrm{MKeyGen}\left(\right)$ \Comment{For com output to remote}
          \State $\left(p_{\mathrm{dpay}}, s_{\mathrm{dpay}}\right) \gets
          \mathrm{MKeyGen}\left(\right)$ \Comment{For com output to self}
          \State $\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right) \gets
          \mathrm{MKeyGen}\left(\right)$ \Comment{For htlc output to self}
          \State $\texttt{seed} \overset{\$}{\gets} U(k)$ \Comment{For per com
          point}
          \State $\left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right) \gets
          \mathrm{MKeyGen}\left(\right)$ \Comment{For revocation in com}
          \State \Return $\left(\left(p_F, s_F\right), \left(p_{\mathrm{pay}},
          s_{\mathrm{pay}}\right), \left(p_{\mathrm{dpay}},
          s_{\mathrm{dpay}}\right),\right.$
          \Indent
            \State $\left.\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right),
            \mathtt{seed}, \left(p_{\mathrm{rev}},
            s_{\mathrm{rev}}\right)\right)$
          \EndIndent
        \EndFunction
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:support}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{openChannel} from
    \environment}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x,
        \mathit{tid}\right)$ from \environment:
        \Indent
          \State ensure \textit{tid} hasn't been used for opening another
          channel before
          \label{alg:protocol:open:env:valid}
          \State $\left(\left(ph_F, sh_F\right), \left(phb_{\mathrm{pay}},
          shb_{\mathrm{pay}}\right), \left(phb_{\mathrm{dpay}},
          shb_{\mathrm{dpay}}\right),\right.$ $\left.\left(phb_{\mathrm{htlc}},
          shb_{\mathrm{htlc}}\right), \mathtt{seed}, \left(phb_{\mathrm{rev}},
          shb_{\mathrm{rev}}\right)\right) \gets \texttt{GetKeys}\left(\right)$
          \State $\mathrm{prand}_1 \gets \texttt{PRF}\left(\mathtt{seed},
          1\right)$
          \State $\left(sh_{\mathrm{com}, 1}, ph_{\mathrm{com}, 1}\right) \gets
          \mathrm{KeyShareGen}\left(1^k; \mathrm{prand}_1\right)$
          \State associate keys with \textit{tid}
          \State add $\left(\alice, \bob, x, \mathtt{tid}, \left(ph_F,
          sh_F\right), \left(phb_{\mathrm{pay}}, shb_{\mathrm{pay}}\right),
          \left(phb_{\mathrm{dpay}}, shb_{\mathrm{dpay}}\right)\right.$
          $\left.\left(phb_{\mathrm{htlc}}, shb_{\mathrm{htlc}}\right),
          \left(phb_{\mathrm{com}, 1}, shb_{\mathrm{com}, 1}\right),\right.$
          $\left.\left(phb_{\mathrm{rev}}, shb_{\mathrm{rev}}\right),
          \mathit{tid}\right)$ to \texttt{pendingOpen}
          \label{alg:protocol:open:env:pendingOpen}
          \State send (\textsc{openChannel}, $x, \mathtt{delay} + k + \tochain,
          ph_F, phb_{\mathrm{pay}}, phb_{\mathrm{dpay}}, phb_{\mathrm{htlc}},$
          $ph_{\mathrm{com}, 1}, phb_{\mathrm{rev}}$, \textit{tid}) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:env}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{openChannel} from \bob}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{openChannel}, $x, \mathtt{remoteDelay},
        pt_F, ptb_{\mathrm{pay}}, ptb_{\mathrm{dpay}}, ptb_{\mathrm{htlc}},
        pt_{\mathrm{com}, 1}, ptb_{\mathrm{rev}}$, \textit{tid}) from \bob:
        \Indent
          \State ensure \textit{tid} has not been used yet with \bob
          \State $\left(\left(ph_F, sh_F\right), \left(phb_{\mathrm{pay}},
          shb_{\mathrm{pay}}\right), \left(phb_{\mathrm{dpay}},
          shb_{\mathrm{dpay}}\right), \left(phb_{\mathrm{htlc}},
          shb_{\mathrm{htlc}}\right), \mathtt{seed},\right.$
          $\left.\left(phb_{\mathrm{rev}}, shb_{\mathrm{rev}}\right)\right)
          \gets \texttt{GetKeys}\left(\right)$
          \State $\mathrm{prand}_1 \gets \texttt{PRF}\left(\mathtt{seed},
          1\right)$
          \State $\left(sh_{\mathrm{com}, 1}, ph_{\mathrm{com}, 1}\right) \gets
          \mathrm{KeyShareGen}\left(1^k; \mathrm{prand}_1\right)$
          \State associate keys with \textit{tid} and store in
          \texttt{pendingOpen}
          \label{alg:protocol:open:openChannel:pendingOpen}
          \State send (\textsc{acceptChannel}, $\mathtt{delay} + k + \tochain,
          ph_F, phb_{\mathrm{pay}}, phb_{\mathrm{dpay}}, phb_{\mathrm{htlc}},$
          $ph_{\mathrm{com}, 1}, phb_{\mathrm{rev}}$, \textit{tid}) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:openChannel}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{acceptChannel}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{acceptChannel}, $\mathtt{remoteDelay},
        pt_F, ptb_{\mathrm{pay}}, ptb_{\mathrm{dpay}},$ $ptb_{\mathrm{htlc}},$
        $pt_{\mathrm{com}, 1}, ptb_{\mathrm{rev}}$, \textit{tid}) from \bob:
        \Indent
          \State ensure there is a temporary ID \textit{tid} with \bob{} in
          \texttt{pendingOpen} on which \textsc{acceptChannel} hasn't been
          received
          \State associate received keys with \textit{tid}
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State assign to \texttt{prevout} a transaction output found in
          $\Sigma_{\alice}$ that is currently exclusively spendable by \alice{}
          and has value $y \geq x$
          \State $F \gets$ TX \{input spends \texttt{prevout} with a
          \texttt{signature}(TX, $sk_{\alice}$), output 0 pays $y - x$ to
          $pk_{\alice}$, output 1 pays $x$ to $\mathit{tid}.ph_F \wedge pt_F$\}
          \State $\mathit{pchid} \gets \mathcal{H}\left(F\right)$
          \State add \textit{pchid} to \texttt{pendingOpen} entry with id
          \textit{tid}
          \State $pt_{\mathrm{rev}, 1} \gets
          \mathtt{CombinePubKey}\left(ptb_{\mathrm{rev}}, ph_{\mathrm{com},
          1}\right)$
          \State $ph_{\mathrm{dpay}, 1} \gets
          \texttt{PubKeyGen}\left(phb_{\mathrm{dpay}}, ph_{\mathrm{com},
          1}\right)$
          \State $ph_{\mathrm{pay}, 1} \gets
          \texttt{PubKeyGen}\left(phb_{\mathrm{pay}}, ph_{\mathrm{com},
          1}\right)$
          \State $\mathtt{remoteCom} \gets \mathtt{remoteCom}_1 \gets$ TX
          \{input: output 1 of $F$, outputs: $\left(x, ph_{\mathrm{pay},
          1}\right), \left(0, ph_{\mathrm{rev}, 1} \vee \left(pt_{\mathrm{dpay},
          1}, \mathtt{delay} + k + \tochain{} \text{ relative}\right)\right)$\}
          \State $\mathtt{localCom} \gets$ TX \{input: output 1 of $F$, outputs:
          $\left(x, pt_{\mathrm{rev}, 1} \vee \left(ph_{\mathrm{dpay}, 1},
          \mathtt{remoteDelay} \text{ relative}\right)\right), \left(0,
          pt_{\mathrm{pay}, 1}\right)$\}
          \State add $\mathtt{remoteCom}$ and $\mathtt{localCom}$ to channel
          entry in \texttt{pendingOpen}
          \State $\mathrm{sig} \gets
          \mathtt{signature}\left(\mathtt{remoteCom}_1, sh_F\right)$
          \State $\mathtt{lastRemoteSigned} \gets 0$
          \State send (\textsc{fundingCreated}, \textit{tid},
          \textit{pchid}, sig) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:acceptChannel}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{fundingCreated}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingCreated}, \textit{tid},
        \textit{pchid}, $\mathtt{BobSig}_1$) from \bob:
        \Indent
          \State ensure there is a temporary ID \textit{tid} with \bob{} in
          \texttt{pendingOpen} on which we have sent up to
          \textsc{acceptChannel}
          \State $ph_{\mathrm{rev}, 1} \gets
          \mathtt{CombinePubKey}\left(phb_{\mathrm{rev}} pt_{\mathrm{com},
          1}\right)$
          \State $pt_{\mathrm{dpay}, 1} \gets
          \texttt{PubKeyGen}\left(ptb_{\mathrm{dpay}}, pt_{\mathrm{com},
          1}\right)$
          \State $pt_{\mathrm{pay}, 1} \gets
          \texttt{PubKeyGen}\left(ptb_{\mathrm{pay}}, pt_{\mathrm{com},
          1}\right)$
          \State $\mathtt{localCom} \gets \mathtt{localCom}_1 \gets$ TX \{input:
          output 1 of $F$, outputs: $\left(x, pt_{\mathrm{pay}, 1}\right),
          \left(0, pt_{\mathrm{rev}, 1} \vee \left(ph_{\mathrm{dpay}, 1},
          \mathtt{remoteDelay} \text{ relative}\right)\right)$\}
          \State ensure $\mathtt{verify}\left(\mathtt{localCom}_1,
          \mathtt{BobSig}_1, pt_F\right) = \mathtt{True}$
          \State $\mathtt{remoteCom} \gets \mathtt{remoteCom}_1 \gets$ TX
          \{input: output 1 of $F$, outputs: $\left(x, ph_{\mathrm{rev}, 1} \vee
          \left(pt_{\mathrm{dpay}, 1}, \mathtt{delay} + k + \tochain{} \text{
          relative}\right)\right), \left(0, ph_{\mathrm{pay}, 1}\right)\}$
          \State add $\mathtt{BobSig}_1, \mathtt{remoteCom}_1$ and
          $\mathtt{localCom}_1$ to channel entry in \texttt{pendingOpen}
          \State $\mathrm{sig} \gets
          \mathtt{signature}\left(\mathrm{remoteCom}_1, sh_F\right)$
          \State mark channel as ``broadcast, no \textsc{fundingLocked}''
          \label{alg:protocol:open:fundingCreated:mark}
          \State $\mathtt{lastRemoteSigned}, \mathtt{lastLocalSigned} \gets 0$
          \State send (\textsc{fundingSigned}, \textit{pchid}, sig) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:fundingCreated}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{fundingSigned}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingSigned}, \textit{pchid},
        $\mathtt{BobSig}_1$) from \bob:
        \Indent
          \State ensure there is a channel ID \textit{pchid} with \bob{} in
          \texttt{pendingOpen} on which we have sent up to
          \textsc{fundingCreated}
          \State ensure $\mathtt{verify}\left(\mathtt{localCom},
          \mathtt{BobSig}_1, pb_F\right) = \mathtt{True}$
          \State $\mathtt{localCom}_1 \gets \mathtt{localCom}$
          \State $\mathtt{lastLocalSigned} \gets 0$
          \State add $\mathtt{BobSig}_1$ to channel entry in
          \texttt{pendingOpen}
          \State $\mathrm{sig} \gets \mathtt{signature}\left(F,
          sk_{\mathit{Alice}}\right)$
          \State mark \textit{pchid} in \texttt{pendingOpen} as ``broadcast, no
          \textsc{fundingLocked}''
          \label{alg:protocol:open:fundingSigned:mark}
          \State send (\textsc{submit}, $\left(\mathrm{sig}, F\right)$) to
          \ledger
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:fundingSigned}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{checkNew}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{checkNew}, \alice, \bob, \textit{tid})
        from \environment: \Comment{new message: represents lnd polling daemon}
        \Indent
          \State ensure there is a matching \texttt{channel} in
          \texttt{pendingOpen} with id \textit{pchid}, with a ``broadcast''
          mark, funded with $x$ coins
          \label{alg:protocol:checkNew:valid}
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \label{alg:protocol:checkNew:read}
          \State ensure $\exists$ unspent TX in $\Sigma_{\alice}$ with ID
          \textit{pchid} and a $\left(x, ph_F \wedge pt_F\right)$ output
          \label{alg:protocol:checkNew:included}
          \State $\mathrm{prand}_2 \gets \texttt{PRF}\left(\mathtt{seed},
          2\right)$
          \label{alg:protocol:checkNew:prand}
          \State $\left(sh_{\mathrm{com}, 2}, ph_{\mathrm{com}, 2}\right) \gets
          \mathrm{KeyShareGen}\left(1^k; \mathrm{prand}_2\right)$
          \State add TX to \texttt{channel} data \State replace ``broadcast''
          mark in \texttt{channel} with ``in state''
          \If{\texttt{channel} is marked as ``in state,
          \textsc{fundingLocked}''}
            \State move channel data from \texttt{pendingOpen} to
            \texttt{channels}
            \State add receipt of channel to \texttt{newChannels}
          \EndIf
          \State send (\textsc{fundingLocked}, \textit{pchid},
          $ph_{\mathrm{com}, 2}$) to \bob{}
          \label{alg:protocol:checkNew:send}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:checkNew}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{fundingLocked}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingLocked}, \textit{pchid},
        $pt_{\mathrm{com}, 2}$) from \bob:
        \Indent
          \State ensure there is a \texttt{channel} with ID \textit{pchid} with
          \bob{} in \texttt{pendingOpen} with a ``no \textsc{fundingLocked}''
          mark
          \State ensure $pk\left(st_{\mathrm{com}, n}\right) = pt_{\mathrm{com},
          n}$
          \State replace ``no \textsc{fundingLocked}'' mark in \texttt{channel}
          with ``\textsc{fundingLocked}''
          \State ensure \texttt{channel} has an ``in state'' mark
          \State generate 2nd remote delayed payment, htlc, payment keys
          \State add TX to \texttt{channel} data
          \State move channel data from \texttt{pendingOpen} to
          \texttt{channels}
          \State add receipt of channel to \texttt{newChannels}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:fundingLocked}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - poll}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{poll}) from \environment:
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \label{alg:protocol:poll:read}
          \State assign largest block number in $\Sigma_{\alice}$ to
          \texttt{lastPoll}
          \label{alg:protocol:poll:afterread}
        \State $\mathtt{toSubmit} \gets \emptyset$
          \ForAll{$\tau \in \mathtt{unclaimedOfferedHTLCs}$}
            \If{input of $\tau$ has been spent} \Comment{by
            \texttt{remote HTLC-success}}
              \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
              \If{we are intermediary}
                \State retrieve preimage $R$, $\mathit{pchid}'$ of previous
                channel on the path of the HTLC, and $\mathtt{HTLCNo}'$ of the
                corresponding $\mathrm{HTLC}'$ in $\mathit{pchid}'$
                \State add $\left(\mathtt{HTLCNo}', R\right)$ to
                $\mathtt{pendingFulfills}_{\mathit{pchid}'}$
              \EndIf
            \ElsIf{input of $\tau$ has not been spent and timelock is over}
              \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
              \State add $\tau$ to \texttt{toSubmit}
            \EndIf
          \EndFor
          \State run loop of Fig.~\ref{alg:protocol:poll:closedch}
          \ForAll{honestly closed $\mathtt{remoteCom}_n$ that were processed
          above, with channel id \textit{pchid}}
            \ForAll{received HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
              \If{there is an entry in
              $\mathtt{pendingFulfills}_{\mathit{pchid}}$ with the same
              \texttt{HTLCNo} and $R$}
                \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
                $\mathtt{remoteCom}_n$ with $\left(ph_{\mathrm{htlc}, n},
                R\right)$ as method, output: $pk_{\alice}$\}
                \State $\mathrm{sig} \gets \mathtt{signature}\left(TX,
                sh_{\mathrm{htlc}, n}\right)$
                \State add (sig, TX) to \texttt{toSubmit}
                \State remove entry from
                $\mathtt{pendingFulfills}_{\mathit{pchid}}$
              \EndIf
            \EndFor
          \EndFor
          \label{alg:protocol:poll:beforesubmit}
          \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger
          \label{alg:protocol:poll:submit}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{getNews}) from \alice:
        \Indent
          \State clear \texttt{newChannels}, \texttt{closedChannels},
          \texttt{updatesToReport} and send them to \alice
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:poll}
  \end{figure}

  \begin{figure}[H]
    \begin{titlebox}{\normalfont Loop over closed channels}{commonbox}{normal}
      \begin{algorithmic}[1]
        \ForAll{$\mathtt{remoteCom}_n \in \Sigma_{\alice}$ that spend $F$ of a
        $\mathtt{channel} \in \mathtt{channels}$}
          \If{we do not have $sh_{\mathrm{rev}, n}$} \Comment{Honest closure}
            \ForAll{unspent offered HTLC outputs $i$ of
            $\mathtt{remoteCom}_n$}
              \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
              $\mathtt{remoteCom}_n$ with $ph_{\mathrm{htlc}, n}$ as method,
              output: $pk_{\alice}$\}
              \State $\mathrm{sig} \gets \mathtt{signature}\left(TX,
              sh_{\mathrm{htlc}, n}\right)$
              \If{timelock has not expired}
                \State add (sig, TX) to \texttt{unclaimedOfferedHTLCs}
              \ElsIf{timelock has expired}
                \State add (sig, TX) to \texttt{toSubmit}
                \label{alg:protocol:poll:htlc:submit}
              \EndIf
            \EndFor
            \ForAll{spent offered HTLC output $i$ of $\mathtt{remoteCom}_n$}
              \If{we are intermediary}
                \State retrieve preimage $R$, $\mathit{pchid}'$ of previous
                channel on the path of the HTLC, and $\mathtt{HTLCNo}'$ of the
                corresponding $\mathrm{HTLC}'$ in $\mathit{pchid}'$
                \State add $\left(\mathtt{HTLCNo}', R\right)$ to
                $\mathtt{pendingFulfills}_{\mathit{pchid}'}$
              \EndIf
            \EndFor
          \Else \ \Comment{malicious closure}
            \State $\mathrm{rev} \gets$ TX \{inputs: all
            $\mathtt{remoteCom}_n$ outputs, choosing $ph_{\mathrm{rev}, n}$
            method, output: $pk_{\mathit{Alice}}$\}
            \label{alg:protocol:poll:mal:tx}
            \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathrm{rev},
            sh_{\mathrm{rev}, n}\right)$
            \State add $\left(\mathrm{sig}, \mathrm{rev}\right)$ to
            \texttt{toSubmit}
            \label{alg:protocol:poll:mal:submit}
          \EndIf
          \State move \texttt{channel} from \texttt{channels} to
          \texttt{closedChannels}
        \EndFor
      \end{algorithmic}
    \end{titlebox}
    \caption{}
    \label{alg:protocol:poll:closedch}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - invoice}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pay}, \textit{Bob}, $x$,
        $\overrightarrow{\mathtt{path}}$) from \environment:
        \Indent
          \State ensure that $\overrightarrow{\mathtt{path}}$ consists of
          syntactically valid (\textit{pchid}, \texttt{CltvExpiryDelta}) pair
          \Comment{Payment completes only if $\forall i \in
          \overrightarrow{\mathtt{path}}, \mathtt{CltvExpiryDelta}_i \geq 3k +
          \mathtt{RelayDelay}_i$}
          \label{alg:protocol:pay:validpath}
          \State ensure that the first $\mathit{pchid} \in
          \overrightarrow{\mathtt{path}}$ corresponds to an open
          $\mathtt{channel} \in \mathtt{channels}$ in which we own at least $x$
          in the irrevocably committed state.
          \label{alg:protocol:pay:validchannel}
          \State choose unique payment ID \textit{payid} \Comment{unique for
          \alice{} and \bob}
          \State add (\bob, $x$, $\overrightarrow{\mathtt{path}}$,
          \textit{payid}, ``waiting for invoice'') to \texttt{pendingPay}
          \State send (\textsc{sendInvoice}, \textit{payid}) to \bob{}
          \label{alg:protocol:pay:sendinvoice}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{sendInvoice}, \textit{payid}) from \bob:
        \Indent
          \State ensure there is no (\bob, \textit{payid}) entry in
          \texttt{pendingGetPaid}
          \State choose random, unique preimage $R$
          \State add (\bob, $R$, \textit{payid}) to \texttt{pendingGetPaid}
          \State send $\left(\textsc{invoice}, \mathcal{H}\left(R\right),
          \mathtt{relayDelay} + 3k + 2\tochain{} - 1, \mathit{payid}\right)$ to
          \bob{}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{invoice}, $h$, \textit{payid}) from \bob:
        \Indent
          \State ensure there is a (\bob, $x$, $\overrightarrow{\mathtt{path}}$,
          \textit{payid}, ``waiting for invoice'') entry in \texttt{pendingPay}
          \State ensure $h$ is valid (in the range of $\mathcal{H}$)
          \State remove entry from \texttt{pendingPay}
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to $t$
          \State $l \gets |\left(\overrightarrow{\mathtt{path}}\right)|$
          \State $m \gets$ the concatenation of $l \left(x,
          \mathtt{OutgoingCltvExpiry}\right)$ pairs, where
          $\mathtt{OutgoingCltvExpiry}_l \gets t, \forall i \in \{1, \dots, l -
          1\}, \mathtt{OutgoingCltvExpiry}_{l - i} \gets
          \mathtt{OutgoingCltvExpiry}_{l - i + 1} + \mathtt{CltvExpiryDelta}_{l
          - i + 1}$
          \label{alg:protocol:pay:invoice:cltv}
          \State $\left(\mu_0, \delta_0\right) \gets
          \mathtt{SphinxCreate}\left(m, \text{ public keys of }
          \overrightarrow{\mathtt{path}} \text{ parties}\right)$
          \State let $\mathtt{remoteCom}_n$ the latest signed remote commitment
          tx
          \State $\mathtt{CltvExpiry} \gets \mathtt{OutgoingCltvExpiry}_1 +
          \mathtt{relayDelay} + 2k + \tochain{} - 1$
          \State reduce simple payment output in \texttt{remoteCom} by $x$
          \State add an additional $\left(x, ph_{\mathrm{rev}, n+1} \vee
          \left(ph_{\mathrm{htlc}, n+1} \wedge pt_{\mathrm{htlc}, n+1}, \text{
          on preimage}\right.\right.$ $\left.\left.\text{of } h\right) \vee
          ph_{\mathrm{htlc}, n+1}, \mathtt{CltvExpiry} \text{ absolute}\right)$
          output (all with $n+1$ keys) to \texttt{remoteCom}, marked with
          \texttt{HTLCNo}
          \State reduce delayed payment output in \texttt{localCom} by $x$
          \State add an additional $\left(x, pt_{\mathrm{rev}, n+1} \vee
          \left(pt_{\mathrm{htlc}, n+1}, \text{ on preimage}\right.\right.$
          $\left.\left.\text{of } h\right) \vee \left(ph_{\mathrm{htlc}, n+1}
          \wedge pt_{\mathrm{htlc}, n+1}, \mathtt{CltvExpiry} \text{
          absolute}\right)\right)$ output (all with $n+1$ keys) to
          \texttt{localCom}, marked with \texttt{HTLCNo}
          \State increment $\mathtt{HTLCNo}_{\mathit{pchid}}$ by one and
          associate $x, h, \mathit{pchid}$ with it
          \State mark \texttt{HTLCNo} as ``sender''
          \State send (\textsc{updateAddHtlc}, first \textit{pchid} of
          $\overrightarrow{\mathtt{path}}, \mathtt{HTLCNo}_{\mathit{pchid}}, x,
          h, \mathtt{CltvExpiry}, \left(\mu_0, \delta_0\right)$) to
          \textit{pchid} channel counterparty
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:invoice}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{updateAddHtlc}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{updateAddHtlc}, \textit{pchid},
        $\mathtt{HTLCNo}, x, h, \mathtt{CltvExpiry}, M$) from \bob:
        \Indent
          \State ensure \textit{pchid} corresponds to an open \texttt{channel}
          in \texttt{channels} where \bob{} has at least $x$
          \State ensure $\mathtt{HTLCNo} = \mathtt{HTLCNo}_{\mathit{pchid}} + 1$
          \State $\left(\mathit{pchid}', x', \mathtt{CltvExpiry}',
          \delta\right) \gets \mathtt{SphinxPeel}\left(sk_{\alice}, M\right)$
          \If{$\delta = \mathtt{receiver}$}
            \State ensure $\mathit{pchid}' = \bot, x = x', \mathtt{CltvExpiry}
            \geq \mathtt{CltvExpiry}' + \mathtt{relayDelay} + 2k + \tochain{} -
            1$
            \State mark \texttt{HTLCNo} as ``receiver''
          \Else \ \Comment{We are an intermediary}
            \State ensure $x = x', \mathtt{CltvExpiry} \geq \mathtt{CltvExpiry}'
            + \mathtt{relayDelay} + 3k + 2\tochain{} - 1$
            \State ensure $\mathtt{pchid}'$ corresponds to an open channel in
            \texttt{channels} where we have at least $x$
            \State mark \texttt{HTLCNo} as ``intermediary''
          \EndIf
          \State increment $\mathtt{HTLCNo}_{\mathit{pchid}}$ by one
          \State let $\mathtt{remoteCom}_n$ the latest signed remote commitment
          tx
          \State reduce delayed payment output in \texttt{remoteCom} by $x$
          \State add an $\left(x, ph_{\mathrm{rev}, n+1} \vee
          \left(ph_{\mathrm{htlc}, n+1} \wedge pt_{\mathrm{htlc}, n+1},
          \mathtt{CltvExpiry} \text{ absolute}\right) \vee\right.$
          $\left.ph_{\mathrm{htlc}, n+1}, \text{ on preimage of } h\right)$ htlc
          output (all with $n+1$ keys) to \texttt{remoteCom}, marked with
          \texttt{HTLCNo}
          \State reduce simple payment output in \texttt{localCom} by $x$
          \State add an $\left(x, pt_{\mathrm{rev}, n+1} \vee pt_{\mathrm{htlc},
          n+1}, \mathtt{CltvExpiry} \text{ absolute}\right) \vee$
          $\left(\left(pt_{\mathrm{htlc}, n+1} \wedge ph_{\mathrm{htlc}, n+1},
          \text{ on preimage of } h\right)\right)$ htlc output (all with $n+1$
          keys) to \texttt{remoteCom}, marked with \texttt{HTLCNo}
          \If{$\delta = \mathtt{receiver}$}
            \State retrieve $R : \mathcal{H}\left(R\right) = h$ from
            \texttt{pendingGetPaid} and clear entry
            \State add $\left(\mathtt{HTLCNo}, R\right)$ to
            $\mathtt{pendingFulfills}_{\mathit{pchid}}$
          \ElsIf{$\delta \neq \mathtt{receiver}$} \Comment{Send HTLC to next
          hop}
            \State retrieve $\mathit{pchid}'$ data
            \State let $\mathtt{remoteCom}_n'$ the latest signed remote
            commitment tx
            \State reduce simple payment output in $\mathtt{remoteCom}'$ by $x$
            \State add an additional $\left(x, ph_{\mathrm{rev}, n+1} \vee
            \left(ph_{\mathrm{htlc}, n+1} \wedge pt_{\mathrm{htlc}, n+1}, \text{
            on preimage}\right.\right.$ $\left.\left.\text{of } h\right) \vee
            ph_{\mathrm{htlc}, n+1}\mathtt{CltvExpiry}' \text{ absolute}\right)$
            output (all with $n+1$ keys) to $\mathtt{remoteCom}'$, marked with
            $\texttt{HTLCNo}'$
            \State reduce delayed payment output in $\mathtt{localCom}'$ by $x$
            \State add an additional $\left(x, pt_{\mathrm{rev}, n+1} \vee
            \left(pt_{\mathrm{htlc}, n+1}, \text{ on preimage}\right.\right.$
            $\left.\left.\text{of } h\right) \vee \left(pt_{\mathrm{htlc}, n+1}
            \wedge ph_{\mathrm{htlc}, n+1}\mathtt{CltvExpiry}' \text{
            absolute}\right)\right)$ output (all with $n+1$ keys) to
            $\mathtt{remoteCom}'$, marked with $\texttt{HTLCNo}'$
            \State increment $\texttt{HTLCNo}'$ by 1
            \State $M' \gets \mathtt{SphinxPrepare}\left(M, \delta,
            sk_{\mathit{Alice}}\right)$
            \State add $\left(\mathtt{HTLCNo}', x, h, \mathtt{CltvExpiry}',
            M'\right)$ to $\mathtt{pendingAdds}_{\mathit{pchid}'}$
          \EndIf
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:updateAddHtlc}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{updateFulfillHtlc}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{updateFulfillHtlc}, \textit{pchid},
        \texttt{HTLCNo}, $R$) from \bob:
        \Indent
          \If{$\mathtt{HTLCNo} > \mathtt{lastRemoteSigned} \vee \mathtt{HTLCNo}
          > \mathtt{lastLocalSigned} \vee \mathcal{H}\left(R\right) \neq h$,
          where $h$ is the hash in the HTLC with number \texttt{HTLCNo}}
            \State close channel (as in Fig.~\ref{alg:protocol:close})
            \State \Return
          \EndIf
          \State ensure \texttt{HTLCNo} is an offered HTLC (\texttt{localCom}
          has $h$ tied to a public key that we own)
          \State add value of HTLC to delayed payment of \texttt{remoteCom}
          \State remove HTLC output with number \texttt{HTLCNo} from
          \texttt{remoteCom}
          \State add value of HTLC to simple payment of \texttt{localCom}
          \State remove HTLC output with number \texttt{HTLCNo} from
          \texttt{localCom}
          \If{we have a channel $\mathit{phcid}'$ that has a received HTLC with
          hash $h$ with number $\mathtt{HTLCNo}'$} \Comment{We are intermediary}
            \State send (\textsc{read}) to \ledger{} and assign reply to
            $\Sigma_{\alice}$
            \If{latest $\mathtt{remoteCom}'_n \in \Sigma_{\alice}$}
            \Comment{counterparty has gone on-chain}
              \State $\mathrm{TX} \gets$ \{input: ($\mathtt{remoteCom}'$ HTLC
              output with number $\mathtt{HTLCNo}', R$), output:
              $pk_{\alice}$\}
              \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathrm{TX},
              sh_{\mathrm{htlc}, n}\right)$
              \State send (\textsc{submit}, (sig, TX)) to \ledger{}
              \Comment{shouldn't be already spent by remote
              \texttt{HTLCTimeout}}
              \label{alg:protocol:pay:updateFulfillHtlc:submit}
            \Else \ \Comment{counterparty still off-chain}
              \State \Comment{Not having the HTLC irrevocably committed is
              impossible (Fig.~\ref{alg:protocol:pay:push},
              l.~\ref{alg:protocol:pay:pushadd:choose})}
              \State send $\left(\textsc{updateFulfillHtlc}, \mathit{pchid}',
              \mathtt{HTLCNo}', R\right)$ to counterparty
            \EndIf
          \EndIf
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:updateFulfillHtlc}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{commit}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{commit}, \textit{pchid}) from
        \environment:
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State retrieve latest remote commitment tx $\mathtt{remoteCom}_n$ in
          \texttt{channel}
          \State ensure $\mathtt{remoteCom} \neq \mathtt{remoteCom}_n$
          \Comment{there are uncommitted updates}
          \State ensure \texttt{channel} is not marked as ``waiting for
          \textsc{revokeAndAck}''
          \State $\mathtt{remoteCom}_{n+1} \gets \mathtt{remoteCom}$
          \State $\mathrm{ComSig} \gets
          \mathtt{signature}\left(\mathtt{remoteCom}_{n+1}, sh_F\right)$
          \State $\mathrm{HTLCSigs} \gets \emptyset$
          \For{$i$ from \texttt{lastRemoteSigned} to \texttt{HTLCNo}}
            \State $\mathtt{remoteHTLC}_{n+1, i} \gets$ TX \{input: HTLC output
            $i$ of $\mathtt{remoteCom}_{n+1}$, output: $\left(c_{\mathrm{htlc,
            i}}, ph_{\mathrm{rev}, n+1} \vee \left(pt_{\mathrm{dpay}, n+1},
            \mathtt{delay} + k + \tochain{} \text{ relative}\right)\right)$\}
            \State add $\mathtt{signature}\left(\mathtt{remoteHTLC}_{n+1, i},
            sh_{\mathrm{htlc}, n+1}\right)$ to HTLCSigs
          \EndFor
          \State add $\mathtt{signature}\left(\mathtt{remoteHTLC}_{n+1, m+1},
          sh_{\mathrm{htlc}, n+1}\right)$ to HTLCSigs
          \State $\mathtt{lastRemoteSigned} \gets \mathtt{HTLCNo}$
          \State mark \texttt{channel} as ``waiting for \textsc{revokeAndAck}''
          \State send (\textsc{commitmentSigned}, \textit{pchid}, ComSig,
          HTLCSigs) to \textit{pchid} counterparty
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:commit}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{commitmentSigned}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{commitmentSigned}, \textit{pchid},
        $\mathtt{comSig}_{n+1}$, $\mathtt{HTLCSigs}_{n+1}$) from \bob:
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid} with \bob
          \State retrieve latest local commitment tx $\mathtt{localCom}_n$ in
          \texttt{channel}
          \State ensure $\mathtt{localCom} \neq \mathtt{localCom}_n$ and
          $\mathtt{localCom} \neq \mathtt{pendingLocalCom}$
          \Comment{there are uncommitted updates}
          \If{$\mathtt{verify}\left(\mathtt{localCom},
          \mathtt{comSig}_{n+1}, pt_F\right) = \mathtt{false} \vee
          |\mathtt{HTLCSigs}_{n+1}| \neq \mathtt{HTLCNo} -
          \mathtt{lastLocalSigned} + 1$}
            \State close channel (as in Fig.~\ref{alg:protocol:close})
            \State \Return
          \EndIf
          \For{$i$ from \texttt{lastLocalSigned} to \texttt{HTLCNo}}
            \State $\mathtt{localHTLC}_{n+1, i} \gets$ TX \{input: HTLC output
            $i$ of $\mathtt{localCom}$, output: $\left(c_{\mathrm{htlc, i}},
            ph_{\mathrm{rev}, n+1} \vee \left(pt_{\mathrm{dpay}, n+1},
            \mathtt{remoteDelay} \text{ relative}\right)\right)$\}
            \If{$\mathtt{verify}\left(\mathtt{localHTLC}_{n+1, i},
            \mathtt{HTLCSigs}_{n+1, i}, pt_{\mathrm{htlc}, n+1}\right) =
            \mathtt{false}$}
              \State close channel (as in Fig.~\ref{alg:protocol:close})
              \State \Return
            \EndIf
          \EndFor
          \State $\mathtt{pendingLocalCom} \gets \mathtt{localCom}$
          \State mark $\mathtt{pendingLocalCom}$ as ``irrevocably committed''
          \State $\mathrm{prand}_{n+2} \gets \texttt{PRF}\left(\mathtt{seed},
          n+2\right)$
          \State $\left(sh_{\mathrm{com}, n+2}, ph_{\mathrm{com}, n+2}\right)
          \gets \mathrm{KeyShareGen}\left(1^k; \mathrm{prand}_{n+2}\right)$
          \State send (\textsc{revokeAndAck}, \textit{pchid}, $\mathrm{prand}_n,
          ph_{\mathrm{com}, n+2}$) to \bob
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:commitmentSigned}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{revokeAndAck}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{revokeAndAck}, \textit{pchid},
        $st_{\mathrm{com}, n}, pt_{\mathrm{com}, n+2}$) from \bob:
        \Indent
          \State ensure there is a $\mathtt{channel} \in \mathtt{channels}$ with
          \bob{} with ID \textit{pchid} marked as ``waiting for
          \textsc{revokeAndAck}''
          \If{$pk\left(st_{\mathrm{com}, n}\right) \neq pt_{\mathrm{com}, n}$}
          \Comment{wrong $st_{\mathrm{com}, n}$ - closing}
            \State close channel (as in Fig.~\ref{alg:protocol:close})
            \State \Return
          \EndIf
          \State mark $\mathtt{remoteCom}_{n+1}$ as ``irrevocably committed''
          \State $\mathtt{localCom}_{n+1} \gets \mathtt{pendingLocalCom}$
          \State unmark \texttt{channel}
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{updatesToReport}
          \label{alg:protocol:pay:raa:report}
          \State $sh_{\mathrm{rev}, n} \gets
          \mathtt{CombineKey}\left(shb_{\mathrm{rev}}, phb_{\mathrm{rev}},
          st_{\mathrm{com} n}, pt_{\mathrm{com}, n}\right)$
          \State $ph_{\mathrm{rev}, n+2} \gets
          \mathtt{CombinePubKey}\left(phb_{\mathrm{rev}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $pt_{\mathrm{rev}, n+2} \gets
          \mathtt{CombinePubKey}\left(ptb_{\mathrm{rev}}, ph_{\mathrm{com},
          n+2}\right)$
          \State $ph_{\mathrm{dpay}, n+2} \gets
          \texttt{PubKeyGen}\left(phb_{\mathrm{dpay}}, ph_{\mathrm{com},
          n+2}\right)$
          \State $pt_{\mathrm{dpay}, n+2} \gets
          \texttt{PubKeyGen}\left(ptb_{\mathrm{dpay}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $ph_{\mathrm{pay}, n+2} \gets
          \texttt{PubKeyGen}\left(phb_{\mathrm{pay}}, ph_{\mathrm{com},
          n+2}\right)$
          \State $pt_{\mathrm{pay}, n+2} \gets
          \texttt{PubKeyGen}\left(ptb_{\mathrm{pay}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $ph_{\mathrm{htlc}, n+2} \gets
          \texttt{PubKeyGen}\left(phb_{\mathrm{htlc}}, ph_{\mathrm{com},
          n+2}\right)$
          \State $pt_{\mathrm{htlc}, n+2} \gets
          \texttt{PubKeyGen}\left(ptb_{\mathrm{htlc}}, pt_{\mathrm{com},
          n+2}\right)$
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:revokeAndAck}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - \textsc{push}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}) from
        \environment:
        \label{alg:protocol:pushfulfill:start}
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State choose a member (\texttt{HTLCNo}, $R$) of
          $\mathtt{pendingFulfills}_{\mathit{pchid}}$ that is both in an
          ``irrevocably committed'' $\mathtt{remoteCom}_n$ and
          $\mathtt{localCom}_n$
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State remove (\texttt{HTLCNo}, $R$) from
          $\mathtt{pendingFulfills}_{\mathit{pchid}}$
          \If{$\mathtt{remoteCom}_n \notin \Sigma_{\alice}$}
          \Comment{counterparty cooperative}
            \State send (\textsc{updateFulfillHtlc}, \textit{pchid},
            \texttt{HTLCNo}, $R$) to \textit{pchid} counterparty
          \Else \ \Comment{counterparty gone on-chain}
            \State $\mathrm{TX} \gets$ \{input: ($\mathtt{remoteCom}_n$ HTLC
            output with number $\mathtt{HTLCNo}, R$), output:
            $pk_{\alice}$\}
            \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathrm{TX},
            sh_{\mathrm{htlc}, n}\right)$
            \State send (\textsc{submit}, (sig, TX)) to \ledger{}
            \Comment{shouldn't be already spent by remote \texttt{HTLCTimeout}}
            \label{alg:protocol:pushfulfill:submit}
          \EndIf
          \label{alg:protocol:pushfulfill:end}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{pushAdd}, \textit{pchid}) from
        \environment:
        \label{alg:protocol:pushadd:start}
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State choose a member $\left(\mathtt{HTLCNo}, x, h,
          \mathtt{CltvExpiry}, M\right)$ of
          $\mathtt{pendingAdds}_{\mathit{pchid}}$ that is both in an
          ``irrevocably committed'' $\mathtt{remoteCom}_n$ and
          $\mathtt{localCom}_n$
          \label{alg:protocol:pay:pushadd:choose}
          \State remove chosen entry from
          $\mathtt{pendingAdds}_{\mathit{pchid}}$
          \State send (\textsc{updateAddHtlc}, \textit{pchid}, \texttt{HTLCNo},
          $x, h, \mathtt{CltvExpiry}, M$) to \textit{pchid} counterparty
          \label{alg:protocol:pushadd:end}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{fulfillOnChain}) from \environment:
        \label{alg:protocol:pay:foc:top}
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to $t$
          \label{alg:protocol:pay:foc:read}
          \State $\mathtt{toSubmit} \gets \emptyset$
          \label{alg:protocol:pay:foc:tosubmit}
          \ForAll{channels}
            \If{there exists an HTLC in latest $\mathtt{localCom}_n$ for which
            we have sent both \textsc{updateFulfillHtlc} and
            \textsc{commitmentSigned} to a transaction without that HTLC to
            counterparty, but have not received the corresponding
            \textsc{revokeAndAck} AND the HTLC expires within $\left[t, t + k +
            \tochain{}\right]$}
              \State add $\mathtt{localCom}_n$ of the channel and all
              corresponding valid \texttt{HTLC-success}es and
              \texttt{HTLC-timeout}s (for both $\mathtt{localCom}_n$ and
              $\mathtt{remoteCom}_n$\footnote{Ensures funds retrieval if
              counterparty has gone on-chain}), along with their signatures to
              \texttt{toSubmit}
            \EndIf
          \EndFor
          \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger
          \label{alg:protocol:pay:foc:submit}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:push}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ - close}
      \begin{algorithmic}[1]
        \TODO{remove receipt?}
        \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from
        \environment:
        \Indent
          \State ensure \texttt{receipt} corresponds to an open
          $\mathtt{channel} \in \mathtt{channels}$
          \State assign latest \texttt{channel} sequence number to $n$
          \State $\mathrm{HTLCs} \gets \emptyset$
          \For{every $\text{HTLC output } \in \mathtt{localCom}_n$ with number
          $i$}
            \State $\mathrm{sig} \gets
            \mathtt{signature}\left(\mathtt{localHTLC}_{n, i},
            sh_{\mathrm{htlc}, n}\right)$
            \State add $\left(\mathrm{sig}, \mathtt{HTLCSigs}_{n, i},
            \mathtt{localHTLC}_{n, i}\right)$ to HTLCs
          \EndFor
          \State $\mathrm{sig} \gets
          \mathtt{signature}\left(\mathtt{localCom}_n, sh_F\right)$
          \State remove \texttt{channel} from \texttt{channels}
          \State send (\textsc{submit}, $\left(\mathrm{sig},
          \mathtt{remoteSig}_n, \mathtt{localCom}_n\right), \mathrm{HTLCs}$) to
          \ledger
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:close}
  \end{figure}
