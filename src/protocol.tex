\ \\ \noindent {$\Pi_{\mathrm{LN}}$} (self is \alice)
  \label{alg:lightningprot}
  \begin{algorithmic}[1]
    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{pendingOpen}, \mathtt{pendingPay},
      \mathtt{pendingClose}, \mathtt{newChannels},$ $\mathtt{closedChannels},
      \mathtt{unclaimedOfferedHTLCs}, \mathtt{unclaimedReceivedHTLCs},
      \mathtt{pendingGetPaid} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving (\textsc{register}, delay) from \environment:
    \Indent
      \State $\mathtt{delay} \gets \mathrm{delay}$
      \State send (\textsc{read}) to \ledger{} and assign largest block number
      to \texttt{lastPoll}
      \State $\left(pk_{\alice}, sk_{\alice}\right) \gets
      \mathrm{genKey}\left(\right)$
      \State send (\textsc{register}, \alice, \texttt{delay},
      $pk_{\alice}$) to \adversary \orfeas{delay to \adversary{}
      needed?}
    \EndIndent
    \State

    \State Upon receiving (\textsc{registered}) from \adversary:
    \Indent
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State assign the sum of all output values that are exclusively spendable
      by \alice{} to \texttt{onChainBalance}
      \State send (\textsc{registered}) to \environment
    \EndIndent
    \State

    \State Upon receiving any message ($M$) except for
    $\left(\textsc{register}\right)$:
    \Indent
      \If{if haven't received (\textsc{register}) from \environment{}}
        \State send (\textsc{invalid}, $M$) to \adversary{} and ignore message
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, \mathrm{pid}_{\alice},
    \mathrm{pid}_{\bob}, x\right)$ from \environment:
    \Indent
      \State $\left(\left(ph_F, sh_F\right),
      \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},
      sh\_\mathrm{base}_{\mathrm{dpay}}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right), \left(ph_{\mathrm{com}, 1},
      sh_{\mathrm{com}, 1}\right), \left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$ \TODO{change font}
      \State choose unique temporary ID \textit{tid} \Comment{unique for the two
      parties}
      \State associate keys with \textit{tid}
      \State add $\left(\alice, \bob, x, \mathtt{delay}, \left(ph_F,
      sh_F\right), \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},\right.\right.$
      $\left.\left.sh\_\mathrm{base}_{\mathrm{dpay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{com}, 1},
      sh\_\mathrm{base}_{\mathrm{com}, 1}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right), \mathit{tid}\right)$ to
      \texttt{pendingOpen}
      \State send (\textsc{openChannel}, $x$, \texttt{delay}, $ph_F,
      ph\_\mathrm{base}_{\mathrm{pay}}, ph\_\mathrm{base}_{\mathrm{dpay}},
      ph\_\mathrm{base}_{\mathrm{htlc}},$ $ph_{\mathrm{com}, 1},
      ph\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) to \bob{} and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{openChannel}, $x$, BobDelay, $pt_F,
    pt\_\mathrm{base}_{\mathrm{pay}}, pt\_\mathrm{base}_{\mathrm{dpay}},$
    $pt\_\mathrm{base}_{\mathrm{htlc}}, pt_{\mathrm{com}, 1},
    pt\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) from \bob:
    \Indent
      \State ensure \textit{tid} has not been used yet with \bob
      \State $\left(\left(ph_F, sh_F\right),
      \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},
      sh\_\mathrm{base}_{\mathrm{dpay}}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right),
      \left(ph_{\mathrm{com}, 1}, sh_{\mathrm{com}, 1}\right),
      \left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$ \TODO{change font}
      \State associate keys with \textit{tid} and store in \texttt{pendingOpen}
      \State send (\textsc{acceptChannel}, \texttt{delay}, $ph_F,
      ph\_\mathrm{base}_{\mathrm{pay}}, ph\_\mathrm{base}_{\mathrm{dpay}},
      ph\_\mathrm{base}_{\mathrm{htlc}},$ $ph_{\mathrm{com}, 1},
      ph\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) to \bob{} and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{acceptChannel}, \texttt{delay}, $pt_F,
    pt\_\mathrm{base}_{\mathrm{pay}}, pt\_\mathrm{base}_{\mathrm{dpay}},$
    $pt\_\mathrm{base}_{\mathrm{htlc}},$ $pt_{\mathrm{com}, 1},
    pt\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) from \bob:
    \Indent
      \State ensure there is a temporary ID \textit{tid} with \bob{} in
      \texttt{pendingOpen} on which \textsc{acceptChannel} hasn't been received
      \State associate received keys with \textit{tid}
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State assign to \texttt{prevout} a transaction output found in
      $\Sigma_{\alice}$ that is currently exclusively spendable by \alice{} and
      has value $y \geq x$
      \State $F \gets$ TX \{input spends prevout with a \texttt{signature}(TX,
      $sk_{\alice}$), output 0 pays $y - x$ to $pk_{\alice}$ now, output 1 pays
      $x$ to $\textit{tid}.ph_F \wedge pt_F$ now\}
      \State $\mathit{pchid} \gets \mathcal{H}\left(F\right)$
      \State replace \textit{tid} with \textit{pchid} in storage
      \State $pt_{\mathrm{rev}, 1} \gets pt\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(pt\_\mathrm{base}_{\mathrm{rev}} ||
      pt_{\mathrm{com}, 1}\right) + pt_{\mathrm{com}, 1} \cdot \mathcal{H}\left(
      pt_{\mathrm{com}, 1} || pt\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{dpay}, 1} \gets ph\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, 1} ||
      ph\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $ph_{\mathrm{pay}, 1} \gets ph\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, 1} ||
      ph\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $\mathtt{remoteCom} \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, ph_{\mathrm{pay}, 1}\right)$\}
      \State $\mathtt{localCom} \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, pt_{\mathrm{rev}, 1} \vee \left(ph_{\mathrm{dpay}_1},
      \mathtt{delay} \text{ relative}\right)\right)$ \TODO{check delays}
      \State add $\mathtt{remoteCom}_1$ and $\mathtt{localCom}_1$ to channel
      entry in \texttt{pendingOpen}
      \State $\mathrm{AliceSig} \gets
      \mathtt{signature}\left(\mathtt{remoteCom}_1, sh_F\right)$
      \State mark $\mathtt{remoteCom}_1$ as ``signed''
      \State send (\textsc{fundingCreated}, \textit{tid},
      \textit{pchid}, AliceSig) to \bob{} and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingCreated}, \textit{tid},
    \textit{pchid}, $\mathtt{BobSig}_1$) from \bob:
    \Indent
      \State ensure there is a temporary ID \textit{tid} with \bob{} in
      \texttt{pendingOpen} on which we have sent up to \textsc{acceptChannel}
      \State $ph_{\mathrm{rev}, 1} \gets ph\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ph\_\mathrm{base}_{\mathrm{rev}} ||
      ph_{\mathrm{com}, 1}\right) + ph_{\mathrm{com}, 1} \cdot \mathcal{H}\left(
      ph_{\mathrm{com}, 1} || ph\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{dpay}, 1} \gets pt\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, 1} ||
      pt\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $pt_{\mathrm{pay}, 1} \gets pt\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, 1} ||
      pt\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $\mathtt{localCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, pt_{\mathrm{pay}, 1}\right)$\}
      \State ensure $\mathtt{verify}\left(\mathtt{localCom}_1,
      \mathtt{BobSig}_1, pt_F\right) = \mathtt{True}$
      \State $\mathtt{remoteCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, ph_{\mathrm{rev}} \vee \left(pt_{\mathrm{dpay}}, \mathtt{delay}
      \text{ relative}\right)\right)$ \orfeas{check delays}
      \State add $\mathtt{BobSig}, \mathtt{remoteCom}_1$ and
      $\mathtt{localCom}_1$ to channel entry in \texttt{pendingOpen}
      \State $\mathrm{AliceSig} \gets
      \mathtt{signature}\left(\mathrm{remoteCom}_1, sh_F\right)$
      \State mark channel as ``broadcast, no \textsc{fundingLocked}''
      \State mark $\mathtt{localCom}_1$ and $\mathtt{remoteCom}_1$ as ``signed''
      \State send (\textsc{fundingSigned}, \textit{pchid}, AliceSig) to \bob{}
      and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingSigned}, \textit{pchid},
    $\mathtt{BobSig}$) from \bob:
    \Indent
      \State ensure there is a channel ID \textit{pchid} with \bob{} in
      \texttt{pendingOpen} on which we have sent up to \textsc{fundingCreated}
      \State ensure $\mathtt{verify}\left(\mathtt{localCom}, \mathtt{BobSig},
      pb_F\right) = \mathtt{True}$
      \State mark \texttt{localCom} as ``signed''
      \State add $\mathtt{BobSig}$ to channel entry in \texttt{pendingOpen}
      \State $\mathrm{sig} \gets \mathtt{signature}\left(F,
      sk_{\mathit{Alice}}\right)$
      \State mark \textit{pchid} in \texttt{pendingOpen} as ``broadcast, no
      \textsc{fundingLocked}''
      \State send (\textsc{submit}, $\left(\mathrm{sig}, F\right)$) to \ledger
    \EndIndent
    \State

    \Function{GetKeys}{} \TODO{change font}
      \State $\left(p_F, s_F\right) \gets \mathrm{genKey}\left(\right)$
      \Comment{For $F$ output}
      \State $\left(p_{\mathrm{pay}}, s_{\mathrm{pay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to remote}
      \State $\left(p_{\mathrm{dpay}}, s_{\mathrm{dpay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to self}
      \State $\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For htlc output to self}
      \State $\left(p_{\mathrm{com}, 1}, s_{\mathrm{com}, 1}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For deriving all keys}
      \State $\left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For revocation in com}
      \State \Return $\left(\left(p_F, s_F\right), \left(p_{\mathrm{pay}},
      s_{\mathrm{pay}}\right), \left(p_{\mathrm{dpay}},
      s_{\mathrm{dpay}}\right),\right.$
      \Indent
        \State $\left.\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right),
        \left(p_{\mathrm{com}, 1}, s_{\mathrm{com}, 1}\right),
        \left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right)\right)$
      \EndIndent
    \EndFunction
    \State

    \State \TODO{explicitly add keys et al to \texttt{channel}}
    \State Upon receiving (\textsc{checkNew}, \alice, \bob, $x$) from
    \environment: \Comment{new message: represents lnd polling daemon}
    \Indent
      \State ensure there is a matching \texttt{channel} in \texttt{pendingOpen}
      with id \textit{pchid} with a ``broadcast'' mark
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State ensure $\exists$ unspent TX in $\Sigma_{\alice}$ with ID
      \textit{pchid} and a $\left(x, ph_F \wedge pt_F\right)$ output
      \State $\left(ph\_\mathrm{base}_{\mathrm{com}, 2},
      sh\_\mathrm{base}_{\mathrm{com}, 2}\right) \gets
      \mathrm{genKey}\left(\right)$
      \State add TX to \texttt{channel} data \State replace ``broadcast'' mark
      in \texttt{channel} with ``in state''
      \If{\texttt{channel} is marked as ``in state, \textsc{fundingLocked}''}
        \State move channel data from \texttt{pendingOpen} to \texttt{channels}
        \State add receipt of channel to \texttt{newChannels}
      \EndIf
      \State send (\textsc{fundingLocked}, \textit{pchid},
      $ph\_\mathrm{base}_{\mathrm{com}, 2}$) to \bob{}
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingLocked}, \textit{pchid},
    $pt\_\mathrm{base}_{\mathrm{com}, 2}$) from \bob:
    \Indent
      \State ensure there is a \texttt{channel} with ID \textit{pchid} with
      \bob{} in \texttt{pendingOpen} with a ``no \textsc{fundingLocked}'' mark
      \State replace ``no \textsc{fundingLocked}'' mark in \texttt{channel} with
      ``\textsc{fundingLocked}''
      \State ensure \texttt{channel} has an ``in state'' mark
      \State add TX to \texttt{channel} data
      \State move channel data from \texttt{pendingOpen} to \texttt{channels}
      \State add receipt of channel to \texttt{newChannels}
    \EndIndent
    \State

    \State Upon receiving (\textsc{poll}) from \environment:
    \Indent
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State assign largest block number in $\Sigma_{\alice}$ to
      \texttt{lastPoll}
    \State $\mathtt{toSubmit} \gets \emptyset$
      \ForAll{$\tau \in \mathtt{unclaimedOfferedHTLCs}$}
        \If{input of $\tau$ has been spent} \Comment{by
        \texttt{remoteHTLC-success}}
          \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
        \ElsIf{input of $\tau$ has not been spent and timelock is over}
          \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
          \State add $\tau$ to \texttt{toSubmit}
        \EndIf
      \EndFor
      \ForAll{$\mathtt{remoteCom}_n \in \Sigma_{\alice}$ that spend $F$ of a
      $\mathtt{channel} \in \mathtt{channels}$}
        \If{we do not have $sh_{\mathrm{rev}, n}$} \Comment{Honest closure}
          \ForAll{received HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
            \If{we know the preimage $R$}
              \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
              $\mathtt{remoteCom}_n$ with $\left(ph_{\mathrm{htlc}, n},
              R\right)$ as method, output: $pk_{\alice}$\}
              \State $\mathrm{sig} \gets \mathtt{signature}\left(TX,
              sh_{\mathrm{htlc}, n}\right)$
              \State add (sig, TX) to \texttt{toSubmit}
            \Else
              \State add $\left(\texttt{channel}, \mathtt{remoteCom}_n, h,
              sh_{\mathrm{htlc}, n}\right)$ to \texttt{unclaimedReceivedHTLCs}
            \EndIf
          \EndFor
          \ForAll{unspent offered HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
            \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
            $\mathtt{remoteCom}_n$ with $ph_{\mathrm{htlc}, n}$ as method,
            output: $pk_{\alice}$\}
            \State $\mathrm{sig} \gets \mathtt{signature}\left(TX,
            sh_{\mathrm{htlc}, n}\right)$
            \If{timelock has not expired}
              \State add (sig, TX) to \texttt{unclaimedOfferedHTLCs}
            \ElsIf{timelock has expired}
              \State add (sig, TX) to \texttt{toSubmit}
            \EndIf
          \EndFor
        \Else \Comment{malicious closure}
          \State $\mathrm{rev} \gets$ TX \{inputs: all $\mathtt{remoteCom}_n$
          outputs, choosing $ph_{\mathrm{rev}, n}$ method, output:
          $pk_{\mathit{Alice}}$\}
          \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathrm{rev},
          sh_{\mathrm{rev}, n}\right)$
          \State add $\left(\mathrm{sig}, \mathrm{rev}\right)$ to
          \texttt{toSubmit}
        \EndIf
        \State move \texttt{channel} from \texttt{channels} to
        \texttt{closedChannels}
      \EndFor
      \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger
    \EndIndent
    \State

    \State UpRecv uAH add (both) local-\&remote-uncommited HTLC(s) and push uAH
    if intermediary
    \State upRecv uFH add (both) local-\&remote-uncommited remove-HTLC(s) and if
    intermediary and prev htlc is remote-irr-commited send uFH back
    \State UpRecv comSig update local com, mark diff HTLCs as local-irr-commited
    \& send rAA
    \State upRecv rAA mark old remote com as revoked, remote-commited HTLCs as
    remote-irr-commited
    \State upRecv commit send comSig for all remote-uncomitted htlcs and mark
    them as remote-commited
    \State upRecv push(ch) send uFH for all remote-irr-commited received htlcs
    that we are final receiver
    \State \orfeas{maybe leak queries to global functionalities to \adversary?}
    \State Upon receiving (\textsc{pay}, \textit{Bob}, $x$,
    $\overrightarrow{\mathtt{path}}$, \texttt{receipt}) from \environment:
    \Indent
      \State ensure that $\overrightarrow{\mathtt{path}}$ consists of valid
      \textit{pchid}s
      \State ensure that the first $\mathit{pchid} \in
      \overrightarrow{\mathtt{path}}$ has the same \textit{pchid} as in
      \texttt{receipt}
      \State ensure that \texttt{receipt} corresponds to the latest version of
      an open $\mathtt{channel} \in \mathtt{channels}$ in which we have at least
      $x$.
      \State choose unique payment ID \textit{payid} \Comment{unique for
      \alice{} and \bob}
      \State add (\textit{Bob}, $x$, $\overrightarrow{\mathtt{path}}$,
      \texttt{receipt}, \textit{payid}, ``waiting for invoice'') to
      \texttt{pendingPay}
      \State send (\textsc{sendInvoice}, \textit{payid}) to \bob{} and
      \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{sendInvoice}, \textit{payid}) from \bob:
    \Indent
      \State ensure there is no (\bob, \textit{payid}) entry in
      \texttt{pendingGetPaid}
      \State choose random, unique preimage $R$
      \State add (\bob, $R$, \textit{payid}) to \texttt{pendingGetPaid}
      \State send (\textsc{invoice}, $\mathcal{H}\left(R\right)$,
      \textit{payid}) to \bob{} and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{invoice}, $h$, \textit{payid}) from \bob:
    \Indent
      \State ensure there is a (\bob, $x$, $\overrightarrow{\mathtt{path}}$,
      \texttt{receipt}, \textit{payid}, ``waiting for invoice'') entry in
      \texttt{pendingPay}
      \State ensure $h$ is valid (in the range of $\mathcal{H}$)
      \State send (\textsc{read}) to \ledger{} and assign largest block number
      to $t$
      \State $m \gets$ the concatenation of \texttt{length}
      $\overrightarrow{\mathtt{path}}$ $\left(x, \mathtt{absDelay}_i\right)$
      pairs, where the last \texttt{absDelay} is $t$ + \orfeas{TODECIDE} and
      every previous \texttt{absDelay} is incremented by \orfeas{TODECIDE}
      \State $\left(\mu_0, \delta_0\right) \gets \mathtt{SphinxCreate}\left(m,
      \text{ public keys of } \overrightarrow{\mathtt{path}} \text{
      parties}\right)$
      \State increment $\mathtt{HTLCNo}_{\textit{pchid}}$ by one and associate
      $x, h, \mathit{pchid}$ with it
      \State mark \texttt{channel} as ``waiting for \textsc{commitmentSigned}''
      \State send (\textsc{updateAddHtlc}, first \textit{pchid} of
      $\overrightarrow{\mathtt{path}}, \mathtt{HTLCNo}_{\textit{pchid}}, x, h,$
      largest \texttt{absDelay}, $\left(\mu_0, \delta_0\right)$) to
      \textit{pchid} channel counterparty and \adversary
    \EndIndent
    \State

    \State Upon receiving (\textsc{updateAddHtlc}, \textit{pchid},
    $\mathtt{HTLCNo}, x, h, \mathtt{absDelay}, M$) from \bob:
    \Indent
      \State ensure \textit{pchid} corresponds to an open \texttt{channel} in
      \texttt{channels} where \bob{} has at least $x$
      \State ensure $\mathtt{HTLCNo} = \mathtt{HTLCNo}_{\mathit{pchid}} + 1$
      \State ensure \texttt{absDelay} \orfeas{TODECIDE}
      \State $\left(\mathit{pchid}', x', \mathtt{absDelay}', \delta\right) \gets
      \mathtt{SphinxPeel}\left(sk_{\textit{Alice}}, M\right)$
      \If{$\delta = \mathtt{receiver}$}
        \State ensure $\mathit{pchid}' = \bot, x = x', \mathtt{absDelay} =
        \mathtt{absDelay}'$
        \State mark \texttt{HTLCNo}+1 as ``receiver''
      \Else \Comment{We are an intermediary}
        \State ensure $x = x', \mathtt{absDelay} = \mathtt{absDelay}' +$
        \orfeas{TODECIDE}
        \State ensure $\mathtt{pchid}'$ corresponds to an open channel in
        \State mark \texttt{HTLCNo}+1 as ``intermediary''
      \EndIf
      \State increment $\mathtt{HTLCNo}_{\textit{pchid}}$ by one
      \texttt{channels} where we have at least $x$
      \State $\mathtt{remoteCom}_n \gets$ latest \texttt{remoteCom} in
      \texttt{channel}
      \State get the $\left(c_{n, \bob}, ph_{\mathrm{rev}, n} \vee
      \left(pt_{\mathrm{dpay}, n}, \mathtt{delay} \text{
      relative}\right)\right), \left(c_{n, \alice}, ph_{\mathrm{pay},
      n}\right),$ $\left(c_{n, i}, \text{htlc methods}_{n, i}\right)_{\left[1,
      \dots, m\right]}$ outputs of $\mathtt{remoteCom}_n$
      \State $ph_{\mathrm{rev}, n+1} \gets ph\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ph\_\mathrm{base}_{\mathrm{rev}} ||
      ph_{\mathrm{com}, n+1}\right) + ph_{\mathrm{com}, n+1} \cdot \mathcal{H}\left(
      ph_{\mathrm{com}, n+1} || ph\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{rev}, n+1} \gets pt\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(pt\_\mathrm{base}_{\mathrm{rev}} ||
      pt_{\mathrm{com}, n+1}\right) + pt_{\mathrm{com}, n+1} \cdot \mathcal{H}\left(
      pt_{\mathrm{com}, n+1} || pt\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{dpay}, n+1} \gets ph\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $pt_{\mathrm{dpay}, n+1} \gets pt\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $ph_{\mathrm{pay}, n+1} \gets ph\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $pt_{\mathrm{pay}, n+1} \gets pt\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $ph_{\mathrm{htlc}, n+1} \gets ph\_\mathrm{base}_{\mathrm{htlc}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{htlc}}\right)$
      \State $pt_{\mathrm{htlc}, n+1} \gets pt\_\mathrm{base}_{\mathrm{htlc}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{htlc}}\right)$
      \State $\mathtt{remoteCom}_{n+1} \gets$ TX \{input: output 1 of $F$,
      outputs:
      \State $\left(c_{n, \bob} - x, ph_{\mathrm{rev}, n+1} \vee
      \left(pt_{\mathrm{dpay}, n+1}, \mathtt{delay} \text{
      relative}\right)\right), \left(c_{n, \alice}, ph_{\mathrm{pay},
      n+1}\right),$ $\left(c_{n, i}, \text{htlc methods}_{n+1,
      i}\right)_{\left[1, \dots, m\right]}, \left(x, ph_{\mathrm{rev}, n+1}
      \vee \left(ph_{\mathrm{htlc}, n+1} \wedge pt_{\mathrm{htlc},
      n+1},\right.\right.$ $\left.\left.\mathtt{cltv\_expiry} \text{
      absolute}\right) \vee ph_{\mathrm{htlc}, n+1}, \text{on preimage of }
      h\right)$\}
      \State $\mathrm{ComSig} \gets
      \mathtt{signature}\left(\mathtt{remoteCom}_n, sh_F\right)$
      \State $\mathrm{HTLCSigs} \gets \emptyset$
      \For{i from 1 to $m$}
        \State $\mathtt{remoteHTLC}_{n+1, i} \gets$ TX \{input:
        output $\mathrm{htlc}_{n+1, i}$ of $\mathtt{remoteCom}_n$, output:
        $\text{htlc methods}_{n, i}$\}
        \State add $\mathtt{signature}\left(\mathtt{remoteHTLC}_{n+1, i},
        sh_{\mathrm{htlc}, n+1}\right)$ to HTLCSigs
      \EndFor
      \State $\mathtt{remoteHTLC}_{n+1, m+1} \gets$ TX \{input: output
      $\mathrm{htlc}_{n+1, m+1}$ of $\mathtt{remoteCom}_n$, output: $\left(x,
      ph_{\mathrm{rev}, n+1} \vee pt_{\mathrm{dpay}, n+1}, \mathtt{delay}
      \text{ relative}\right)$\} \Comment{HTLC timeout}
      \State add $\mathtt{signature}\left(\mathtt{remoteHTLC}_{n+1, m+1},
      sh_{\mathrm{htlc}, n+1}\right)$ to HTLCSigs
      \State send (\textsc{commitmentSigned}, \textit{pchid}, ComSig, HTLCSigs)
      to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{commitmentSigned}, \textit{pchid},
    $\mathtt{comSig}_{n+1}$, $\mathtt{HTLCSigs}_{n+1}$) from \bob:
    \Indent
      \State ensure \texttt{channel} with ID \textit{pchid} is marked ``waiting
      for \textsc{commitmentSigned}''
      \State $ph_{\mathrm{rev}, n+1} \gets ph\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ph\_\mathrm{base}_{\mathrm{rev}} ||
      ph_{\mathrm{com}, n+1}\right) + ph_{\mathrm{com}, n+1} \cdot \mathcal{H}\left(
      ph_{\mathrm{com}, n+1} || ph\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{rev}, n+1} \gets pt\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(pt\_\mathrm{base}_{\mathrm{rev}} ||
      pt_{\mathrm{com}, n+1}\right) + pt_{\mathrm{com}, n+1} \cdot \mathcal{H}\left(
      pt_{\mathrm{com}, n+1} || pt\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{dpay}, n+1} \gets ph\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $pt_{\mathrm{dpay}, n+1} \gets pt\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $ph_{\mathrm{pay}, n+1} \gets ph\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $pt_{\mathrm{pay}, n+1} \gets pt\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $ph_{\mathrm{htlc}, n+1} \gets ph\_\mathrm{base}_{\mathrm{htlc}} +
      \mathcal{H}\left(ph_{\mathrm{com}, n+1} ||
      ph\_\mathrm{base}_{\mathrm{htlc}}\right)$
      \State $pt_{\mathrm{htlc}, n+1} \gets pt\_\mathrm{base}_{\mathrm{htlc}} +
      \mathcal{H}\left(pt_{\mathrm{com}, n+1} ||
      pt\_\mathrm{base}_{\mathrm{htlc}}\right)$
      \State $\mathtt{localCom}_{n+1} \gets$ TX \{input: output 1 of $F$,
      outputs:
      \State $\left(c_{n, \alice} - x, pt_{\mathrm{rev}, n+1} \vee
      \left(ph_{\mathrm{dpay}, n+1}, \mathtt{delay} \text{
      relative}\right)\right), \left(c_{n, \bob}, pt_{\mathrm{pay},
      n+1}\right),$ $\left(c_{n, i}, \text{htlc methods}_{n, i}\right)_{\left[1,
      \dots, m\right]}, \left(x, pt_{\mathrm{rev}, n+1} \vee
      \left(pt_{\mathrm{htlc}, n+1} \wedge ph_{\mathrm{htlc}, n+1},
      \mathtt{cltv\_expiry}\right.\right.$ $\left.\left.\text{ absolute}\right)
      \vee pt_{\mathrm{htlc}, n+1}, \text{on preimage of } h\right)$\}
      \State ensure $\mathtt{verify}\left(\mathtt{localCom}_{n+1},
      \mathtt{comSig}_{n+1}, pt_F\right) = \mathtt{true}$
      \For{$j$ from $\mathtt{lastComHTLC}_{\mathit{pchid}}$ to
      $\mathtt{HTLCNo}_{\mathit{pchid}}$}
        \State $i \gets j - \mathtt{lastComHTLC}_{\mathit{pchid}} + 1$
        \State $\mathtt{localHTLC}_{n+1, i} \gets$ TX \{input:
        output $\mathrm{htlc}_{n+1, i}$ of $\mathtt{remoteCom}_n$, output:
        $\text{htlc methods}_{n, i}$\}
        \State ensure $\mathtt{verify}\left(\mathtt{localHTLC}_{n+1, i},
        \mathtt{HTLCSigs}_{n+1}\left[i\right], pt_{\mathrm{htlc}, n+1}\right) =
        \mathtt{true}$
      \EndFor
      \State $\mathtt{localHTLC}_{n+1, m+1} \gets$ TX \{input: output
      $\mathrm{htlc}_{n+1, m+1}$ of $\mathtt{localCom}_n$, output: $\left(x,
      pt_{\mathrm{rev}, n+1} \vee ph_{\mathrm{dpay}, n+1}, \mathtt{delay}
      \text{ relative}\right)$\} \Comment{HTLC timeout}
      \State ensure $\mathtt{verify}\left(\mathtt{localHTLC}_{n+1, m+1},
      \mathtt{HTLCSigs}_{n+1}\left[m+1\right], pt_{\mathrm{htlc}, n+1}\right) =
      \mathtt{true}$
      \State $\left(ph_{\mathrm{com}, n+2}, sh_{\mathrm{com}, n+2}\right) \gets
      \mathrm{genKey}\left(\right)$
      \State \orfeas{TODO start}
      \State generate remote commitment tx
      \State generate commitment signature
      \State $\mathrm{HTLCSigs} \gets \emptyset$
      \For{$j$ from $\mathtt{lastComHTLC}_{\mathit{pchid}}$ to
      $\mathtt{HTLCNo}_{\mathit{pchid}}$}
        \State $i \gets j - \mathtt{lastComHTLC}_{\mathit{pchid}} + 1$
        \State generate remote HTLCTimeout/HTLCSuccess
        \State generate
        $\mathtt{signature}\left(\mathtt{HTLCTimeout/Success}_{n+1, i},
        sh_{\mathrm{htlc}, n+1}\right)$ and add to HTLCSigs
      \EndFor
      \State $\mathtt{lastComHTLC}_{\mathit{pchid}} \gets
      \mathtt{HTLCNo}_{\mathit{pchid}}$
      \State \orfeas{TODO end}
      \State unmark \texttt{channel}
      \State \orfeas{TODO: understand when this party sends sigs for new
      commitment and htlc txs}
      \State send (\textsc{revokeAndAck}, \textit{pchid}, $sh_{\mathrm{com}, n},
      ph_{\mathrm{com}, n+2}$) to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{revokeAndAck}, \textit{pchid},
    $st_{\mathrm{com}, n}, pt_{\mathrm{com}, n+1}$) from \bob:
    \Indent
      \State ensure $pk\left(st_{\mathrm{com}, n}\right) = pt_{\mathrm{com}, n}$
      \State \orfeas{TODO: find out when this party sends old com\_secret and
      next com\_point}
      \If{terminal node}
        \State send back fulfill htlc
      \Else
        \State send forward update add htlc
      \EndIf
    \EndIndent
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from
    \environment:
    \Indent
      \State ensure \texttt{receipt} corresponds to an open $\mathtt{channel}
      \in \mathtt{channels}$
      \State assign latest \texttt{channel} sequence number to $n$
      \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathtt{localCom}_n,
      sh_F\right)$
      \State remove \texttt{channel} from \texttt{channels}
      \State send (\textsc{submit}, $\left(\mathrm{sig}, \mathtt{remoteSig}_n,
      \mathtt{localCom}_n\right)$) to \ledger
    \EndIndent
  \end{algorithmic}
\hrulefill
