\section{Lightning Protocol}
  \label{appendix:protocol}

  Simiarly to Fig.~\ref{alg:fpaynet:support} of \fpaynet, the registration of a
  new player consists of the generation a new keypair, the topping up of the
  public key with some initial funds and the non-serving of any other messages
  until registration is complete. The main difference is that here the keypair
  is generated locally.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ (self is \alice{} always) --
    support}
      \begin{algorithmic}[1]
        \State Initialisation:
        \Indent
          \ifelseieee{
            \State $\mathtt{channels}, \mathtt{pendingOpen},
            \mathtt{pendingPay} \gets \emptyset$
            \State $\mathtt{pendingClose}, \mathtt{newChannels} \gets \emptyset$
            \State $\mathtt{closedChannels}, \mathtt{updatesToReport} \gets
            \emptyset$
            \State $\redden{\mathtt{paymentsToReport}} \gets \emptyset$
            \State $\mathtt{unclaimedOfferedHTLCs}, \redden{\mathtt{gotPaid}}
            \gets \emptyset$
            \State $\mathtt{unclaimedReceivedHTLCs}, \mathtt{pendingGetPaid}
            \gets \emptyset$
          }{
            \State $\mathtt{channels}, \mathtt{pendingOpen},
            \mathtt{pendingPay}, \mathtt{pendingClose},
            \redden{\mathtt{paymentsToReport}} \gets \emptyset$
            \State $\mathtt{newChannels}, \mathtt{closedChannels},
            \mathtt{updatesToReport}, \redden{\mathtt{gotPaid}} \gets \emptyset$
            \State $\mathtt{unclaimedOfferedHTLCs},
            \mathtt{unclaimedReceivedHTLCs}, \mathtt{pendingGetPaid} \gets
            \emptyset$
          }
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{register}, delay, relayDelay) from
        \environment:
        \Indent
          \State $\mathtt{delay} \gets \mathrm{delay}$ \Comment{Must check chain
          at least once every \texttt{delay} blocks}
          \label{alg:protocol:support:delay}
          \State $\mathtt{relayDelay} \gets \mathrm{relayDelay}$
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \label{alg:protocol:support:read}
          \State $\left(pk_{\alice}, sk_{\alice}\right) \gets
          \textsc{KeyGen}\left(\right)$
          \label{alg:protocol:support:keygen}
          \State send (\textsc{register}, \alice, \texttt{delay},
          \texttt{relayDelay}, $pk_{\alice}$) to \environment
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{toppedUp}) from \environment:
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State assign the sum of all output values that are exclusively
          spendable by \alice{} to \texttt{onChainBalance}
          \State send (\textsc{registered}) to \environment
        \EndIndent
        \Statex

        \State Upon receiving any message ($M$) except for
        $\left(\textsc{register}\right)$ or (\textsc{toppedUp}):
        \Indent
          \If{if haven't received (\textsc{register}) and (\textsc{toppedUp})
          from \environment{} (in this order)}
            \State send (\textsc{invalid}, $M$) to \environment{} and ignore
            message
          \EndIf
        \EndIndent
        \Statex

        \Function{GetKeys}{}
          \State $\left(p_F, s_F\right) \gets \textsc{KeyGen}\left(\right)$
          \Comment{For $F$ output}
          \label{alg:protocol:support:gen:fund}
          \State $\left(p_{\mathrm{pay}}, s_{\mathrm{pay}}\right) \gets
          \textsc{Setup}\left(\right)$ \Comment{For com output to remote}
          \State $\left(p_{\mathrm{dpay}}, s_{\mathrm{dpay}}\right) \gets
          \textsc{Setup}\left(\right)$ \Comment{For com output to self}
          \State $\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right) \gets
          \textsc{Setup}\left(\right)$ \Comment{For htlc output to self}
          \State $\texttt{seed} \overset{\$}{\gets} U(k)$ \Comment{For per com
          point}
          \State $\left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right) \gets
          \textsc{MasterKeyGen}\left(\right)$ \Comment{For revocation in com}
          \label{alg:protocol:support:gen:rev}
          \State \Return $\left(\left(p_F, s_F\right), \left(p_{\mathrm{pay}},
          s_{\mathrm{pay}}\right), \left(p_{\mathrm{dpay}},
          s_{\mathrm{dpay}}\right),\right.$
          \Indent
            \State $\left.\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right),
            \mathtt{seed}, \left(p_{\mathrm{rev}},
            s_{\mathrm{rev}}\right)\right)$
          \EndIndent
        \EndFunction
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:support}
  \end{figure}

  When a player receives \textsc{openChannel} from \environment, she generates a
  number of base keypairs (funding, payment, delayed payment, HTLC), along with
  a seed for the per-update key shares, a master keypair and a share keypair
  used for revocation. She then sends the public keys along with the desired
  delay and initial funds to the counterparty as specified by \environment{} in
  a message labeled also \textsc{openChannel}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{openChannel} from
    \environment}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x,
        \mathit{tid}\right)$ from \environment:
        \Indent
          \State ensure \textit{tid} hasn't been used for opening another
          channel before
          \label{alg:protocol:open:env:valid}
          \State \Comment{\redden{Keys marked with ``$b$'' are called basepoint
          keys. Their use reduces from three to one the public keys that have to
          be exchanged on each update.}}
          \State $\left(\left(ph_F, sh_F\right), \left(phb_{\mathrm{pay}},
          shb_{\mathrm{pay}}\right), \left(phb_{\mathrm{dpay}},
          shb_{\mathrm{dpay}}\right),\right.$ $\left.\left(phb_{\mathrm{htlc}},
          shb_{\mathrm{htlc}}\right), \mathtt{seed}, \left(phb_{\mathrm{rev}},
          shb_{\mathrm{rev}}\right)\right) \gets \texttt{GetKeys}\left(\right)$
          \State $\mathrm{prand}_1 \gets \textsc{PRF}\left(\mathtt{seed},
          1\right)$
          \label{alg:protocol:open:env:prf}
          \State $\left(ph_{\mathrm{com}, 1}, sh_{\mathrm{com}, 1}\right) \gets
          \textsc{KeyShareGen}\left(1^k; \mathrm{prand}_1\right)$
          \State associate keys with \textit{tid}
          \State add (\alice, \bob, $x$, \texttt{tid}, $(ph_F, sh_F)$,
          $(phb_{\mathrm{pay}}, shb_{\mathrm{pay}})$, $(phb_{\mathrm{dpay}},
          shb_{\mathrm{dpay}})$ $(phb_{\mathrm{htlc}}, shb_{\mathrm{htlc}})$,
          $(phb_{\mathrm{com}, 1}, shb_{\mathrm{com}, 1})$,
          $(phb_{\mathrm{rev}}, shb_{\mathrm{rev}})$, \textit{tid}) to
          \texttt{pendingOpen}
          \label{alg:protocol:open:env:pendingOpen}
          \State send (\textsc{openChannel}, $x, \mathtt{delay} + \tochain,
          ph_F, phb_{\mathrm{pay}}, phb_{\mathrm{dpay}}, phb_{\mathrm{htlc}},$
          $ph_{\mathrm{com}, 1}, phb_{\mathrm{rev}}$, \textit{tid}) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:env}
  \end{figure}

  When he receives \textsc{openChannel} by a funding party, the same steps are
  followed by the counterparty. The only difference is that he labels his reply
  with \textsc{acceptChannel} instead.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{openChannel} from \bob}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{openChannel}, $x$, \texttt{remoteDelay},
        $pt_F$, $ptb_{\mathrm{pay}}$, $ptb_{\mathrm{dpay}}$,
        $ptb_{\mathrm{htlc}}$, $pt_{\mathrm{com}, 1}$, $ptb_{\mathrm{rev}}$,
        \textit{tid}) from \bob:
        \Indent
          \State ensure \textit{tid} has not been used yet with \bob
          \State ($(ph_F, sh_F)$, $(phb_{\mathrm{pay}}, shb_{\mathrm{pay}})$,
          $(phb_{\mathrm{dpay}}, shb_{\mathrm{dpay}})$, $(phb_{\mathrm{htlc}},
          shb_{\mathrm{htlc}})$, \texttt{seed} $(phb_{\mathrm{rev}},
          shb_{\mathrm{rev}})$) $\gets$ \texttt{GetKeys}()
          \State $\mathrm{prand}_1 \gets \textsc{PRF}\left(\mathtt{seed},
          1\right)$
          \label{alg:protocol:open:peer:prf}
          \State $\left(ph_{\mathrm{com}, 1}, sh_{\mathrm{com}, 1}\right) \gets
          \textsc{KeyShareGen}\left(1^k; \mathrm{prand}_1\right)$
          \State associate keys with \textit{tid} and store in
          \texttt{pendingOpen}
          \label{alg:protocol:open:openChannel:pendingOpen}
          \State send (\textsc{acceptChannel}, $\mathtt{delay}  + \tochain,
          ph_F, phb_{\mathrm{pay}}, phb_{\mathrm{dpay}}, phb_{\mathrm{htlc}},$
          $ph_{\mathrm{com}, 1}, phb_{\mathrm{rev}}$, \textit{tid}) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:openChannel}
  \end{figure}

  When she receives \textsc{acceptChannel} by the counterparty, the funding
  party creates the funding transaction and the first commitment transaction,
  signs the funding transaction and sends this signature to the counterparty
  with a message labelled \textsc{fundingCreated}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{acceptChannel}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{acceptChannel}, $\mathtt{remoteDelay},
        pt_F, ptb_{\mathrm{pay}}, ptb_{\mathrm{dpay}},$ $ptb_{\mathrm{htlc}},$
        $pt_{\mathrm{com}, 1}, ptb_{\mathrm{rev}}$, \textit{tid}) from \bob:
        \Indent
          \State ensure there is a temporary ID \textit{tid} with \bob{} in
          \texttt{pendingOpen} on which \textsc{acceptChannel} hasn't been
          received
          \State associate received keys with \textit{tid}
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State assign to \texttt{prevout} a transaction output found in
          $\Sigma_{\alice}$ that is currently exclusively spendable by \alice{}
          and has value $y \geq x$
          \State $F \gets$ TX \{input spends \texttt{prevout} with a
          \textsc{SignDS}(TX, $sk_{\alice}$), output 0 pays $y - x$ to
          $pk_{\alice}$, output 1 pays $x$ to $\mathit{tid}.ph_F \wedge pt_F$\}
          \State $\mathit{pchid} \gets \mathcal{H}\left(F\right)$
          \State add \textit{pchid} to \texttt{pendingOpen} entry with id
          \textit{tid}
          \State $pt_{\mathrm{rev}, 1} \gets
          \textsc{CombinePubKey}\left(ptb_{\mathrm{rev}}, ph_{\mathrm{com},
          1}\right)$
          \State $(ph_{\mathrm{dpay}, 1}, sh_{\mathrm{dpay}, 1}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{dpay}}, shb_{\mathrm{dpay}},
          ph_{\mathrm{com}, 1}\right)$
          \State $(ph_{\mathrm{pay}, 1}, sh_{\mathrm{pay}, 1}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{pay}}, shb_{\mathrm{pay}},
          ph_{\mathrm{com}, 1}\right)$
          \State $(ph_{\mathrm{htlc}, 1}, sh_{\mathrm{htlc}, 1}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{htlc}}, shb_{\mathrm{htlc}},
          ph_{\mathrm{com}, 1}\right)$
          \State $\mathtt{remoteCom} \gets \mathtt{remoteCom}_1 \gets$ TX
          \{input: output 1 of $F$, outputs: $(x, ph_{\mathrm{pay}, 1})$, $(0,
          ph_{\mathrm{rev}, 1} \vee (pt_{\mathrm{dpay}, 1}, \mathtt{delay} +
          \tochain{} \text{ relative}))$\}
          \State $\mathtt{localCom} \gets$ TX \{input: output 1 of $F$, outputs:
          $(x, pt_{\mathrm{rev}, 1} \vee (ph_{\mathrm{dpay}, 1},
          \mathtt{remoteDelay} \text{ relative}))$, $(0, pt_{\mathrm{pay},
          1})$\}
          \State add $\mathtt{remoteCom}$ and $\mathtt{localCom}$ to channel
          entry in \texttt{pendingOpen}
          \State $\mathrm{sig} \gets \textsc{SignDS}\left(\mathtt{remoteCom}_1,
          sh_F\right)$
          \State $\mathtt{lastRemoteSigned} \gets 0$
          \State send (\textsc{fundingCreated}, \textit{tid},
          \textit{pchid}, sig) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:acceptChannel}
  \end{figure}

  When he receives \textsc{fundingCreated} by the funding party, the
  counterparty creates the funding transaction and then checks the validity of
  the received signature. If it is valid, he then creates the first commitment
  transaction as well, signs the funding transaction and sends this signature to
  the funding party with a message labelled \textsc{fundingSigned}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{fundingCreated}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingCreated}, \textit{tid},
        \textit{pchid}, $\mathtt{BobSig}_1$) from \bob:
        \Indent
          \State ensure there is a temporary ID \textit{tid} with \bob{} in
          \texttt{pendingOpen} on which we have sent up to
          \textsc{acceptChannel}
          \State $ph_{\mathrm{rev}, 1} \gets
          \textsc{CombinePubKey}\left(phb_{\mathrm{rev}} pt_{\mathrm{com},
          1}\right)$
          \State $pt_{\mathrm{dpay}, 1} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{dpay}}, pt_{\mathrm{com},
          1}\right)$
          \State $pt_{\mathrm{pay}, 1} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{pay}}, pt_{\mathrm{com},
          1}\right)$
          \State $pt_{\mathrm{htlc}, 1} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{htlc}}, pt_{\mathrm{com},
          1}\right)$
          \State $\mathtt{localCom} \gets \mathtt{localCom}_1 \gets$ TX \{input:
          output 1 of $F$, outputs: $(x, pt_{\mathrm{pay}, 1})$, $(0,
          pt_{\mathrm{rev}, 1} \vee (ph_{\mathrm{dpay}, 1}, \mathtt{remoteDelay}
          \text{ relative})$\}
          \State ensure $\textsc{VerifyDS}\left(\mathtt{BobSig}_1,
          \mathtt{localCom}_1, pt_F\right) = \mathtt{True}$
          \State $\mathtt{remoteCom} \gets \mathtt{remoteCom}_1 \gets$ TX
          \{input: output 1 of $F$, outputs: $(x, ph_{\mathrm{rev}, 1} \vee
          (pt_{\mathrm{dpay}, 1}, \mathtt{delay} + \tochain{} \text{
          relative}))$, $(0, ph_{\mathrm{pay}, 1})$\}
          \State add $\mathtt{BobSig}_1, \mathtt{remoteCom}_1$ and
          $\mathtt{localCom}_1$ to channel entry in \texttt{pendingOpen}
          \State $\mathrm{sig} \gets \textsc{SignDS}\left(\mathrm{remoteCom}_1,
          sh_F\right)$
          \State mark channel as ``broadcast, no \textsc{fundingLocked}''
          \label{alg:protocol:open:fundingCreated:mark}
          \State $\mathtt{lastRemoteSigned}, \mathtt{lastLocalSigned} \gets 0$
          \State send (\textsc{fundingSigned}, \textit{pchid}, sig) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:fundingCreated}
  \end{figure}

  When the funding party receives \textsc{fundingSigned}, she verifies the
  validity of the received signature. If it is valid, it broadcasts the funding
  transaction.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{fundingSigned}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingSigned}, \textit{pchid},
        $\mathtt{BobSig}_1$) from \bob:
        \Indent
          \State ensure there is a channel ID \textit{pchid} with \bob{} in
          \texttt{pendingOpen} on which we have sent up to
          \textsc{fundingCreated}
          \State ensure $\textsc{VerifyDS}\left(\mathtt{BobSig}_1,
          \mathtt{localCom}, pb_F\right) = \mathtt{True}$
          \State $\mathtt{localCom}_1 \gets \mathtt{localCom}$
          \State $\mathtt{lastLocalSigned} \gets 0$
          \State add $\mathtt{BobSig}_1$ to channel entry in
          \texttt{pendingOpen}
          \State $\mathrm{sig} \gets \textsc{SignDS}\left(F,
          sk_{\mathit{Alice}}\right)$
          \State mark \textit{pchid} in \texttt{pendingOpen} as ``broadcast, no
          \textsc{fundingLocked}''
          \label{alg:protocol:open:fundingSigned:mark}
          \State send (\textsc{submit}, $\left(\mathrm{sig}, F\right)$) to
          \ledger
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:open:fundingSigned}
  \end{figure}

  When either party (say \alice) receives \textsc{checkForNew} from
  \environment, she checks if the funding transaction is in the ledger. If it
  is, it generates the keyshare for the next update and sends it to \bob{} in a
  message labelled \textsc{fundingLocked}. When \alice{} receives a similar
  message from \bob, she considers the channel open.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{checkForNew}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{checkForNew}, \alice, \bob, \textit{tid})
        from \environment: \Comment{lnd polling daemon}
        \Indent
          \State ensure there is a matching \texttt{channel} in
          \texttt{pendingOpen} with id \textit{pchid}, with a ``broadcast''
          and a ``no \textsc{fundingLocked}'' mark, funded with $x$ coins
          \label{alg:protocol:checkForNew:valid}
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \label{alg:protocol:checkForNew:read}
          \State ensure $\exists$ unspent TX in $\Sigma_{\alice}$ with ID
          \textit{pchid} and a $\left(x, ph_F \wedge pt_F\right)$ output
          \label{alg:protocol:checkForNew:included}
          \State $\mathrm{prand}_2 \gets \textsc{PRF}\left(\mathtt{seed},
          2\right)$
          \label{alg:protocol:checkForNew:prand}
          \State $\left(ph_{\mathrm{com}, 2}, sh_{\mathrm{com}, 2}\right) \gets
          \textsc{KeyShareGen}\left(1^k; \mathrm{prand}_2\right)$
          \State add TX to \texttt{channel} data
          \State replace ``broadcast'' mark in \texttt{channel} with
          ``\textsc{fundingLocked} sent''
          \State send (\textsc{fundingLocked}, \textit{pchid},
          $ph_{\mathrm{com}, 2}$) to \bob{}
          \label{alg:protocol:checkForNew:send}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:checkForNew}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{fundingLocked}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fundingLocked}, \textit{pchid},
        $pt_{\mathrm{com}, 2}$) from \bob:
        \Indent
          \State ensure there is a \texttt{channel} with ID \textit{pchid} with
          \bob{} in \texttt{pendingOpen} with a ``no \textsc{fundingLocked}''
          mark
          \If{\texttt{channel} is not marked with ``\textsc{fundingLocked}
          sent''} \Comment{i.e. marked with ``broadcast''}
            \State send (\textsc{read}) to \ledger{} and assign reply to
            $\Sigma_{\alice}$
            \State ensure $\exists$ unspent TX in $\Sigma_{\alice}$ with ID
            \textit{pchid} and a $\left(x, ph_F \wedge pt_F\right)$ output
            \State add TX to \texttt{channel} data
            \State $\mathrm{prand}_2 \gets \textsc{PRF}\left(\mathtt{seed},
            2\right)$
            \label{alg:protocol:fundingLocked:prand}
            \State $\left(ph_{\mathrm{com}, 2}, sh_{\mathrm{com}, 2}\right) \gets
            \textsc{KeyShareGen}\left(1^k; \mathrm{prand}_2\right)$
            \State generate 2nd remote delayed payment, htlc, payment keys
          \EndIf
          \State replace ``no \textsc{fundingLocked}'' mark in \texttt{channel}
          with ``\textsc{fundingLocked} received''
          \State move channel data from \texttt{pendingOpen} to
          \texttt{channels}
          \State add receipt of channel to \texttt{newChannels}, where
          $\mathrm{receipt} \gets (\alice: x, \bob: 0, \mathit{pchid})$
          \label{alg:protocol:fundingLocked:report}
          \If{\texttt{channel} is not marked with ``\textsc{fundingLocked}
          sent''}
            \State replace ``broadcast'' mark in \texttt{channel} with
            ``\textsc{fundingLocked} sent''
            \State send (\textsc{fundingLocked}, \textit{pchid},
            $ph_{\mathrm{com}, 2}$) to \bob{}
          \EndIf
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:fundingLocked}
  \end{figure}

  When a player receives \textsc{poll}, she checks the ledger for closed
  channels and acts upon them. In particular, she retrieves funds from failed
  HTLC payments and punishes counterparties that closed their channel
  maliciously. She also takes note of honestly closed channels. When she
  receives \textsc{getNews}, she sends back a list of all unreported channels
  that opened or closed, along with payments that were carried out successfully.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- poll}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{poll}) from \environment:
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \label{alg:protocol:poll:read}
          \State $\mathtt{toSubmit} \gets \emptyset$
          \label{alg:protocol:poll:afterread}
          \ForAll{$\tau \in \mathtt{unclaimedOfferedHTLCs}$}
            \If{input of $\tau$ has been spent} \Comment{by
            \texttt{remote HTLC-success}}
              \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
              \If{we are intermediary}
                \State retrieve preimage $R$, $\mathit{pchid}'$ of previous
                channel on the path of the HTLC, and $\mathtt{HTLCNo}'$ of the
                corresponding $\mathrm{HTLC}'$ in $\mathit{pchid}'$
                \State add $\left(\mathtt{HTLCNo}', R\right)$ to
                $\mathtt{pendingFulfills}_{\mathit{pchid}'}$
              \EndIf
            \ElsIf{input of $\tau$ has not been spent and timelock is over}
              \State remove $\tau$ from \texttt{unclaimedOfferedHTLCs}
              \State add $\tau$ to \texttt{toSubmit}
            \EndIf
          \EndFor
          \State run loop of Fig.~\ref{alg:protocol:poll:closedch}
          \ForAll{honestly closed $\mathtt{remoteCom}_n$ that were processed
          above, with channel id \textit{pchid}}
            \ForAll{received HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
              \If{there is an entry in
              $\mathtt{pendingFulfills}_{\mathit{pchid}}$ with the same
              \texttt{HTLCNo} and $R$}
                \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
                $\mathtt{remoteCom}_n$ with $\left(ph_{\mathrm{htlc}, n},
                R\right)$ as method, output: $pk_{\alice}$\}
                \State $\mathrm{sig} \gets \textsc{SignIBS}\left(TX,
                sh_{\mathrm{htlc}, n}\right)$
                \State add (sig, TX) to \texttt{toSubmit}
                \State remove entry from
                $\mathtt{pendingFulfills}_{\mathit{pchid}}$
              \EndIf
            \EndFor
          \EndFor
          \label{alg:protocol:poll:beforesubmit}
          \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger
          \label{alg:protocol:poll:submit}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{getNews}) from \environment:
        \label{alg:protocol:getnews}
        \Indent
          \State clear \texttt{newChannels}, \texttt{closedChannels},
          \texttt{updatesToReport}, \redden{\texttt{paymentsToReport}} and send
          them to \environment{} with message name \textsc{news}
          \label{alg:protocol:getnews:send}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:poll}
  \end{figure}

  \begin{figure}[H]
    \begin{titlebox}{\normalfont Loop over closed channels for
    poll}{commonbox}{normal}
      \begin{algorithmic}[1]
        \ForAll{$\mathtt{remoteCom}_n \in \Sigma_{\alice}$ that spend $F$ of a
        $\mathtt{channel} \in \mathtt{channels}$}
        \label{alg:protocol:poll:closedch:loop}
          \If{we do not have $sh_{\mathrm{rev}, n}$} \Comment{Honest closure}
            \ForAll{unspent offered HTLC outputs $i$ of
            $\mathtt{remoteCom}_n$}
              \State $\mathrm{TX} \gets$ \{input: $i$ HTLC output of
              $\mathtt{remoteCom}_n$ with $ph_{\mathrm{htlc}, n}$ as method,
              output: $pk_{\alice}$\}
              \State $\mathrm{sig} \gets \textsc{SignIBS}\left(TX,
              sh_{\mathrm{htlc}, n}\right)$
              \If{timelock has not expired}
                \State add (sig, TX) to \texttt{unclaimedOfferedHTLCs}
              \ElsIf{timelock has expired}
                \State add (sig, TX) to \texttt{toSubmit}
                \label{alg:protocol:poll:htlc:submit}
              \EndIf
            \EndFor
            \ForAll{spent offered HTLC output $i$ of $\mathtt{remoteCom}_n$}
            \label{alg:protocol:poll:htlc:spent:loop}
              \If{we are intermediary}
                \State retrieve preimage $R$, $\mathit{pchid}'$ of previous
                channel on the path of the HTLC, and $\mathtt{HTLCNo}'$ of the
                corresponding $\mathrm{HTLC}'$ in $\mathit{pchid}'$
                \State add $\left(\mathtt{HTLCNo}', R\right)$ to
                $\mathtt{pendingFulfills}_{\mathit{pchid}'}$
              \redden{\Else \Comment{we are the payer}
                \State retrieve (\textit{expayid}, $x$) from entry in
                \texttt{pendingPay} with $h$, \texttt{HTLCNo} of
                $\mathrm{HTLC}_i$ and remove the entry
                \label{alg:protocol:poll:report:pendingPay}
                \State add (\textit{expayid}, $-x$) to \texttt{paymentsToReport}
                \label{alg:protocol:poll:report:pay}}
              \EndIf
            \EndFor
          \Else \ \Comment{malicious closure}
          \label{alg:protocol:poll:mal}
            \State $\mathrm{rev} \gets$ TX \{inputs: all
            $\mathtt{remoteCom}_n$ outputs, choosing $ph_{\mathrm{rev}, n}$
            method, output: $pk_{\mathit{Alice}}$\}
            \label{alg:protocol:poll:mal:tx}
            \State $\mathrm{sig} \gets \textsc{SignCS}\left(\mathrm{rev},
            sh_{\mathrm{rev}, n}\right)$
            \State add $\left(\mathrm{sig}, \mathrm{rev}\right)$ to
            \texttt{toSubmit}
            \label{alg:protocol:poll:mal:submit}
          \EndIf
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{closedChannels}
          \label{alg:protocol:poll:report}
          \State remove \texttt{channel} from \texttt{channels}
          \label{alg:protocol:poll:remove}
        \EndFor
      \end{algorithmic}
    \end{titlebox}
    \caption{}
    \label{alg:protocol:poll:closedch}
  \end{figure}

  When a player (say \alice) receives \textsc{pay} along with a payee (say
  \bob), a payment amount and a path, she informs \bob{} of the upcoming payment
  with a \textsc{sendInvoice} message. He then generates a secret preimage and
  sends back its hash and his desired minimum slack between the present and the
  moment he has to disclose the preimage (known as ``relay delay'') in a message
  labelled \textsc{invoice}. Subsequently \alice{} prepares a Sphinx onion
  packet~\cite{sphinx} with one message for each path member, taking into
  account each hop's desired relay delay. Afterwards she creates an HTLC that
  transfers the payment amount and adds it to her channel with the first path
  member. She then sends the onion, the payment amount and the hash to the first
  hop in a message labelled \textsc{updateAddHtlc}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- pay}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pay}, \bob, $x$,
        $\overrightarrow{\mathtt{path}}$, \redden{\textit{expayid}}) from
        \environment:
        \Indent
          \State ensure that $\overrightarrow{\mathtt{path}}$ consists of
          syntactically valid (\textit{pchid}, \texttt{CltvExpiryDelta}) pair
          \Comment{Payment completes only if $\forall \text{ honest } i \in
          \overrightarrow{\mathtt{path}}, \mathtt{CltvExpiryDelta}_i \geq 3k +
          \mathtt{RelayDelay}_i$}
          \label{alg:protocol:pay:validpath}
          \State ensure that the first $\mathit{pchid} \in
          \overrightarrow{\mathtt{path}}$ corresponds to an open
          $\mathtt{channel} \in \mathtt{channels}$ in which we own at least $x$
          in the irrevocably committed state.
          \label{alg:protocol:pay:validchannel}
          \State choose unique payment ID \textit{payid} \Comment{unique for
          \alice{} and \bob}
          \State add (\bob, $x$, $\overrightarrow{\mathtt{path}}$,
          \redden{\textit{expayid}}, \textit{payid}, ``waiting for invoice'') to
          \texttt{pendingPay}
          \State send (\textsc{sendInvoice}, \redden{$x$, \textit{expayid}},
          \textit{payid}) to \bob{}
          \label{alg:protocol:pay:sendinvoice}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{sendInvoice}, \redden{$x$,
        \textit{expayid}}, \textit{payid}) from \bob:
        \label{alg:protocol:pay:sendinvoice:receive}
        \Indent
          \State ensure there is no (\bob, \redden{\_, \textit{expayid},}
          \textit{payid}, \redden{\_}) entry in \texttt{pendingGetPaid}
          \State choose random, unique preimage $R$
          \State add (\bob, $R$, \redden{\textit{expayid},} \textit{payid},
          \redden{$x$}) to \texttt{pendingGetPaid}
          \State send (\textsc{invoice}, $\mathcal{H}(R)$, $\mathtt{relayDelay}
          + \tochain{}$, \textit{payid}) to \bob{}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:outofband}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- invoice}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{invoice}, $h$,
        \texttt{minFinalCltvExpiry}, \textit{payid}) from \bob:
        \label{alg:protocol:pay:invoice:receive}
        \Indent
          \State ensure there is a (\bob, $x$, $\overrightarrow{\mathtt{path}}$,
          \redden{\_,} \textit{payid}, ``waiting for invoice'') entry in
          \texttt{pendingPay}
          \State ensure $h$ is valid (in the range of $\mathcal{H}$)
          \State \redden{remove mark from, add $h$ and \texttt{HTLCNo} to entry
          in \texttt{pendingPay}}
          \State retrieve \texttt{CltvExpiryDelta}s from
          $\overrightarrow{\mathtt{path}}$
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to $t$
          \State $l \gets |\left(\overrightarrow{\mathtt{path}}\right)|$
          \State $\mathtt{CltvExpiry}_l \gets t + \mathtt{minFinalCltvExpiry}$
          \State $\forall i \in \{1, \dots, l - 1\}, \mathtt{CltvExpiry}_{l - i}
          \gets \mathtt{CltvExpiry}_{l - i + 1} + \mathtt{CltvExpiryDelta}_{l -
          i + 1}$
          \label{alg:protocol:pay:invoice:cltv}
          \State ensure $\mathtt{CltvExpiry}_1 \geq \mathtt{CltvExpiry}_2 +
          \mathtt{relayDelay} + \tochain$
          \State $m \gets$ the concatenation of $l \left(x,
          \mathtt{CltvExpiry}\right)$
          \State $\left(\mu_0, \delta_0\right) \gets
          \mathtt{SphinxCreate}\left(m, \text{ public keys of }
          \overrightarrow{\mathtt{path}} \text{ parties}\right)$
          \State let $\mathtt{remoteCom}_n$ the latest signed remote commitment
          tx with first $\overrightarrow{\mathtt{path}}$ member
          \State reduce simple payment output in \texttt{remoteCom} by $x$
          \State add an additional ($x$, $ph_{\mathrm{rev}, n+1}$ $\vee$
          ($ph_{\mathrm{htlc}, n+1}$ $\wedge$ $pt_{\mathrm{htlc}, n+1}$,
          on preimage of $h$) $\vee$
          $ph_{\mathrm{htlc}, n+1}$, $\mathtt{CltvExpiry}_1$ absolute)
          output (all with $n+1$ keys) to \texttt{remoteCom}, marked with
          \texttt{HTLCNo}
          \State reduce delayed payment output in \texttt{localCom} by $x$
          \State add an additional ($x$, $pt_{\mathrm{rev}, n+1}$ $\vee$
          ($pt_{\mathrm{htlc}, n+1}$, on preimage of $h$) $\vee$
          ($ph_{\mathrm{htlc}, n+1}$ $\wedge$ $pt_{\mathrm{htlc}, n+1}$,
          $\mathtt{CltvExpiry}_1$ absolute)) output (all with $n+1$ keys) to
          \texttt{localCom}, marked with \texttt{HTLCNo}
          \State increment $\mathtt{HTLCNo}_{\mathit{pchid}}$ by one and
          associate $x, h, \mathit{pchid}$ with it
          \State mark \texttt{HTLCNo} as ``sender''
          \State send (\textsc{updateAddHtlc}, first \textit{pchid} of
          $\overrightarrow{\mathtt{path}}, \mathtt{HTLCNo}_{\mathit{pchid}}, x,
          h, \mathtt{CltvExpiry}_1, \left(\mu_0, \delta_0\right)$) to
          \textit{pchid} channel counterparty
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:invoice}
  \end{figure}

  When a player receives \textsc{updateAddHtlc}, she peels the outermost onion
  layer and extracts the CLTV expiry, the next channel ID (or $\bot$ if she is
  the payee) and the payment amount. She checks that the CLTV expiry is within
  her desired relay delay and adds to the incoming channel an HTLC that pays her
  the payment amount. If she is the payee, she prepares to disclose the
  preimage. Otherwise, she creates an HTLC that transfers the payment amount
  from her to the next party of the path, prepares the next onion and takes a
  note to send it to the next party.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{updateAddHtlc}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{updateAddHtlc}, \textit{pchid},
        \texttt{HTLCNo}, $x$, $h$, \texttt{IncomingCltvExpiry}, $M$) from \bob:
        \label{alg:protocol:pay:updateAddHtlc:receive}
        \Indent
          \State run code of Fig.~\ref{alg:protocol:pay:updateAddHtlc:checks} --
          \textsc{updateAddHtlc} checks
          \State increment $\mathtt{HTLCNo}_{\mathit{pchid}}$ by one
          \State let $\mathtt{remoteCom}_n$ the latest signed remote commitment
          tx
          \State reduce delayed payment output in \texttt{remoteCom} by $x$
          \State add an ($x$, $ph_{\mathrm{rev}, n+1}$ $\vee$
          ($ph_{\mathrm{htlc}, n+1}$ $\wedge$ $pt_{\mathrm{htlc}, n+1}$,
          \texttt{IncomingCltvExpiry} absolute) $\vee$ $ph_{\mathrm{htlc},
          n+1}$, on preimage of $h$) htlc output (all with $n+1$ keys) to
          \texttt{remoteCom}, marked with \texttt{HTLCNo}
          \State reduce simple payment output in \texttt{localCom} by $x$
          \State add an ($x$, $pt_{\mathrm{rev}, n+1}$ $\vee$
          \redden{(}$pt_{\mathrm{htlc}, n+1}$, \texttt{IncomingCltvExpiry}
          absolute) $\vee$ ($pt_{\mathrm{htlc}, n+1}$ $\wedge$
          $ph_{\mathrm{htlc}, n+1}$, on preimage of $h$)) htlc output (all with
          $n+1$ keys) to \redden{\texttt{localCom}}, marked with \texttt{HTLCNo}
          \If{$\delta = \mathtt{receiver}$}
            \State retrieve $R : \mathcal{H}\left(R\right) = h$ from
            \texttt{pendingGetPaid} and \redden{move entry to \texttt{gotPaid}}
            \label{alg:protocol:pay:updateAddHtlc:gotpaid}
            \State add $\left(\mathtt{HTLCNo}, R\right)$ to
            $\mathtt{pendingFulfills}_{\mathit{pchid}}$
          \ElsIf{$\delta \neq \mathtt{receiver}$} \Comment{Send HTLC to next
          hop}
            \State retrieve $\mathit{pchid}'$ data
            \State let $\mathtt{remoteCom}_n'$ the latest signed remote
            commitment tx
            \State reduce simple payment output in $\mathtt{remoteCom}'$ by $x$
            \State add an additional $\left(x,
            ph\redden{\redden{'}}_{\mathrm{rev}, n+1} \vee
            \left(ph\redden{'}_{\mathrm{htlc}, n+1} \wedge
            pt\redden{'}_{\mathrm{htlc}, n+1}, \text{ on
            preimage}\right.\right.$ $\left.\left.\text{of } h\right) \vee
            ph\redden{'}_{\mathrm{htlc}, n+1}, \mathtt{OutgoingCltvExpiry}
            \text{ absolute}\right)$ output (all with $n+1$ keys) to
            $\mathtt{remoteCom}'$, marked with $\texttt{HTLCNo}'$
            \State reduce delayed payment output in $\mathtt{localCom}'$ by $x$
            \State add an additional ($x$, $pt\redden{'}_{\mathrm{rev}, n+1}$
            $\vee$ ($pt\redden{'}_{\mathrm{htlc}, n+1}$, on preimage of $h$)
            $\vee$ ($pt\redden{'}_{\mathrm{htlc}, n+1}$ $\wedge$
            $ph\redden{'}_{\mathrm{htlc}, n+1},$ \texttt{OutgoingCltvExpiry}
            absolute)) output (all with $n+1$ keys) to
            $\redden{\mathtt{localCom}}'$, marked with $\texttt{HTLCNo}'$
            \State increment $\texttt{HTLCNo}'$ by 1
            \State $M' \gets \mathtt{SphinxPrepare}\left(M, \delta,
            sk_{\mathit{Alice}}\right)$
            \State add $\left(\mathtt{HTLCNo}', x, h,
            \mathtt{OutgoingCltvExpiry}, M'\right)$ to
            $\mathtt{pendingAdds}_{\mathit{pchid}'}$
          \EndIf
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:updateAddHtlc}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{updateAddHtlc} checks}
      \begin{algorithmic}[1]
        \State ensure \textit{pchid} corresponds to an open \texttt{channel}
        in \texttt{channels} where \bob{} has at least $x$
        \State ensure $\mathtt{HTLCNo} = \mathtt{HTLCNo}_{\mathit{pchid}} + 1$
        \State $\left(\mathit{pchid}', x', \mathtt{OutgoingCltvExpiry},
        \delta\right) \gets \mathtt{SphinxPeel}\left(sk_{\alice}, M\right)$
        \State send (\textsc{read}) to \ledger{} and assign largest block
        number to $t$
        \If{$\delta = \mathtt{receiver}$}
          \State ensure $\mathit{pchid}' = \bot, x = x',
          \mathtt{IncomingCltvExpiry} \geq \mathtt{OutgoingCltvExpiry} =
          \mathtt{minFinalCltvExpiry}$
          \State mark \texttt{HTLCNo} as ``receiver''
        \Else \ \Comment{We are \redden{an} intermediary}
          \State ensure $x = x', \mathtt{IncomingCltvExpiry} \geq
          \max\{\mathtt{OutgoingCltvExpiry}, t\} + \mathtt{relayDelay} +
          2\tochain{}$
          \label{alg:protocol:pay:updateAddHtlc:slack}
          \State ensure $\mathtt{pchid}'$ corresponds to an open channel in
          \texttt{channels} where we have at least $x$
          \State mark \texttt{HTLCNo} as ``intermediary''
        \EndIf
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:updateAddHtlc:checks}
  \end{figure}

  When a player receives a preimage for a particular HTLC in an
  \textsc{updateFulfillHtlc} message, she verifies the validity of the preimage,
  she removes the HTLC and incorporates the new balance to the commitment
  transactions and, if she is an intermediary, she sends the preimage to the
  previous party on the path if the channel is still open, or publishes the
  preimage on-chain otherwise.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{updateFulfillHtlc}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{updateFulfillHtlc}, \textit{pchid},
        \texttt{HTLCNo}, $R$) from \bob:
        \Indent
          \If{$\mathtt{HTLCNo} > \mathtt{lastRemoteSigned} \vee \mathtt{HTLCNo}
          > \mathtt{lastLocalSigned} \vee \mathcal{H}\left(R\right) \neq h$,
          where $h$ is the hash in the HTLC with number \texttt{HTLCNo}}
            \State close channel (as in
            Fig.~\ref{alg:protocol:close:unilateral})
            \State \Return
          \EndIf
          \State ensure \texttt{HTLCNo} is an offered HTLC (\texttt{localCom}
          has $h$ tied to a public key that we own)
          \State add value of HTLC to delayed payment of \texttt{remoteCom}
          \State remove HTLC output with number \texttt{HTLCNo} from
          \texttt{remoteCom}
          \State add value of HTLC to simple payment of \texttt{localCom}
          \State remove HTLC output with number \texttt{HTLCNo} from
          \texttt{localCom}
          \If{we have a channel $\mathit{phcid}'$ that has a received HTLC with
          hash $h$ with number $\mathtt{HTLCNo}'$} \Comment{We are an
          intermediary}
            \State send (\textsc{read}) to \ledger{} and assign reply to
            $\Sigma_{\alice}$
            \If{latest $\mathtt{remoteCom}'_n \in \Sigma_{\alice}$}
            \Comment{counterparty has gone on-chain}
              \State $\mathrm{TX} \gets$ \{input: ($\mathtt{remoteCom}'$ HTLC
              output with number $\mathtt{HTLCNo}', R$), output:
              $pk_{\alice}$\}
              \State $\mathrm{sig} \gets \textsc{SignIBS}\left(\mathrm{TX},
              sh_{\mathrm{htlc}, n}\right)$
              \State send (\textsc{submit}, (sig, TX)) to \ledger{}
              \Comment{shouldn't be already spent by remote
              \texttt{HTLCTimeout}}
              \label{alg:protocol:pay:updateFulfillHtlc:submit}
            \Else \ \Comment{counterparty still off-chain}
              \State \Comment{Not having the HTLC irrevocably committed is
              impossible (Fig.~\ref{alg:protocol:pay:push},
              l.~\ref{alg:protocol:pay:pushadd:choose})}
              \State send $\left(\textsc{updateFulfillHtlc}, \mathit{pchid}',
              \mathtt{HTLCNo}', R\right)$ to counterparty
            \EndIf
          \redden{\Else \Comment{We are the payer}
            \State retrieve (\textit{expayid}, $x$) from entry in
            \texttt{pendingPay} with $h$, \texttt{HTLCNo} and remove the entry
            \Comment{entry is unique because of \texttt{HTLCNo}}
            \State add (\textit{expayid}, $-x$) to
            \texttt{updateDiffs}(\texttt{channel}) of \texttt{channel} with ID
            \textit{pchid}
            \label{alg:protocol:pay:updateFulfillHtlc:updatediffs}
          \EndIf}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:updateFulfillHtlc}
  \end{figure}

  When a player receives \textsc{commit} from \environment{} accompanied by a
  channel ID, she generates and signs a new commitment tx and all new HTLC
  txs that correspond to unsigned added HTLCs. She then sends the signatures to
  the channel counterparty in a message labelled \textsc{commitmentSigned}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{commit}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{commit}, \textit{pchid}) from
        \environment:
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State retrieve latest remote commitment tx $\mathtt{remoteCom}_n$ in
          \texttt{channel}
          \State ensure $\mathtt{remoteCom} \neq \mathtt{remoteCom}_n$
          \Comment{there are uncommitted updates}
          \State ensure \texttt{channel} is not marked as ``waiting for
          \textsc{revokeAndAck}''
          \label{alg:protocol:pay:commit:nomark}
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to $t$
          \State undo adding all outgoing HTLCs in \texttt{remoteCom} for which
          we are intermediary and $\mathtt{IncomingCltvExpiry} < t +
          \mathtt{relayDelay} + \tochain$
          \State $\mathtt{remoteCom}_{n+1} \gets \mathtt{remoteCom}$
          \State $\mathrm{ComSig} \gets
          \textsc{SignDS}\left(\mathtt{remoteCom}_{n+1}, sh_F\right)$
          \State $\mathrm{HTLCSigs} \gets \emptyset$
          \For{$i$ from \texttt{lastRemoteSigned} + 1 to \texttt{HTLCNo}}
            \State $\mathtt{remoteHTLC}_{n+1, i} \gets$ TX \{input: HTLC output
            $i$ of $\mathtt{remoteCom}_{n+1}$, output: ($c_{\mathrm{htlc, i}}$,
            $ph_{\mathrm{rev}, n+1}$ $\vee$ ($pt_{\mathrm{dpay}, n+1}$,
            $\mathtt{delay} + \tochain{}$ relative))\}
            \State add $\textsc{SignIBS}\left(\mathtt{remoteHTLC}_{n+1, i},
            sh_{\mathrm{htlc}, n+1}\right)$ to HTLCSigs
          \EndFor
          \State $\mathtt{lastRemoteSigned} \gets \mathtt{HTLCNo}$
          \State mark \texttt{channel} as ``waiting for \textsc{revokeAndAck}''
          \label{alg:protocol:pay:commit:mark}
          \State send (\textsc{commitmentSigned}, \textit{pchid}, ComSig,
          HTLCSigs) to \textit{pchid} counterparty
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:commit}
  \end{figure}

  When a player receives \textsc{commitmentSigned} with some signatures for a
  particular channel, she verifies that the signatures correspond to the
  expected HTLCs (i.e. the added but unsigned ones) and that the signatures for
  the new commitment tx and said HTLCs are valid. She then generates the
  keyshare pair and sends its public part to the counterparty along with the
  secret part of the old keyshare in a message labelled \textsc{revokeAndAck}.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{commitmentSigned}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{commitmentSigned}, \textit{pchid},
        $\mathtt{comSig}_{n+1}$, $\mathtt{HTLCSigs}_{n+1}$) from \bob:
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid} with \bob
          \State retrieve latest local commitment tx $\mathtt{localCom}_n$ in
          \texttt{channel}
          \State ensure $\mathtt{localCom} \neq \mathtt{localCom}_n$ and
          $\mathtt{localCom} \neq \mathtt{pendingLocalCom}$
          \Comment{there are uncommitted updates}
          \If{$\textsc{VerifyDS}\left(\mathtt{comSig}_{n+1}, \mathtt{localCom},
          pt_F\right) = \mathtt{false} \vee |\mathtt{HTLCSigs}_{n+1}| \neq
          \mathtt{HTLCNo} - \mathtt{lastLocalSigned}$}
            \State close channel (as in Fig.~\ref{alg:protocol:close:unilateral})
            \State \Return
          \EndIf
          \For{$i$ from \texttt{lastLocalSigned} + 1 to \texttt{HTLCNo}}
            \State $\mathtt{localHTLC}_{n+1, i} \gets$ TX \{input: HTLC output
            $i$ of $\mathtt{localCom}$, output: ($c_{\mathrm{htlc, i}}$,
            $ph_{\mathrm{rev}, n+1}$ $\vee$ ($pt_{\mathrm{dpay}, n+1}$,
            \texttt{remoteDelay} relative))\}
            \If{\textsc{VerifyIBS}($\mathtt{HTLCSigs}_{n+1, i}$,
            $\mathtt{localHTLC}_{n+1, i}$, $pt_{\mathrm{htlc}, n+1}$) =
            \texttt{false}}
              \State close channel (as in
              Fig.~\ref{alg:protocol:close:unilateral})
              \State \Return
            \EndIf
          \EndFor
          \State $\mathtt{lastLocalSigned} \gets \mathtt{HTLCNo}$
          \State $\mathtt{pendingLocalCom} \gets \mathtt{localCom}$
          \State mark $\mathtt{pendingLocalCom}$ as ``irrevocably committed''
          \State $\mathrm{prand}_{n+2} \gets \textsc{PRF}\left(\mathtt{seed},
          n+2\right)$
          \label{alg:protocol:pay:commitmentSigned:prf}
          \State $\left(ph_{\mathrm{com}, n+2}, sh_{\mathrm{com}, n+2}\right)
          \gets \textsc{KeyShareGen}\left(1^k; \mathrm{prand}_{n+2}\right)$
          \State send (\textsc{revokeAndAck}, \textit{pchid}, $\mathrm{prand}_n,
          ph_{\mathrm{com}, n+2}$) to \bob
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:commitmentSigned}
  \end{figure}

  When a player receives \textsc{revokeAndAck} from a counterparty for a
  particular channel, she checks that the secret keyshare received corresponds
  to the public keyshare that had been received in the last
  \textsc{revokeAndAck} (or in the \textsc{fundingLocked} if this is the first
  \textsc{revokeAndAck} received for this channel) and then generates all the
  necessary new keys for the next update. There are now no more outstanding
  updates. Furthermore, if a closing of the channel is pending, execution
  continues with the closing sequence.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{revokeAndAck}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{revokeAndAck}, \textit{pchid},
        $st_{\mathrm{com}, n}, pt_{\mathrm{com}, n+2}$) from \bob:
        \Indent
          \State ensure there is a $\mathtt{channel} \in \mathtt{channels}$ with
          \bob{} with ID \textit{pchid} marked as ``waiting for
          \textsc{revokeAndAck}''
          \label{alg:protocol:pay:revokeAndAck:ensure}
          \If{$\textsc{TestKey}\left(pt_{\mathrm{com}, n}, st_{\mathrm{com},
          n}\right) \neq 1$} \Comment{wrong $st_{\mathrm{com}, n}$ - closing}
            \State close channel (as in
            Fig.~\ref{alg:protocol:close:unilateral})
            \State \Return
          \EndIf
          \State mark $\mathtt{remoteCom}_{n+1}$ as ``irrevocably committed''
          \State $\mathtt{localCom}_{n+1} \gets \mathtt{pendingLocalCom}$
          \State unmark \texttt{channel}
          \State \redden{append} \texttt{receipt}(\texttt{channel}) to
          \texttt{updatesToReport}
          \label{alg:protocol:pay:raa:report:updates}
          \redden{\ForAll{$(\_, \_, \textit{payid}, \mathtt{ref}) \in
          \mathtt{updateDiffs}(\mathtt{channel})$}
          \label{alg:protocol:pay:raa:loop:gotpaid}
            \State remove from \texttt{gotPaid} the entry referenced by
            \texttt{ref}
            \State strip \texttt{ref} and \textit{payid} from
            \texttt{updateDiffs}(\texttt{channel}) entry
          \EndFor
          \If{$\mathtt{updateDiffs}(\mathtt{channel}) \neq \emptyset$}
            \State add \texttt{updateDiffs}(\texttt{channel}) members to
            \texttt{paymentsToReport}
            \label{alg:protocol:pay:raa:report:payments}
          \EndIf}
          \State \redden{$\mathtt{updateDiffs}(\mathtt{channel}) \gets
          \emptyset$}
          \State $sh_{\mathrm{rev}, n} \gets
          \textsc{CombineKey}\left(phb_{\mathrm{rev}}, shb_{\mathrm{rev}},
          pt_{\mathrm{com} n}, st_{\mathrm{com}, n}\right)$
          \State $ph_{\mathrm{rev}, n+2} \gets
          \textsc{CombinePubKey}\left(phb_{\mathrm{rev}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $pt_{\mathrm{rev}, n+2} \gets
          \textsc{CombinePubKey}\left(ptb_{\mathrm{rev}}, ph_{\mathrm{com},
          n+2}\right)$
          \State $(ph_{\mathrm{dpay}, n+2}, sh_{\mathrm{dpay}, n+2}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{dpay}}, shb_{\mathrm{dpay}},
          ph_{\mathrm{com}, n+2}\right)$
          \State $pt_{\mathrm{dpay}, n+2} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{dpay}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $(ph_{\mathrm{pay}, n+2}, sh_{\mathrm{pay}, n+2}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{pay}}, shb_{\mathrm{pay}},
          ph_{\mathrm{com}, n+2}\right)$
          \State $pt_{\mathrm{pay}, n+2} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{pay}}, pt_{\mathrm{com},
          n+2}\right)$
          \State $(ph_{\mathrm{htlc}, n+2}, sh_{\mathrm{htlc}, n+2}) \gets
          \textsc{KeyDer}\left(phb_{\mathrm{htlc}}, shb_{\mathrm{htlc}},
          ph_{\mathrm{com}, n+2}\right)$
          \State $pt_{\mathrm{htlc}, n+2} \gets
          \textsc{PubKeyDer}\left(ptb_{\mathrm{htlc}}, pt_{\mathrm{com},
          n+2}\right)$
          \If{no outstanding HTLCs remain for this channel and the sequence for
          \textsc{closeChannel} or \textsc{shutdown}
          (Fig.~\ref{alg:protocol:close:coop}) has been initiated}
            \State continue execution at Fig.~\ref{alg:protocol:close:coop},
            l.~\ref{alg:protocol:close:coop:init:continue} or
            l.~\ref{alg:protocol:close:coop:shutdown:continue} respectively
          \EndIf
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:revokeAndAck}
  \end{figure}

  The following code defines a player's actions when she receives from
  \environment{} one of the three messages needed to ``nudge'' her to carry on
  with some particular part of the protocol. \textsc{pushFulfill} makes the
  player read a preimage of a hash from \ledger{} and use it to fulfill the
  relevant HTLC that pays her, \textsc{pushAdd} has the player send an
  \textsc{updateAddHtlc} message that is ready but has not yet been sent and
  \textsc{fulfillOnChain} requests that the player publish all HTLC txs that are
  about to expire on-chain. A player that does not receive such messages in time
  may end up losing funds albeit being honest; such a player is dubbed
  ``negligent''.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \textsc{push}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}) from
        \environment:
        \label{alg:protocol:pushfulfill:start}
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State choose a member (\texttt{HTLCNo}, $R$) of
          $\mathtt{pendingFulfills}_{\mathit{pchid}}$ that is both in an
          ``irrevocably committed'' $\mathtt{remoteCom}_n$ and
          $\mathtt{localCom}_n$
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_{\alice}$
          \State remove (\texttt{HTLCNo}, $R$) from
          $\mathtt{pendingFulfills}_{\mathit{pchid}}$
          \If{$\mathtt{remoteCom}_n \notin \Sigma_{\alice}$}
          \Comment{counterparty cooperative}
            \redden{\If{$\exists (\_, R, \mathit{expayid}, \mathit{payid}, x)
            \in \mathtt{gotPaid}$} \Comment{receiver}
              \State add ($\mathit{expayid}, x$, \textit{payid}, reference to
              \texttt{gotPaid} entry) to \texttt{updateDiffs}(\texttt{channel})
              \label{alg:protocol:pushfulfill:updatediffs}
            \EndIf}
            \State send (\textsc{updateFulfillHtlc}, \textit{pchid},
            \texttt{HTLCNo}, $R$) to \textit{pchid} counterparty
          \Else \ \Comment{counterparty gone on-chain}
            \redden{\If{$\exists (\_, R, \mathit{expayid}, \mathit{payid}, x)
            \in \mathtt{gotPaid}$}
            \label{alg:protocol:pushfulfill:check:gotpaid}
              \State remove entry from \texttt{gotPaid}
              \State add $(\mathit{expayid}, x)$ to \texttt{paymentsToReport}
              \label{alg:protocol:pushfulfill:report}
            \EndIf}
            \State $\mathrm{TX} \gets$ \{input: ($\mathtt{remoteCom}_n$ HTLC
            output with number $\mathtt{HTLCNo}, R$), output:
            $pk_{\alice}$\}
            \State $\mathrm{sig} \gets \textsc{SignIBS}\left(\mathrm{TX},
            sh_{\mathrm{htlc}, n}\right)$
            \State send (\textsc{submit}, (sig, TX)) to \ledger{}
            \Comment{shouldn't be already spent by remote \texttt{HTLCTimeout}}
            \label{alg:protocol:pushfulfill:submit}
          \EndIf
          \label{alg:protocol:pushfulfill:end}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{pushAdd}, \textit{pchid}) from
        \environment:
        \label{alg:protocol:pushadd:start}
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}$
          with ID \textit{pchid}
          \State choose a member $\left(\mathtt{HTLCNo}, x, h,
          \mathtt{CltvExpiry}, M\right)$ of
          $\mathtt{pendingAdds}_{\mathit{pchid}}$ that is both in an
          ``irrevocably committed'' $\mathtt{remoteCom}_n$ and
          $\mathtt{localCom}_n$
          \label{alg:protocol:pay:pushadd:choose}
          \State remove chosen entry from
          $\mathtt{pendingAdds}_{\mathit{pchid}}$
          \State send (\textsc{updateAddHtlc}, \textit{pchid}, \texttt{HTLCNo},
          $x, h, \mathtt{CltvExpiry}, M$) to \textit{pchid} counterparty
          \label{alg:protocol:pushadd:end}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:push}
  \end{figure}

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- \redden{\textsc{fulfillOnChain}}}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{fulfillOnChain}) from \environment:
        \label{alg:protocol:pay:foc:top}
        \Indent
          \State send (\textsc{read}) to \ledger{} and assign largest block
          number to $t$
          \label{alg:protocol:pay:foc:read}
          \State $\mathtt{toSubmit} \gets \emptyset$
          \label{alg:protocol:pay:foc:tosubmit}
          \ForAll{channels}
            \If{there exist HTLC\redden{s with hashes $h_1, \dots, h_k$} in
            latest $\mathtt{localCom}_n$ for which we have sent both
            \textsc{updateFulfillHtlc} and \textsc{commitmentSigned} to a
            transaction without \redden{those HTLCs} to counterparty, but have
            not received the corresponding \textsc{revokeAndAck}\redden{s} AND
            \redden{some of} the HTLC\redden{s} expire within $\left[t, t +
            \tochain{}\right]$}
              \State add $\mathtt{localCom}_n$ of the channel and all
              corresponding valid \texttt{HTLC-success}es and
              \texttt{HTLC-timeout}s (for both $\mathtt{localCom}_n$ and
              $\mathtt{remoteCom}_n$\footnote{Ensures funds retrieval if
              counterparty has gone on-chain}), along with their signatures to
              \texttt{toSubmit}
              \redden{\ForAll{such HTLCs for which we are the payee (i.e., we
              have received a (\textsc{sendInvoice}, $x$, \textit{expayid},
              \textit{payid}) message in response to which we generated and sent
              $h_i$)}
              \label{alg:protocol:pay:foc:payment:loop}
                \State add (\textit{expayid}, $x$) to \texttt{paymentsToReport}
                \label{alg:protocol:pay:foc:payment}
              \EndFor}
            \EndIf
          \EndFor
          \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger
          \label{alg:protocol:pay:foc:submit}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:pay:foc}
  \end{figure}

  When a player receives \textsc{forceCloseChannel} for a particular channel,
  she signs and publishes the latest commitment and HTLC txs for this particular
  channel, in effect unilateraly closing the channel.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- close unilaterally}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{forceCloseChannel}, \texttt{receipt},
        \textit{pchid}) from \environment:
        \Indent
          \State ensure \texttt{receipt} corresponds to an open
          $\mathtt{channel} \in \mathtt{channels}$ with ID \textit{pchid}
          \label{alg:protocol:close:unilateral:ensure}
          \If{the sequence for \textsc{closeChannel} has been initiated and is
          pending on clearing all outstanding HTLCs}
            \State forget this ``hook''
          \EndIf
          \State assign latest \texttt{channel} sequence number to $n$
          \State $\mathrm{HTLCs} \gets \emptyset$
          \For{every $\text{HTLC output} \in \mathtt{localCom}_n$ with number
          $i$}
            \redden{\If{there is a (\_, $R$, \textit{expayid}, \textit{payid},
            $x$) entry in \texttt{gotPaid} for $R$ the preimage of
            $\mathrm{HTLC}_i$}
            \label{alg:protocol:close:unilateral:check:gotpaid}
              \State remove entry from \texttt{gotPaid}
              \State add (\textit{expayid}, $x$) to \texttt{paymentsToReport}
              \label{alg:protocol:close:unilateral:report:payment}
            \EndIf}
            \State $\mathrm{sig} \gets
            \textsc{SignIBS}\left(\mathtt{localHTLC}_{n, i}, sh_{\mathrm{htlc},
            n}\right)$
            \State add $\left(\mathrm{sig}, \mathtt{HTLCSigs}_{n, i},
            \mathtt{localHTLC}_{n, i}\right)$ to HTLCs
          \EndFor
          \State $\mathrm{sig} \gets \textsc{SignDS}\left(\mathtt{localCom}_n,
          sh_F\right)$
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{closedChannels}
          \label{alg:protocol:close:unilateral:report}
          \State remove \texttt{channel} from \texttt{channels}
          \label{alg:protocol:close:unilateral:remove}
          \State send (\textsc{submit}, $\left(\mathrm{sig},
          \mathtt{remoteSig}_n, \mathtt{localCom}_n\right), \mathrm{HTLCs}$) to
          \ledger
          \label{alg:protocol:close:unilateral:submit}
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:close:unilateral}
  \end{figure}

  When a player receives \textsc{closeChannel} for a particular channel, she
  initiates the cooperative channel close sequence with the counterparty. The
  sequence includes completing all outstanding updates and creating, signing and
  publishing the ``closing'' transaction that spends the funding transaction and
  distributes the funds to the counterparties without timelocks.

  \begin{figure}[H]
    \begin{protocolbox}{$\Pi_{\mathrm{LN}}$ -- close cooperatively}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{closeChannel}, \texttt{receipt},
        \textit{pchid}) from \environment:
        \Indent
          \State ensure \texttt{receipt} corresponds to an open
          $\mathtt{channel} \in \mathtt{channels}$ with ID \textit{pchid}
          \label{alg:protocol:close:coop:ensure}
          \State stop serving any (\textsc{pay}, \textsc{closeChannel}) message
          from \environment{} \redden{and any (\textsc{UpdateAddHtlc},
          \textsc{sendInvoice}) message from counterparty} for this channel.
          \label{alg:protocol:close:coop:noserve}
          \State mark \texttt{channel} as ``coop closing''
          \If{there are outstanding HTLC outputs in the latest
          $\mathtt{localCom}_n$}
            \State continue from here when there are none left
          \EndIf
          \label{alg:protocol:close:coop:init:continue}
          \State send (\textsc{shutdown}, $pk_{\alice}$, \textit{pchid}) to \bob
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{shutdown}, $pk_{\bob}$, \textit{pchid})
        from \bob:
        \Indent
          \State ensure there is an open $\mathtt{channel} \in
          \mathtt{channels}$ with \bob{} with ID \textit{pchid}
          \If{\texttt{channel} is not marked ``coop closing''}
            \State \redden{stop serving any (\textsc{pay},
            \textsc{closeChannel}) message from \environment{} and any
            (\textsc{UpdateAddHtlc}, \textsc{sendInvoice}) message from
            counterparty for this channel.}
            \State mark channel as ``coop closing''
            \If{there are outstanding HTLC outputs in the latest
            $\mathtt{localCom}_n$}
              \State continue from here when there are none left
            \EndIf
            \label{alg:protocol:close:coop:shutdown:continue}
            \State send (\textsc{shutdown}, $pk_{\alice}$, \textit{pchid}) to
            \bob
          \Else
            \State $Cl \gets$ TX \{input spends \texttt{channel} funding TX
            output, outputs pay $x, y$ to $pk_{\alice}, pk_{\bob}$ respectively,
            alphabetically ordered by some fixed encoding of the keys, where $x$
            is \alice's and $y$ is \bob's balance in the latest \texttt{channel}
            state
            \State $\mathrm{sig} \gets \textsc{SignDS}(Cl, sk_{\alice})$
            \State send (\textsc{closingSigned}, sig, \textit{pchid}) to \bob
          \EndIf
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{closingSigned}, bobSig, \textit{pchid}) from
        \bob:
        \Indent
          \State ensure there is an open $\mathtt{channel} \in
          \mathtt{channels}$ with \bob with ID \textit{pchid}
          \label{alg:protocol:close:coop:signed:ensure:exists}
          \State ensure \texttt{channel} is marked as ``coop closing''
          \label{alg:protocol:close:coop:signed:ensure:marked}
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{closedChannels}
          \label{alg:protocol:close:coop:report}
          \State remove \texttt{channel} from \texttt{channels}
          \State $Cl \gets$ TX \{input spends \texttt{channel} funding TX
          output, outputs pay $x, y$ to $pk_{\alice}, pk_{\bob}$ respectively,
          alphabetically ordered by some fixed encoding of the keys, where $x$
          is \alice's and $y$ is \bob's balance in the latest \texttt{channel}
          state
          \State ensure $\textsc{VerifyDS}(\mathrm{bobSig}, Cl, pk_\bob) =
          \mathtt{True}$
          \label{alg:protocol:close:coop:signed:ensure:sig}
          \State $\mathrm{aliceSig} \gets \textsc{SignDS}(Cl, sk_{\alice})$
          \State sort aliceSig, bobSig according to the ordering of the
          respective keys to produce sig1, sig2
          \State send (\textsc{submit}, $\left((\mathrm{sig1}, \mathrm{sig2}),
          Cl\right)$) to \ledger
        \EndIndent
      \end{algorithmic}
    \end{protocolbox}
    \caption{}
    \label{alg:protocol:close:coop}
  \end{figure}
