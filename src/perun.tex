\section{Perun}
  Perun~\cite{perun} is a payment network designed for Turing-complete smart contract
  scripting languages. It has been implemented for Ethereum. Its main contribution is
  \textit{multistate channels} that allow the dynamic deployment of virtual contracts,
  known as \textit{nanocontracts}. Contracts of this type do not have to enter the
  blockchain if all parties are cooperative and only do so in case of a dispute.

  The paper describes specifically the use of such multistate channels for creating
  virtual payment channels between parties that do not have a basic payment channel
  between them, but both have basic multistate channels with an intermediary. Then the
  intermediary could substitute for the blockchain and thus a virtual payment channel on
  top of the two basic multistate channels can be created. The parties need the
  intermediary only for setting up the channel and to close it fast. If the intermediary
  refuses to close the channel, they can always fall back to the blockchain in order to
  close it.

  \subsection{Payment channels}
    A basic payment channel is a tuple
    \begin{equation*}
      \gamma = \left(\gamma\mbox{\texttt{.id}}, \gamma\mbox{\texttt{.Alice}},
      \gamma\mbox{\texttt{.Bob}}, \gamma\mbox{\texttt{.cash}},
      \gamma\mbox{\texttt{.ver-num}}, \gamma\mbox{\texttt{.sign}}\right)
    \end{equation*}
    Versions of this tuple are held by $Alice$ and $Bob$. $\gamma\mbox{\texttt{.id}}$ is a
    unique identifier for the channel, $\gamma\mbox{\texttt{.Alice}}$ and
    $\gamma\mbox{\texttt{.Bob}}$ are the end-users of $\gamma$ and
    $\gamma\mbox{\texttt{.cash}}$ is a function from the end-users to a real non-negative
    value that denotes the amount of cash the user has in the channel.
    $\gamma\mbox{\texttt{.ver-num}}$ is a number that is incremented with each channel
    update (so that the latest state of the channel is known in case of dispute) and
    $\gamma\mbox{\texttt{.sign}}$ is the singature of the other party on
    $\left(\gamma\mbox{\texttt{.id}}, \gamma\mbox{\texttt{.cash}},
    \gamma\mbox{\texttt{.ver-num}}\right)$.

    A payment channel has a corresponding
    $\mbox{\texttt{PaymentContract}}_{\gamma\mbox{\texttt{.id}}}$ on the ledger. End-users
    interact with the contract only to set up and close the channel, whereas updating the
    channel happens off-chain. The contract does not contain the fields
    $\gamma\mbox{\texttt{.ver-num}}$ and $\gamma\mbox{\texttt{.sign}}$; the two fields are
    kept only by the end-users.

    The procedure of creating a channel is as follows:
    \begin{enumerate}
      \item $Alice$ creates a $\mbox{\texttt{PaymentContract}}\left(\gamma\right)$, pays
      it $\gamma\mbox{\texttt{.cash}}\left(\gamma\mbox{\texttt{.Alice}}\right)$ coins and
      broadcasts it on the ledger. The fields $\gamma\mbox{\texttt{.ver-num}}$ and
      $\gamma\mbox{\texttt{.sign}}$ are not included.
      \item The contract sends the message (\texttt{initialising}, $\gamma$) to both
      end-users ($\gamma\mbox{\texttt{.Alice}}$ and $\gamma\mbox{\texttt{.Bob}}$).
      \item $Bob$ calls the \texttt{confirm}() function of the contract and pays it the
      already specified amount of
      $\gamma\mbox{\texttt{.cash}}\left(\gamma\mbox{\texttt{.Bob}}\right)$ coins.
      \item The contract sends the message (\texttt{initialised}, $\gamma$) to both
      end-users.
      \item If $Alice$ does not receive (\texttt{initialised}, $\gamma$) after a
      predefined time $\Delta$ has passed from receiving (\texttt{initialising},
      $\gamma$), she calls the contract function \texttt{refund}() and gets her deposit
      back.
    \end{enumerate}

    Note that $Alice$ can get her money back if $Bob$ does not cooperate and $Bob$ only
    pays the contract after he verifies that $Alice$ has set up everything correctly. The
    contract code is public and thus end-users do not engage with it if it does not
    correspond to the expected code; no trust towards the contract is needed.

    Assume that the end-users want to update an existing channel balance from
    $\gamma\mbox{\texttt{.cash}}$ to $\mbox{\texttt{cash}}'$, where the total
    channel balance has remained unchanged:
    \begin{equation*}
      \gamma\mbox{\texttt{.cash}}\left(\gamma\mbox{\texttt{.Alice}}\right) +
      \gamma\mbox{\texttt{.cash}}\left(\gamma\mbox{\texttt{.Bob}}\right) =
      \mbox{\texttt{cash}}'\left(\gamma\mbox{\texttt{.Alice}}\right) +
      \mbox{\texttt{cash}}'\left(\gamma\mbox{\texttt{.Bob}}\right)
    \end{equation*}
    The procedure of updating to the new balance is as follows:
    \begin{enumerate}
      \item $Alice$ builds a new channel tuple $\gamma^{Alice}$ where
      \begin{itemize}
        \item the fields \texttt{id} and \texttt{users} are as in $\gamma$,
        \item $\gamma^{Alice}\mbox{\texttt{.cash}} = \mbox{\texttt{cash}}'$,
        \item $\gamma^{Alice}\mbox{\texttt{.ver-num}} = \gamma\mbox{\texttt{.ver-num}} +
        1$ and
        \item $\gamma^{Alice}\mbox{\texttt{.sign}}$ is $Alice$'s signature on \newline
        $\left(\gamma^{Alice}\mbox{\texttt{.id}}, \gamma^{Alice}\mbox{\texttt{.cash}},
        \gamma^{Alice}\mbox{\texttt{.ver-num}}\right)$.
      \end{itemize}
      \item $Alice$ sends $\gamma^{Alice}$ to $Bob$ and waits for his response.
      \item $Bob$ checks that all fields are as expected and replaces the old channel
      tuple, $\gamma$, with the newly tuple, $\gamma^{Alice}$. From his point of view, the
      payment has gone through.
      \item $Bob$ sends to $Alice$ the updated channel, $\gamma^{Bob}$, of which all
      fields are the same as $\gamma^{Alice}$ except for
      $\gamma^{Bob}\mbox{\texttt{.sign}}$, which is $Bob$'s signature on
      $\left(\gamma^{Bob}\mbox{\texttt{.id}}, \gamma^{Bob}\mbox{\texttt{.cash}},
      \gamma^{Bob}\mbox{\texttt{.ver-num}}\right)$.
      \item If $Alice$ receives the expected $\gamma^{Bob}$, she replaces the old channel
      tuple with $\gamma^{Bob}$. From her point of view, the payment has gone through.
    \end{enumerate}
  \subsection{Multistate channels}
    A basic multistate channel is a tuple
    \begin{equation*}
      \gamma = \left(\gamma\mbox{.\texttt{id}}, \gamma\mbox{.\texttt{Alice}},
      \gamma\mbox{.\texttt{Bob}}, \gamma\mbox{.\texttt{cash}},
      \gamma\mbox{.\texttt{nspace}}\right)
    \end{equation*}
