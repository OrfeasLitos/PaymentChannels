\begin{figure}[H]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Reg}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{registered} and \textsc{corrupted}, act like \fpaynet{}, but skip
      lines that call \texttt{checkClosed}().
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:reg}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg}}$}
    Like $\simulator{}_{\mathrm{LN}}$, but it does not accept
    (\textsc{registered}) from $\fpaynet{}_{\mathrm{, Reg}}$.
    Additional differences:
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{register}, \alice, delay, relayDelay,
      lastPoll) from $\fpaynet{}_{\mathrm{, Reg}}$:
      \Indent
        \State $\mathtt{delay} \text{ of \alice{} ITI } \gets \mathrm{delay}$
        \label{alg:sim:reg:delay}
        \State $\mathtt{relayDelay} \text{ of \alice{} ITI } \gets
        \mathrm{relayDelay}$
        \State $\mathtt{lastPoll} \text{ of \alice{} ITI } \gets
        \mathrm{lastPoll}$
        \State $\left(pk_{\alice}, sk_{\alice}\right) \text{ of \alice{} ITI }
        \gets \mathtt{KeyGen}()$
        \label{alg:sim:reg:keygen}
        \State send (\textsc{registerDone}, \alice, $pk_{\alice}$) to
        $\fpaynet{}_{\mathrm{, Reg}}$
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{corrupt}) on the backdoor tape of \alice's
      simulated ITI:
      \Indent
        \State add \alice{} to \texttt{corrupted}
        \State for the rest of the execution, upon receiving any message for
        \alice{}, bypass normal execution and simply forward it to
        \alice
        \State send (\textsc{corrupted}, \alice) to $\fpaynet{}_{\mathrm{,
        Reg}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:reg}
\end{figure}

\begin{lemma}
  \label{lemma:reg}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, dummy}},
  \ledger}_{\simulator_{\mathrm{LN}}, \environment} =
  \textsc{Exec}^{\fpaynet{}_{\mathrm{, Reg}},
  \ledger}_{\simulator_{\mathrm{LN - Reg}}, \environment}$
\end{lemma}

\begin{proof}
  When \environment{} sends (\textsc{register}, delay, relayDelay) to
  \alice{}, it receives as a response (\textsc{register}, \alice, delay,
  relayDelay, $pk_{\alice}$) where $pk_{\alice}$ is a public key generated by
  \texttt{KeyGen}() both in the real (c.f. Fig.~\ref{alg:protocol:support},
  line~\ref{alg:protocol:support:keygen}) and in the ideal world (c.f.
  Fig.~\ref{alg:sim:reg}, line~\ref{alg:sim:reg:keygen}).

  Furthermore, one (\textsc{read}) is sent to \ledger{} from \alice{} in both
  cases (Fig.~\ref{alg:protocol:support},
  line~\ref{alg:protocol:support:lastpoll} and Fig.~\ref{alg:fpaynet:support},
  line~\ref{alg:fpaynet:support:lastpoll}).

  Additionally, $\simulator{}_{\mathrm{LN - Reg}}$ ensures that the state of
  \alice{} ITI is exactly the same as what would have been in the case of
  $\simulator{}_{\mathrm{LN}}$, as
  lines~\ref{alg:protocol:support:delay}-\ref{alg:protocol:support:keygen} of
  Fig.~\ref{alg:protocol:support} change the state of \alice{} ITI in the same
  way as lines~\ref{alg:sim:reg:delay}-\ref{alg:sim:reg:keygen} of
  Fig.~\ref{alg:sim:reg}.

  Lastly, the fact that the state of the \alice{} ITIs are changed in the same
  way in both worlds, along with the same argument as in the proof of
  Lemma~\ref{lemma:dummy} ensures that the rest of the messages are responded
  in an indistinguishable way in both worlds.
\end{proof}
