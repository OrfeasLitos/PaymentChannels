\section{Combined Sign primitive}
  \subsection{Algorithms}
    \begin{itemize}
      \item $\left(mpk, msk\right) \gets \textsc{MasterKeyGen}\left(1^k\right)$
      \item $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right)$
      \item $\left(cpk_l, csk_l\right) \gets \textsc{CombineKeyGen}\left(msk,
      mpk, sk, pk\right)$
      \item $cpk_l \gets \textsc{CombinePubKeyGen}\left(mpk, pk\right)$
      \item $\sigma \gets \textsc{Sign}\left(csk, m\right)$
      \item $\left\{0, 1\right\} \gets \textsc{Verify}\left(cpk, m,
      \sigma\right)$
    \end{itemize}

  \subsection{Correctness}
    \begin{itemize}
      \item $\forall k \in \mathcal{N},$ \\
      $\Pr[(mpk, msk) \gets \textsc{MasterKeyGen}\left(1^k\right),$ \\
      $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right),$ \\
      $\left(cpk_1, csk_1\right) \gets \textsc{CombineKeyGen}\left(msk, mpk, sk,
      pk\right),$ \\
      $cpk_2 \gets \textsc{CombinePubKeyGen}\left(mpk, pk\right),$ \\
      $cpk_1 = cpk_2] = 1$

      \item $\forall k \in \mathcal{N}, m \in \mathcal{M},$ \\
      $\Pr[(mpk, msk) \gets \textsc{MasterKeyGen}\left(1^k\right),$ \\
      $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right),$ \\
      $\left(cpk, csk\right) \gets \textsc{CombineKeyGen}\left(mpk, msk, pk,
      sk\right),$ \\
      $\textsc{Verify}(cpk, m, \textsc{Sign}(csk, m)) = 1] = 1$
    \end{itemize}

  \subsection{Security}
    \begin{figure}[!htbp]
      \begin{gamebox}{$\mathsf{share \mhyphen
      EUF}^{\adversary}\left(1^k\right)$}
        \begin{algorithmic}[1]
          \State $\left(\mathtt{aux}, mpk, n\right) \gets
          \adversary\left(\textsc{init}\right)$
          \For{$i \gets 1$ to $n$}
            \State $\left(pk_i, sk_i\right) \gets
            \textsc{KeyShareGen}\left(1^k\right)$
          \EndFor
          \State $\left(cpk^*, pk^*, m^*, \sigma^*\right) \gets
          \adversary\left(\textsc{keys}, \mathtt{aux}, pk_1, \dots, pk_n\right)$
          \If{$pk^* \in \left\{pk_1, \dots, pk_n\right\} \wedge$
          $cpk^* = \textsc{CombinePubKey}\left(mpk, pk^*\right) \wedge$
          $\textsc{Verify}\left(cpk^*, m^*, \sigma^*\right) = 1$}
            \State \Return 1
          \Else
            \State \Return 0
          \EndIf
        \end{algorithmic}
      \end{gamebox}
      \caption{}
      \label{game:comb:share}
    \end{figure}
    \begin{definition}
      A Combined Sign scheme is \emph{\textsf{share-EUF}-secure} if
      \begin{equation*}
        \forall k \in \mathbb{N}, \forall \adversary \in \mathtt{PPT},
        \Pr\left[\mathsf{share \mhyphen EUF}^{\adversary}\left(1^k\right) =
        1\right] < \mathit{negl}\left(k\right)
      \end{equation*}
    \end{definition}

    \begin{figure}[!htbp]
      \begin{gamebox}{$\mathsf{master \mhyphen EUF \mhyphen
      CMA}^{\adversary}\left(1^k\right)$}
        \begin{algorithmic}[1]
          \State $\left(mpk_i, msk_i\right) \gets
          \textsc{MasterKeyGen}\left(1^k\right)$
          \State $i \gets 0$
          \State $\left(\mathtt{aux}_i, \mathrm{response}\right) \gets
          \adversary\left(\textsc{init}, mpk\right)$
          \While{response can be parsed as $\left(pk, sk, m\right)$}
            \State $i \gets i + 1$
            \State store $pk, sk, m$ as $pk_i, sk_i, m_i$
            \State $\left(cpk_i, csk_i\right) \gets
            \textsc{CombineKeyGen}\left(mpk, msk, pk_i, sk_i\right)$
            \State $\sigma_i \gets \textsc{Sign}\left(csk_i, m_i\right)$
            \State $\left(\mathtt{aux}_i, \mathrm{response}\right) \gets
            \adversary\left(\textsc{signature}, \mathtt{aux}_{i-1},
            \sigma_i\right)$
          \EndWhile
          \State parse response as $\left(cpk^*, pk^*, m^*, \sigma^*\right)$
          \If{$m^* \notin \left\{m_1, \dots, m_i\right\} \wedge$
          $cpk^* = \textsc{CombinePubKey}\left(mpk, pk^*\right) \wedge$
          $\textsc{Verify}\left(cpk^*, m^*, \sigma^*\right) = 1$}
            \State \Return 1
          \Else
            \State \Return 0
          \EndIf
        \end{algorithmic}
      \end{gamebox}
      \caption{}
      \label{game:comb:master}
    \end{figure}
    \begin{definition}
      A Combined Sign scheme is \emph{\textsf{master-EUF-CMA}-secure} if
      \begin{equation*}
        \forall k \in \mathbb{N}, \forall \adversary \in \mathtt{PPT},
        \Pr\left[\mathsf{master \mhyphen EUF \mhyphen
        CMA}^{\adversary}\left(1^k\right) = 1\right] <
        \mathit{negl}\left(k\right)
      \end{equation*}
    \end{definition}
    \begin{definition}
      A Combined Sign scheme is \emph{\textsf{combine-EUF}-secure} if it is both
      \textsf{share-EUF}-secure and \textsf{master-EUF-CMA}-secure.
    \end{definition}

  \subsection{Construction}
    \TODO{output standard signing keypairs to avoid duplication?}

    Parameters: $\mathcal{H}, G$
    \begin{algorithmic}[0]
      \Function{MasterKeyGen}{$1^k$, rand}
        \State Return (rand, $G \cdot \mathrm{rand}$)
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{KeyShareGen}{$1^k$, rand}
        \State Return (rand, $G \cdot \mathrm{rand}$)
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{CombineKeyGen}{$msk, mpk, sk, pk$}
        \State \Return $msk \cdot \mathcal{H}\left(mpk \concat pk\right) + sk
        \cdot \mathcal{H}\left(pk \concat mpk\right)$
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{CombinePubKeyGen}{$mpk, pk$}
        \State \Return $mpk \cdot \mathcal{H}\left(mpk \concat pk\right) + pk
        \cdot \mathcal{H}\left(pk \concat mpk\right)$
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{Sign}{$csk, m$}
        \State like standard sign
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{Verify}{$cpk, m, \sigma$}
        \State like standard verify
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \State just to remember
      \State $sh_{\mathrm{rev}, n} \gets shb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(phb_{\mathrm{rev}} || pt_{\mathrm{com}, n}\right) +
      st_{\mathrm{com}, n} \cdot \mathcal{H}\left(pt_{\mathrm{com}, n} ||
      phb_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{rev}, n+2} \gets ptb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ptb_{\mathrm{rev}} || ph_{\mathrm{com}, n+2}\right) +
      ph_{\mathrm{com}, n+2} \cdot \mathcal{H}\left(ph_{\mathrm{com}, n+2} ||
      ptb_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{rev}, n+2} \gets phb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(phb_{\mathrm{rev}} || pt_{\mathrm{com}, n+2}\right) +
      pt_{\mathrm{com}, n+2} \cdot \mathcal{H}\left(pt_{\mathrm{com}, n+2} ||
      phb_{\mathrm{rev}}\right)$
    \end{algorithmic}

    \begin{lemma}
      \label{lemma:comb:share}
      The construction above is \textsf{share-EUF}-secure in the Random Oracle
      model under the assumption that the underlying signature scheme is
      strongly \textsf{EUF-CMA}-secure and the range of the Random Oracle
      coincides with that of the underlying signature scheme signing keys.
    \end{lemma}

    \begin{proof}
      Let $k \in \mathbb{N}, \mathcal{B}$ PPT algorithm such that
      \begin{equation*}
        \Pr\left[\mathsf{share \mhyphen EUF}^{\mathcal{B}}\left(1^k\right) =
        1\right] = a > \mathrm{negl}\left(k\right) \enspace.
      \end{equation*}
      We construct a PPT distinguisher \adversary{}
      (Fig.~\ref{proof:comb:share:distinguisher}) such that
      \begin{equation*}
        \Pr\left[\mathsf{EUF \mhyphen CMA}^{\adversary}\left(1^k\right) =
        1\right] > \mathrm{negl}\left(k\right)
      \end{equation*}
      that breaks the assumption, thus proving Lemma~\ref{lemma:comb:share}.

      \begin{figure}[!htbp]
        \begin{algobox}{$\adversary\left(vk\right)$}
          \begin{algorithmic}[1]
            \State $j \overset{\$}{\gets} U\left[1,
            T\left(\mathcal{B}\right)\right]$
            \Comment{$T\left(M\right)$ is the maximum running time of $M$}
            \Indent
              \State Random Oracle: for every first-seen query $q$ from
              $\mathcal{B}$ set $\mathcal{H}\left(q\right)$ to a random value
              \State \Return $\mathcal{H}\left(q\right)$ to $\mathcal{B}$
            \EndIndent
            \State $\left(\mathtt{aux}, mpk, n\right) \gets
            \adversary\left(\textsc{init}\right)$
            \For{$i \gets 1$ to $n$}
              \State $\left(pk_i, sk_i\right) \gets
              \textsc{KeyShareGen}\left(1^k\right)$
            \EndFor
            \Indent
              \State Random Oracle: Let $q$ be the $j$th first-seen query from
              $\mathcal{B}$:
              \If{$q = \left(x \concat mpk\right)$}
                \State set $\mathcal{H}\left(x \concat mpk\right)$ to a random
                value
                \State set $\mathcal{H}\left(mpk \concat x\right)$ to $\left(vk
                - x \cdot \mathcal{H}\left(x \concat mpk\right)\right) \cdot
                mpk^{-1}$
              \ElsIf{$q = \left(mpk \concat x\right)$}
                \State set $\mathcal{H}\left(mpk \concat x\right)$ to a random
                value
                \State set $\mathcal{H}\left(x \concat mpk\right)$ to $\left(vk
                - mpk \cdot \mathcal{H}\left(mpk \concat x\right)\right) \cdot
                x^{-1}$
              \Else
                \State set $\mathcal{H}\left(q\right)$ to a random value
              \EndIf
              \State \Return $\mathcal{H}\left(q\right)$ to $\mathcal{B}$
            \EndIndent
            \State $\left(cpk^*, pk^*, m^*, \sigma^*\right) \gets
            \mathcal{B}\left(\textsc{keys}, \mathtt{aux}, pk_1, \dots,
            pk_n\right)$
            \If{$vk = cpk^* \wedge \mathcal{B}$ wins the \textsf{share-EUF}
            game} \Comment{\adversary{} won the \textsf{EUF-CMA} game}
            \label{proof:comb:share:distinguisher:won}
              \State \Return $\left(m^*, \sigma^*\right)$
            \Else
              \State \Return \textsc{fail}
            \EndIf
          \end{algorithmic}
        \end{algobox}
        \caption{}
        \label{proof:comb:share:distinguisher}
      \end{figure}

      Let $Y$ be the range of the random oracle. The modified random oracle used
      in Fig.~\ref{proof:comb:share:distinguisher} is indistinguishable from the
      standard random oracle by PPT algorithms since the statistical distance of
      the standard random oracle from the modified one is at most
      $\frac{1}{2|Y|} < \mathit{negl}\left(k\right)$ as they differ in at most
      one element.

      Let $E$ denote the event in which $\mathcal{B}$ does not invoke
      \textsc{CombinePubKeyGen} to produce $cpk^*$. In that case the values
      $\mathcal{H}\left(pk^* \concat mpk\right)$ and $\mathcal{H}\left(mpk
      \concat pk^*\right)$ are decided in
      line~\ref{proof:comb:share:distinguisher:won} and thus $\Pr\left[cpk^* =
      \textsc{CombinePubKeyGen}\left(mpk, pk^*\right) | E\right] = \frac{1}{|Y|}
      < \mathit{negl}\left(k\right)$. It is
      \begin{gather*}
        \left(\mathcal{B} \text{ wins}\right) \rightarrow \left(cpk^* =
        \textsc{CombinePubKeyGen}\left(mpk, pk^*\right)\right) \Rightarrow \\
        \Pr\left[\mathcal{B} \text{ wins}\right] \leq \Pr\left[cpk^* =
        \textsc{CombinePubKeyGen}\left(mpk, pk^*\right)\right] \Rightarrow \\
        \Pr\left[\mathcal{B} \text{ wins} \wedge E\right] \leq \Pr\left[cpk^* =
        \textsc{CombinePubKeyGen}\left(mpk, pk^*\right) \wedge E\right]
        \Rightarrow \\
        \Pr\left[\mathcal{B} \text{ wins} \wedge E\right] <
        \mathit{negl}\left(k\right) \enspace.
      \end{gather*}

      But we know that $\Pr\left[\mathcal{B} \text{ wins}\right] =
      \Pr\left[\mathcal{B} \text{ wins } \wedge E\right] + \Pr\left[\mathcal{B}
      \text{ wins } \wedge \neg E\right]$ and $\Pr\left[\mathcal{B} \text{
      wins}\right] = a$ by the assumption, thus
      \begin{equation}
        \label{proof:comb:share:nohash}
        \Pr\left[\mathcal{B} \text{ wins} \wedge \neg E\right] > a -
        \mathit{negl}\left(k\right) \enspace.
      \end{equation}

      We now focus at the event $\neg E$. Let $F$ the event in which the call of
      $\mathcal{B}$ to \textsc{CombinePubKeyGen} to produce $cpk^*$ results in
      the $j$th invocation of the Random Oracle. Since $j$ is chosen uniformly
      at random, $\Pr\left[F | \neg E\right] =
      \frac{1}{T\left(\mathcal{B}\right)}$. In that case we win!! % TODO
    \end{proof}

    \begin{lemma}
      \label{lemma:comb:master}
      The construction above is \textsf{master-EUF-CMA}-secure in the Random
      Oracle model under the assumption that the underlying signature scheme is
      strongly \textsf{EUF-CMA}-secure and the range of the Random Oracle
      coincides with that of the underlying signature scheme signing keys.
    \end{lemma}

    \begin{proof}
      Let $k \in \mathbb{N}, \mathcal{B}$ PPT algorithm such that
      \begin{equation*}
        \Pr\left[\mathsf{master \mhyphen EUF \mhyphen
        CMA}^{\mathcal{B}}\left(1^k\right) = 1\right] = a >
        \mathrm{negl}\left(k\right) \enspace.
      \end{equation*}
      We construct a PPT distinguisher \adversary{}
      (Fig.~\ref{proof:comb:master:distinguisher}) such that
      \begin{equation*}
        \Pr\left[\mathsf{EUF \mhyphen CMA}^{\adversary}\left(1^k\right) =
        1\right] > \mathrm{negl}\left(k\right)
      \end{equation*}
      that breaks the assumption, thus proving Lemma~\ref{lemma:comb:master}.

      \begin{figure}[!htbp]
        \begin{algobox}{$\adversary\left(vk\right)$}
          \begin{algorithmic}[1]
            \State $j \overset{\$}{\gets} U\left[1, T\left(\mathcal{B}\right) +
            T\left(\adversary\right)\right]$
            \Comment{$T\left(M\right)$ is the maximum running time of $M$}
            \Indent
              \State Random Oracle: for every first-seen query $q$ from
              $\mathcal{B}$ set $\mathcal{H}\left(q\right)$ to a random value
              \State \Return $\mathcal{H}\left(q\right)$ to $\mathcal{B}$
            \EndIndent
            \State $\left(mpk_i, msk_i\right) \gets
            \textsc{MasterKeyGen}\left(1^k\right)$
            \Indent
              \State Random Oracle: Let $q$ be the $j$th first-seen query from
              $\mathcal{B}$ or \adversary:
              \If{$q = \left(x \concat mpk\right)$}
                \State set $\mathcal{H}\left(x \concat mpk\right)$ to a random
                value
                \State set $\mathcal{H}\left(mpk \concat x\right)$ to $\left(vk
                - x \cdot \mathcal{H}\left(x \concat mpk\right)\right) \cdot
                mpk^{-1}$
              \ElsIf{$q = \left(mpk \concat x\right)$}
                \State set $\mathcal{H}\left(mpk \concat x\right)$ to a random
                value
                \State set $\mathcal{H}\left(x \concat mpk\right)$ to $\left(vk
                - mpk \cdot \mathcal{H}\left(mpk \concat x\right)\right) \cdot
                x^{-1}$
              \Else
                \State set $\mathcal{H}\left(q\right)$ to a random value
              \EndIf
              \State \Return $\mathcal{H}\left(q\right)$ to $\mathcal{B}$ or
              \adversary
            \EndIndent
            \State $i \gets 0$
            \State $\left(\mathtt{aux}_i, \mathrm{response}\right) \gets
            \mathcal{B}\left(\textsc{init}, mpk\right)$
            \While{response can be parsed as $\left(pk, sk, m\right)$}
              \State $i \gets i + 1$
              \State store $pk, sk, m$ as $pk_i, sk_i, m_i$
              \State $\left(cpk_i, csk_i\right) \gets
              \textsc{CombineKeyGen}\left(mpk, msk, pk_i, sk_i\right)$
              \State $\sigma_i \gets \textsc{Sign}\left(csk_i, m_i\right)$
              \State $\left(\mathtt{aux}_i, \mathrm{response}\right) \gets
              \mathcal{B}\left(\textsc{signature}, \mathtt{aux}_{i-1},
              \sigma_i\right)$
            \EndWhile
            \State parse response as $\left(cpk^*, pk^*, m^*, \sigma^*\right)$
            \State $\left(cpk^*, pk^*, m^*, \sigma^*\right) \gets
            \mathcal{B}\left(\textsc{keys}, \mathtt{aux}, pk_1, \dots,
            pk_n\right)$
            \If{$vk = cpk^* \wedge \mathcal{B}$ wins the \textsf{master-EUF-CMA}
            game} \Comment{\adversary{} won the \textsf{EUF-CMA} game}
              \State \Return $\left(m^*, \sigma^*\right)$
            \Else
              \State \Return \textsc{fail}
            \EndIf
          \end{algorithmic}
        \end{algobox}
        \caption{}
        \label{proof:comb:master:distinguisher}
      \end{figure}

      The modified random oracle used in
      Fig.~\ref{proof:comb:master:distinguisher} is indistinguishable from the
      standard random oracle for the same reasons as in the proof of
      Lemma~\ref{lemma:comb:share}.
    \end{proof}

    \begin{theorem}
      \label{thm:combsign}
      The construction above is \textsf{combine-EUF}-secure in the Random Oracle
      model under the assumption that the underlying signature scheme is
      strongly \textsf{EUF-CMA}-secure.
    \end{theorem}

    \begin{proof}
      The construction is \textsf{combine-EUF}-secure as a direct consequence of
      Lemma~\ref{lemma:comb:share}, Lemma~\ref{lemma:comb:master} and the
      definition of \textsf{combine-EUF}-security.
    \end{proof}
