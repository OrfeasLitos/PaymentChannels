\section{Combined Sign primitive}
  \subsection{Algorithms}
    \begin{itemize}
      \item $\left(mpk, msk\right) \gets \textsc{MasterKeyGen}\left(1^k\right)$
      \item $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right)$
      \item $\left(cpk_l, csk_l\right) \gets \textsc{CombineKeyGen}\left(msk,
      mpk, sk, pk\right)$
      \item $cpk_l \gets \textsc{CombinePubKeyGen}\left(mpk, pk\right)$
      \item $\sigma \gets \textsc{Sign}\left(csk, m\right)$
      \item $\left\{0, 1\right\} \gets \textsc{Verify}\left(cpk, m,
      \sigma\right)$
    \end{itemize}

  \subsection{Correctness}
    \begin{itemize}
      \item $\forall k \in \mathcal{N},$ \\
      $\Pr[(mpk, msk) \gets \textsc{MasterKeyGen}\left(1^k\right),$ \\
      $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right),$ \\
      $\left(cpk_1, csk_1\right) \gets \textsc{CombineKeyGen}\left(msk, mpk, sk,
      pk\right),$ \\
      $cpk_2 \gets \textsc{CombinePubKeyGen}\left(mpk, pk\right),$ \\
      $cpk_1 = cpk_2] = 1$

      \item $\forall k \in \mathcal{N}, m \in \mathcal{M},$ \\
      $\Pr[(mpk, msk) \gets \textsc{MasterKeyGen}\left(1^k\right),$ \\
      $\left(pk, sk\right) \gets \textsc{KeyShareGen}\left(1^k\right),$ \\
      $\left(cpk, csk\right) \gets \textsc{CombineKeyGen}\left(mpk, msk, pk,
      sk\right),$ \\
      $\textsc{Verify}(cpk, m, \textsc{Sign}(csk, m)) = 1] = 1$
    \end{itemize}

  \subsection{Security}
    \begin{gamebox}{$(mpk, msk)$ secure}
    \end{gamebox}

    \begin{gamebox}{$(pk, sk)$ secure}
    \end{gamebox}

  \subsection{Construction}
    \TODO{output standard signing keypairs to avoid duplication?}

    Parameters: $\mathcal{H}, G$
    \begin{algorithmic}[0]
      \Function{MasterKeyGen}{$1^k$, rand}
        \State Return (rand, $G \cdot \mathrm{rand}$)
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{KeyShareGen}{$1^k$, rand}
        \State Return (rand, $G \cdot \mathrm{rand}$)
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{CombineKeyGen}{$msk, mpk, sk, pk$}
        \State \Return $msk \cdot \mathcal{H}\left(mpk \concat pk\right) + sk
        \cdot \mathcal{H}\left(pk \concat mpk\right)$
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{CombinePubKeyGen}{$mpk, pk$}
        \State \Return $mpk \cdot \mathcal{H}\left(mpk \concat pk\right) + pk
        \cdot \mathcal{H}\left(pk \concat mpk\right)$
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{Sign}{$csk, m$}
        \State like standard sign
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \Function{Verify}{$cpk, m, \sigma$}
        \State like standard verify
      \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[0]
      \State just to remember
      \State $sh_{\mathrm{rev}, n} \gets shb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(phb_{\mathrm{rev}} || pt_{\mathrm{com}, n}\right) +
      st_{\mathrm{com}, n} \cdot \mathcal{H}\left(pt_{\mathrm{com}, n} ||
      phb_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{rev}, n+2} \gets ptb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ptb_{\mathrm{rev}} || ph_{\mathrm{com}, n+2}\right) +
      ph_{\mathrm{com}, n+2} \cdot \mathcal{H}\left(ph_{\mathrm{com}, n+2} ||
      ptb_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{rev}, n+2} \gets phb_{\mathrm{rev}} \cdot
      \mathcal{H}\left(phb_{\mathrm{rev}} || pt_{\mathrm{com}, n+2}\right) +
      pt_{\mathrm{com}, n+2} \cdot \mathcal{H}\left(pt_{\mathrm{com}, n+2} ||
      phb_{\mathrm{rev}}\right)$
    \end{algorithmic}
