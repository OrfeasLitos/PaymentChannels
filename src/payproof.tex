\begin{figure}[!htbp]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{toppedUp}, \textsc{openChannel}, \textsc{channelAnnounced},
      \textsc{checkForNew}, \textsc{poll}, \textsc{pay},
      \textsc{adversarySendInvoice}, \textsc{pushAdd},
      \textsc{pushFulfill}, \textsc{fulfillOnChain} and \textsc{commit}, act
      like \fpaynet{}, but skip lines that call \texttt{checkClosed}().
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[!htbp]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ -- pay}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon simulating line~\ref{alg:protocol:pay:invoice:receive}
      of Fig.~\ref{alg:protocol:pay:invoice}:
      \Indent
        \If{$\exists (\bot, \bot, \mathit{payid}) \in \mathtt{payids}$
        where \textit{payid} is the one in the \textsc{invoice} message}
          \State replace second $\bot$ with the $h$ found in the
          \textsc{invoice} message
        \EndIf
      \EndIndent
      \Statex

      \State Upon simulating
      line~\ref{alg:protocol:pay:updateAddHtlc:receive} of
      Fig.~\ref{alg:protocol:pay:updateAddHtlc} with honest \alice:
      \Indent
        \If{$\exists \mathit{payid}: (\overrightarrow{\mathtt{path}}, h,
        \mathit{payid}) \in \mathtt{payids}$ where $h$ is the one in the
        \textsc{updateAddHtlc} message}
          \State append \alice{} to $\overrightarrow{\mathtt{path}}$
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{fulfillOnChain}, t, \alice\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \label{alg:sim:pay:foc:top}
      \Indent
        \State execute
        lines~\ref{alg:protocol:pay:foc:tosubmit}-\ref{alg:protocol:pay:foc:submit}
        of Fig.~\ref{alg:protocol:pay:foc} as \alice{}, using $t$ from message
        \label{alg:sim:pay:foc:run}
        \If{during the simulation above,
        line~\ref{alg:protocol:pay:foc:payment} is simulated in \alice's ITI}
        \label{alg:sim:foc:report:if}
          \State send (\textsc{newPayments}, \texttt{payment}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{payment} consists of the
          tuple just added to the simulated \texttt{paymentsToReport}, appended
          with the \textit{payid} mentioned in
          line~\ref{alg:protocol:pay:foc:payment:loop}
          \label{alg:sim:foc:report}
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathit{expayid},
      \mathit{payid}\right)$ from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State add ($\overrightarrow{\mathtt{path}}$, $\top$,
        \textit{payid}) to \texttt{payids}
        \State strip \textit{payid} and \alice, simulate receiving the
        message with \alice{} ITI and further execute the parts of
        $\Pi_{\mathrm{LN}}$ that correspond to honest parties
        (Fig.~\ref{alg:protocol:pay:outofband}-Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \label{alg:sim:pay:simulate}
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until \bob{} processes
        \textsc{updateAddHtlc}} \Comment{payment failed}
          \State add $\left(\bot, \mathit{payid}\right)$ to
          \texttt{charged}(\alice)
          \label{alg:sim:pay:failed}
          \State remove ($\overrightarrow{\mathtt{path}}$, \_,
          \textit{payid}) from \texttt{payids}
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{poll}, $\Sigma_{\alice}$, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:poll},
        lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:submit}
        receiving (\textsc{poll}), using $\Sigma_{\alice}$ from the message,
        with \alice's ITI
        \label{alg:sim:poll:run}
        \If{during the simulation above,
        line~\ref{alg:protocol:poll:report:pay} of
        Fig.~\ref{alg:protocol:poll:closedch} is simulated in \alice's ITI}
        \label{alg:sim:poll:report:if}
          \State send (\textsc{newPayments}, \texttt{payment}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{payment} consists of the
          tuple just added to the simulated \texttt{paymentsToReport}, appended
          with the \textit{payid} stored the entry of \texttt{pendingPay}
          referred to in line~\ref{alg:protocol:poll:report:pendingPay}
          (Fig.~\ref{alg:protocol:poll:closedch},
          line~\ref{alg:protocol:poll:report:pay})
          \label{alg:sim:poll:report}
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{figure}[!htbp]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ --
  adversarial payment}
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{sendInvoice}, $x$,
      \textit{expayid}, \textit{payid}, \textit{from} \alice, \textit{to} \bob)
      from \adversary:
      \Indent
      \label{alg:sim:pay:adv:invoice}
        \State ensure \alice{} is \texttt{corrupted} and that \bob{} is not
        \State ensure no other payment with the same \textit{payid} exists
        \State choose unique number adn assign it to \textit{invid}
        \State store received message along with \textit{invid}
        \State add ($\bot$, $\bot$, \textit{payid}) to \texttt{payids}
        \State send (\textsc{adversarySendInvoice}, $x$, \textit{expayid},
        \textit{payid}, \textit{intid}, \textit{from} \alice, \textit{to} \bob)
        to $\fpaynet{}_{\mathrm{, Pay}}$
        \label{alg:sim:pay:adv:invoice:send}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{adversarySendInvoice},
      \textit{invid}) from $\fpaynet{}_{\mathrm{, Open}}$:
      \label{alg:sim:pay:adv:invoice:recv}
      \Indent
        \State retrieve message associated with \textit{invid}
        \State Continue simulation with \alice{} receiving the message from \bob
        \label{alg:sim:pay:adv:invoice:cont}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay:adv}
\end{figure}

\begin{figure}[!htbp]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ -- push}
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:end}
        on input (\textsc{pushFulfill}, \textit{pchid}) with \alice's ITI and
        handle subsequent messages by simulating respective ITIs of honest
        players or sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:fulfill}
        \If{during the simulation above,
        line~\ref{alg:protocol:pushfulfill:report} of
        Fig.~\ref{alg:protocol:pay:push} is simulated in \alice's ITI}
        \label{alg:sim:pushfulfill:report:if}
          \State send (\textsc{newPayments}, \texttt{payment}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{payment} consists of the
          tuple just added to the simulated \texttt{paymentsToReport}, appended
          with the \textit{payid} of
          line~\ref{alg:protocol:pushfulfill:check:gotpaid}
          (Fig.~\ref{alg:protocol:pay:push},
          line~\ref{alg:protocol:pushfulfill:report})
          \label{alg:sim:pushfulfill:report}
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{pushAdd}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushadd:start}-\ref{alg:protocol:pushadd:end} on
        input (\textsc{pushAdd}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:add}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{commit}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:commit} on input
        (\textsc{commit}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:commit}
        \If{during the simulation above,
        line~\ref{alg:protocol:pay:raa:report:updates}
        of Fig.~\ref{alg:protocol:pay:revokeAndAck} is simulated in \alice's
        ITI}
          \State send (\textsc{newUpdate}, \texttt{receipt}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{receipt} is the
          field just added to the simulated \texttt{updatesToReport}
          (Fig.~\ref{alg:protocol:pay:revokeAndAck},
          line~\ref{alg:protocol:pay:raa:report:updates})
          \label{alg:sim:push:report:updates}
          \State upon receiving (\textsc{continue}) from
          $\fpaynet{}_{\mathrm{, Pay}}$, carry on with the simulation
        \EndIf
        \If{during the simulation above,
        line~\ref{alg:protocol:pay:raa:report:payments}
        of Fig.~\ref{alg:protocol:pay:revokeAndAck} is simulated in \alice's
        ITI}
        \label{alg:sim:push:report:payments:if}
          \State send (\textsc{newPayments}, \texttt{payments}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{payments} consists of the
          fields just added to the simulated \texttt{paymentsToReport}, each
          field appended with the respective \textit{payid} of
          line~\ref{alg:protocol:pay:raa:loop:gotpaid}
          (Fig.~\ref{alg:protocol:pay:revokeAndAck},
          line~\ref{alg:protocol:pay:raa:report:payments})
          \label{alg:sim:push:report:payments}
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:push}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ --
  resolve payments}
    \begin{algorithmic}[1]
      \State Upon receiving any message with a concatenated (\textsc{state},
      $\Sigma$) part from $\fpaynet{}_{\mathrm{, Pay}}$: \Comment{\textsc{pay},
      \textsc{pushFulfill}, \textsc{pushAdd}, \textsc{commit}}
        \Indent
        \State handle first part of the message normally
        \label{alg:sim:resolvepay:firstmsg}
        \If{at the end of the simulation above, control is still held by
        $\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$}
        \label{alg:sim:resolvepay:mayberesolve}
          \ForAll{$\Sigma_{\alice} \in \Sigma$}
          \label{alg:sim:resolvepay:everystate}
            \ForAll{$(\overrightarrow{\mathtt{path}}, \_,
            \mathit{payid}) \in \mathtt{payids} : \alice \in
            \overrightarrow{\mathtt{path}}$}
              \If{condition in Fig.~\ref{alg:sim:resolvepay:corrupted:fig} is
              met} \Comment{no or bad communication with \bob's previous player}
              \label{alg:sim:resolvepay:corrupted}
                \State execute effect in
                Fig.~\ref{alg:sim:resolvepay:corrupted:fig}
                \label{alg:sim:resolvepay:corrupted:do}
              \ElsIf{condition in Fig.~\ref{alg:sim:resolvepay:nofulfill} is
              met} \Comment{\alice{} did not fulfill in time}
              \label{alg:sim:resolvepay:negligent}
                \State execute effect in Fig.~\ref{alg:sim:resolvepay:nofulfill}
                \label{alg:sim:resolvepay:negligent:do}
              \ElsIf{condition in Fig.~\ref{alg:sim:resolvepay:honest:fig} is
              met} \Comment{honest payment completed}
              \label{alg:sim:resolvepay:honest}
                \State execute effect in
                Fig.~\ref{alg:sim:resolvepay:honest:fig}
                \label{alg:sim:resolvepay:honest:do}
              \EndIf
            \EndFor
          \EndFor
          \label{alg:sim:resolvepay:loopend}
          \State clear \texttt{charged} and send
          $\left(\textsc{resolvePays}, \mathtt{charged}\right)$ to
          $\fpaynet{}_{\mathrm{, Pay}}$
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ --
  corrupted charged}
    \begin{algorithmic}[1]
      \Statex \textit{Condition}:
      \Indent
        \State \alice{} sent \textsc{updateFulfillHtlc} to a corrupted player
        and either (got the fulfillment of the HTLC irrevocably committed OR
        fulfilled the HTLC on-chain (i.e. \texttt{HTLC-success} is in
        $\Sigma_{\alice}$)), AND the next honest player \bob{} down the line
        successfully timed out the HTLC on-chain (i.e. \texttt{HTLC-timeout} is
        in $\Sigma_{\bob}$)
      \EndIndent
      \Statex

      \Statex \textit{Effect}:
      \Indent
        \State add (\texttt{corrupted}, \textit{payid}) to
        \texttt{charged}(payer) where \texttt{corrupted} is set to one of the
        corrupted parties between \alice{} and \bob{}
        \If{there is an $h \neq \top$ member in \texttt{payids} entry}
        \Comment{adversarially initiated payment, functionality doesn't know
        path}
          \State append $\overrightarrow{\mathtt{path}}$ to
          \texttt{charged}(\alice) entry
        \EndIf
        \State remove ($\overrightarrow{\mathtt{path}}$, \_,
        \textit{payid}) from \texttt{payids}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay:corrupted:fig}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ -- no
  timely fulfill}
    \begin{algorithmic}[1]
      \Statex \textit{Condition}:
      \Indent
        \State $\Sigma_{\alice}$ contains an old $\mathtt{remoteCom}_m$ of the
        channel before \alice{} (closer to payer) on the
        $\overrightarrow{\mathtt{path}}$ that does not contain the relevant HTLC
        anymore and a tx that spends the delayed output of
        $\mathtt{remoteCom}_m \vee ((\Sigma_{\alice}$ contains the most recent
        $\mathtt{remoteCom}_n$ or $\mathtt{localCom}_n$ of the channel before
        \alice{} and the \texttt{HTLC-timeout} of the relevant HTLC
        $\vee$ \alice's latest irrevocably committed $\mathtt{remoteCom}_n$ for
        the channel before \alice{} does not contain the HTLC) $\wedge \:
        \Sigma_{\alice}$ contains the most recent $\mathtt{remoteCom}_l$ or
        $\mathtt{localCom}_l$ and the \texttt{HTLC-success} that pays the
        counterparty for HTLC of the channel after \alice{})
        \label{alg:sim:resolvepay:nofulfill:cond}
      \EndIndent
      \Statex

      \Statex \textit{Effect}:
      \Indent
        \State add (\alice, \textit{payid}) to \texttt{charged}(payer)
        \If{there is an $h \neq \top$ member in \texttt{payids} entry}
        \Comment{adversarially initiated payment, functionality doesn't know
        path}
          \State append $\overrightarrow{\mathtt{path}}$ to
          \texttt{charged}(\alice) entry
        \EndIf
        \State remove ($\overrightarrow{\mathtt{path}}$, \_,
        \textit{payid}) from \texttt{payids}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay:nofulfill}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ -- honest
  payment}
    \begin{algorithmic}[1]
      \Statex \textit{Condition}:
      \Indent
        \State \alice{} is the payer in $\overrightarrow{\mathtt{path}}$ AND
        ((she has received \textsc{updateFulfillHtlc} AND has subsequently sent
        \textsc{commit} and \textsc{revokeAndAck}) OR (player after
        \alice{} has irrevocably fulfilled the HTLC on-chain (i.e. his
        \texttt{HTLC-success} is in $\Sigma_{\alice}$) AND \alice{} has
        received \textsc{poll} to observe it))
        \label{alg:sim:resolvepay:honest:cond}
      \EndIndent
      \Statex

      \Statex \textit{Effect}:
      \Indent
        \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
        \If{there is an $h \neq \top$ member in \texttt{payids} entry}
        \Comment{adversarially initiated payment, functionality doesn't know
        path}
          \State append $\overrightarrow{\mathtt{path}}$ to
          \texttt{charged}(\alice) entry
        \EndIf
        \State remove ($\overrightarrow{\mathtt{path}}$, \_,
        \textit{payid}) from \texttt{payids}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay:honest:fig}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  \begin{gather*}
    \forall k \in \mathbb{N}, \text{ PPT } \environment, \\
    |\Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open}}, \environment} = 1] -
    \ifelseieee{\\ -}{}
    \Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment} = 1]|
    \leq \\
    nm \cdot \mathrm{E \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) +
    \\
    nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm
    \cdot \mathrm{E \mhyphen master}(k) \enspace.
  \end{gather*}
\end{lemma}

\begin{proof}
  Before focusing on individual messages sent by \environment{} or
  \adversary, we will first prove that four particular forgery events happen
  with negligible probability. Let $P$ be the event in which at some point
  during the execution a transaction that has the following two characteristics
  appears in $\Sigma_{\alice}$, for some honest player \alice: it spends a
  funding transaction of a channel that contains \alice{} (and thus has a
  $p_{\alice, F}$ public key) and it was never signed by \alice. Suppose that
  $m$ is the maximum number of channels that a player can open and $\exists
  \text{ PPT } \environment_P: \Pr[P] = a$. We show in
  Proposition~\ref{prop:forgery:ds} that $\forall \environment, \Pr[P] \leq nm
  \cdot \mathrm{E \mhyphen ds}(k)$.

  Let $Q$ be the event in which at some point during the execution a transaction
  that has the following two characteristics appears in $\Sigma_{\alice}$, for
  some honest player \alice: it spends a simple output, delayed output or htlc
  output tied with a public key that was created by \alice{} ($p_{\alice,
  \mathrm{pay}, n}, p_{\alice, \mathrm{dpay}, n}, p_{\alice, \mathrm{htlc}, n}$
  respectively) and it was never signed by \alice. Suppose that $p$ is the
  maximum total number of opens and updates that a player can perform and that
  $\exists \text{ PPT } \environment_Q: \Pr[Q] = b$. We show
  in Proposition~\ref{prop:forgery:ibs} that $\forall \environment, \Pr[Q] \leq
  3np \cdot \mathrm{E \mhyphen ibs}(k)$.

  Let $R$ be the event in which at some point during the execution a transaction
  that has the following characteristic appears in $\Sigma_{\alice}$, for some
  honest player \alice: it spends the revocation output of a local (for
  \alice{}) commitment transaction for a channel that contains \alice{} and
  \bob{} (and thus has a $p_{\bob, \mathrm{rev}, n}$ key). Observe that, since
  \alice{} is honest and according to both the real and the ideal execution, if
  \alice{} submits her local commitment transaction $\mathtt{localCom}_n$ to the
  ledger, under no circumstances does she subsequently go on to send $s_{\alice,
  \mathrm{com}, n}$ to any party. (This secret information could be used by
  \bob{} to efficiently compute $s_{\bob, \mathrm{rev}, n}$ with
  \textsc{CombineKey}($pb_{\bob, \mathrm{rev}}, sb_{\bob, \mathrm{rev}},
  p_{\alice, \mathrm{com}, n}, s_{\alice, \mathrm{com}, n}$).) Suppose that $p$
  is the maximum total number of opens and updates that a player can perform,
  $m$ is the maximum number of opens a player can perform and $\exists \text{
  PPT } \environment_R: Pr[R] = c$. We show in
  Proposition~\ref{prop:forgery:share} that $\forall \environment, \Pr[R] \leq
  nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k)$.

  Lastly, let $S$ be the event in which at some point during the execution a
  transaction that has the following two characteristics appears in
  $\Sigma_{\alice}$, for some honest player \alice: (a) it spends the revocation
  output of a remote (for \alice{}) commitment transaction for a channel that
  contains \alice{} (and thus has a $p_{\alice, \mathrm{rev}, n}$ key) and (b)
  it was never signed by \alice. Observe that, since \alice{} is honest, she has
  never sent $s_{\alice, \mathrm{rev}, n}$ to any party. Suppose that $m$ is the
  maximum total number of opens and updates that a player can perform and that
  $\exists \text{ PPT } \environment_S: \Pr[S] = d$. We show in
  Proposition~\ref{prop:forgery:master} that $\forall \environment, \Pr[S] \leq
  nm \cdot \mathrm{E \mhyphen master}(k)$.

  In the ideal world, when the simulated \adversary{} attempts to send a
  payment by instructing corrupted \alice{} to send (\textsc{sendInvoice}, $x$,
  \textit{expayid}, \textit{payid}) to the honest payee \bob, \simulator{} sends
  (\textsc{adversarySendInvoice}, $x$, \textit{expayid}, \textit{payid},
  \textit{intid}, \textit{from} \alice, \textit{to} \bob) to
  $\fpaynet{}_{\mathrm{, Pay}}$ (Fig.~\ref{alg:sim:pay:adv},
  lines~\ref{alg:sim:pay:adv:invoice}-\ref{alg:sim:pay:adv:invoice:send}). In
  this case, $\fpaynet{}_{\mathrm{, Pay}}$ stores the intention and prompts
  \simulator{} to continue the payment (Fig.~\ref{alg:fpaynet:pay},
  lines~\ref{alg:fpaynet:invoice:adv}-\ref{alg:fpaynet:invoice:adv:send}), who
  in turn simulates the receipt of \textsc{sendInvoice} by \bob{}
  (Fig.~\ref{alg:sim:pay:adv},
  lines~\ref{alg:sim:pay:adv:invoice:recv}-\ref{alg:sim:pay:adv:invoice:cont}).
  In the real world, such a message by the adversarially controlled \alice{}
  would result in the honest \bob{} sending the same invoice, therefore the two
  behaviours are indistinguishable.

  % TODO: decide if the paragraph below is redundant
  In the ideal world, when the simulated \adversary{} attempts to add an
  HTLC by instructing corrupted \alice{} to send (\textsc{updateAddHtlc},
  \textit{pchid}, \texttt{HTLCNo}, $x$, $h$, \texttt{IncomingCltvExpiry}, $M$)
  to honest \bob, \simulator{} simply simulates the receiving of the message by
  \bob{} and subsequently carries out the rest of the simulation. In the real
  world, such a message by the adversarially controlled \alice{} would result in
  \bob{} and the rest of the ITIs following the same steps as in the simulated
  case, therefore the two behaviours are indistinguishable.

  We can now move on to treating individual messages sent by \environment{}
  during the execution. When \environment{} sends $\left(\textsc{pay}, \bob, x,
  \overrightarrow{\mathtt{path}}, \mathit{expayid}\right)$ to \alice{}
  in the ideal world, $\simulator_{\mathrm{LN - Reg - Open}}$ is always notified
  (Fig.~\ref{alg:fpaynet:pay}, line~\ref{alg:fpaynet:pay:send}) and simulates
  the relevant execution of the real world (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:pay:simulate}). No messages to \ledger{} or \environment{}
  that differ from the real world are generated in the process. At the end of
  this simulation, no further messages are sent (and the control returns to
  \environment). Therefore, when \environment{} sends \textsc{pay}, no
  opportunity for distinguishability arises.

  When \environment{} sends any message of (\textsc{pushAdd}, \textit{pchid}),
  (\textsc{pushFulfill}, \textit{pchid}), (\textsc{commit}, \textit{pchid}) to
  \alice{} in the ideal world, it is forwarded to $\simulator_{\mathrm{LN - Reg
  - Open}}$ (Fig.~\ref{alg:fpaynet:daemon},
  lines~\ref{alg:fpaynet:daemon:fulfill},~\ref{alg:fpaynet:daemon:add},~\ref{alg:fpaynet:daemon:commit}
  respectively), who in turn simulates \alice's real-world execution with her
  simulated ITI and the handling of any subsequent messages sent by \alice's ITI
  (Fig.~\ref{alg:sim:push},
  lines~\ref{alg:sim:push:fulfill},~\ref{alg:sim:push:add},~\ref{alg:sim:push:commit}).
  Neither $\fpaynet{}_{\mathrm{, Pay}}$ nor $\simulator_{\mathrm{LN - Reg -
  Open}}$ alter their state as a result of these messages, apart from the state
  of \alice's simulated ITI and the state of other simulated ITIs that receive
  and handle messages that were sent as a result of \alice's ITI simulation. The
  states of these ITIs are modified in the exact same way as they would in the
  real world. We deduce that these three messages do not introduce any
  opportunity for \environment{} to distinguish the real and the ideal world.

  When \environment{} sends (\textsc{fulfillOnChain}) to \alice{} in the real
  world, lines~\ref{alg:protocol:pay:foc:top}-\ref{alg:protocol:pay:foc:submit}
  of Fig.~\ref{alg:protocol:pay:foc} are executed by \alice. In the ideal world
  on the other hand, $\fpaynet{}_{\mathrm{, Pay}}$ sends (\textsc{read}) to
  \ledger{} (Fig.~\ref{alg:fpaynet:daemon},
  line~\ref{alg:fpaynet:daemon:foc:read}) as \alice{} and subsequently instructs
  $\simulator_{\mathrm{LN - Reg - Open}}$ to simulate the receiving of
  (\textsc{fulfillOnChain}) with \alice{}'s ITI (Fig.~\ref{alg:sim:pay},
  lines~\ref{alg:sim:pay:foc:top}-\ref{alg:sim:pay:foc:run}). Observe that
  during this simulation a second (\textsc{read}) message to \ledger{} (that
  would not match any message in the real world) is avoided because
  $\simulator_{\mathrm{LN - Reg - Open}}$ skips
  line~\ref{alg:protocol:pay:foc:read} of Fig.~\ref{alg:protocol:pay:foc},
  using as $t$ the one received from $\fpaynet{}_{\mathrm{, Pay}}$ in the
  message (\textsc{fulfillOnChain}, $t$, \alice). Since $\fpaynet{}_{\mathrm{,
  Pay}}$ sends (\textsc{read}) to \ledger{} as \alice{} and given that after
  \ledger{} replies, control is given directly to $\simulator_{\mathrm{LN - Reg
  - Open}}$, the $t$ used during the simulation of \alice's ITI is identical to
  the one that \alice{} would obtain in the real-world execution. The rest of
  the simulation is thus identical with the real-world execution, therefore
  \textsc{fulfillOnChain} does not introduce any opportunity for
  distinghuishability.

  When \environment{} sends (\textsc{poll}) to \alice, the first action is
  sending (\textsc{read}) as \alice{} to \ledger{} both in the ideal
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:read}) and the real
  (Fig.~\ref{alg:protocol:poll}, line~\ref{alg:protocol:poll:read}) worlds.
  Subsequently, in the real world
  lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:submit} of
  Fig.~\ref{alg:protocol:poll} are executed by \alice, whereas in the ideal
  world, given that the checks of lines~\ref{alg:fpaynet:poll:haspolled}
  and~\ref{alg:fpaynet:poll:ifdsforgery} do not lead to a bad event (and thus
  given that the functionality does not halt in
  lines~\ref{alg:fpaynet:poll:haspolled:halt}
  or~\ref{alg:fpaynet:poll:dsforgery}), a (\textsc{poll}) message is sent to
  $\simulator_{\mathrm{LN - Reg - Open}}$. We will prove later that
  $\fpaynet{}_{\mathrm{, Pay}}$ does not halt here. Upon receiving
  (\textsc{poll}), $\simulator_{\mathrm{LN - Reg - Open}}$ simulates receiving
  (\textsc{poll}) with \alice's ITI (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:poll:run}), but does not \textsc{read} from \ledger{} and
  uses instead the $\Sigma_{\alice}$ provided along with the message. A
  reasoning identical to that found in the previous paragraph shows that this
  $\Sigma_{\alice}$ is exactly the same as that which \alice's ITI would obtain
  had it executed line~\ref{alg:protocol:poll:read} of
  Fig.~\ref{alg:protocol:poll} and thus the simulation of \alice's ITI is
  identical to what would happen in the same case in the real world, up to and
  including line~\ref{alg:protocol:poll:submit} of Fig.~\ref{alg:protocol:poll}.

  The event $E$ in which $\fpaynet{}_{\mathrm{, Pay}}$ executes
  line~\ref{alg:fpaynet:poll:dsforgery} of Fig.~\ref{alg:fpaynet:poll} and
  halts can only happen if there is a non-commitment transaction that contains a
  valid signature by the $p_{\alice, F}$ key that is needed to spend the funding
  transaction of an open channel. According to $\Pi_{LN}$, \alice{} signs with
  her $s_{\alice, F}$ key only commitment transactions. Therefore $E \subset P
  \Rightarrow \Pr[E | \neg P] = 0$.

  Let $E'$ the ``bad'' event in which $\fpaynet{}_{\mathrm{, Pay}}$ executes
  line~\ref{alg:fpaynet:poll:haspolled:halt} of Fig.~\ref{alg:fpaynet:poll} and
  halts. We will now prove that, during $\textsc{Exec}^{\fpaynet{}_{\mathrm{,
  Pay}}, \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment}$,
  it is $\Pr[E | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$. The
  condition of Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:haspolled} is triggered if the delayed output (that
  of the malicious party) of $\mathtt{tx}_1$ has been spent by the transaction
  $\mathtt{tx}_2$ in $\Sigma_{\alice}$ (event $E'_1$) and \texttt{polls}(\alice)
  contains an element in $\left[h_1, h_1 + \mathtt{delay}\left(\alice\right) -
  1\right]$, where $h_1$ is the block height where $\mathtt{tx}_1$ is (event
  $E'_2$). Observe that $E' = E'_1 \wedge E'_2$. We note that the elements in
  \texttt{polls}(\alice) correspond to the block heights of $\Sigma_{\alice}$ at
  the moments when \alice{} \textsc{poll}s (Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:height}). Consider the following two events:
  $E'_{1,1}: \mathtt{tx}_2$ spends the delayed output with a signature valid by
  the delayed payment public key after the locktime expires. $E'_{1,2}:
  \mathtt{tx}_2$ spends the delayed output with a signature valid by the
  revocation public key $p_{\alice, \mathrm{rev}}$. Note that $E'_1 = E'_{1,1}
  \vee E'_{1,2}$ and $E'_{1,1}, E'_{1,2}$ are mutually exclusive (since the same
  output cannot be spent twice). Observe that $E'_{1,2} \subset S$, thus
  $\Pr\left[E'_{1,2} | \neg S\right] = 0$. We now concetrate on the event
  $E'_{1,1}$. Due to the fact that $\mathtt{tx}_2$ spends an output locked with
  a relative timelock of length $\mathtt{delay}\left(\alice\right) + \tochain$,
  the commitment transaction $\mathtt{tx}_1$ can reside in a block of maximum
  height $h_1 \leq h_2 - \mathtt{delay}\left(\alice\right) - \tochain$, where
  $h_2$ is the block height where $\mathtt{tx}_2$ is. If \alice{} \textsc{poll}s
  on a moment when $|\Sigma_{\alice}| \geq h_1, \Sigma_{\alice}$ necessarily
  contains $\mathtt{tx}_1$. Furthermore, if \alice{} \textsc{poll}s on a moment
  when $|\Sigma_{\alice}| \leq h_1 + \mathtt{delay}\left(\alice\right) - 1 \leq
  h_2 - \tochain{} - 1$, she sees $\mathtt{tx}_1$ and directly submits the
  punishment transaction $\mathtt{tx}_3$ (which she has, given that a
  maliciously closed channel is defined as one where the non-closing party has
  the punishment transaction) (Fig.~\ref{alg:protocol:poll:closedch},
  lines~\ref{alg:protocol:poll:mal:tx}-\ref{alg:protocol:poll:mal:submit}).
  Given that $\mathtt{tx}_3$ is broadcast when $|\Sigma_{\alice}| \leq h_2 -
  \tochain{}$, it is guaranteed to be on-chain in a block $h_3 \leq h_2$
  (according to Proposition~\ref{prop:tochain}). Since $\mathtt{tx}_3$ spends
  the same funds as $\mathtt{tx}_2$, the two cannot be part of the chain
  simultaneously. Since $E'_{1,1} \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_2$ and $E'_2 \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_3$, $E'_{1,1}$ and $E'_2$ are mutually exclusive. Therefore,
  assuming $\neg P \wedge \neg Q \wedge \neg R \wedge \neg S$, it is
  $\Pr\left[E'\right] = \Pr\left[\left(E'_{1,1} \vee E'_{1,2}\right) \wedge
  E'_2\right] = \Pr\left[\left(E'_{1,1} \wedge E'_2\right) \vee \left(E'_{1,2}
  \wedge E'_2\right)\right] \leq \Pr\left[E'_{1,1} \wedge E'_2\right] +
  \Pr\left[E'_{1,2} \wedge E'_2\right] = \Pr$ $\left[ E'_{1,2} \wedge
  E'_2\right] \leq \Pr\left[E'_{1,2}\right] = 0$. We conclude that, given $\neg
  P \wedge \neg Q \wedge \neg R \wedge \neg S$ \textsc{poll} introduces no
  opportunity for distinghuishability.

  We now treat the effects of the (\textsc{state}, $\Sigma$) message that
  $\fpaynet{}_{\mathrm{, Pay}}$ sends to $\simulator_{\mathrm{LN - Reg -
  Open}}$, appended to \textsc{pay}, \textsc{pushFulfill}, \textsc{pushAdd} and
  \textsc{commit} messages. We first observe that the (\textsc{state}) message
  is handled after handling the first message (which is of one of the four
  aforementioned types) (Fig.~\ref{alg:sim:resolvepay},
  line~\ref{alg:sim:resolvepay:firstmsg}). It may be the case that at the end of
  the handling of line~\ref{alg:sim:resolvepay:firstmsg},
  $\simulator_{\mathrm{LN - Reg - Open}}$ does not have control of the
  execution. That can happen if a simulated ITI sends a message to a corrupted
  player and that player does not respond (e.g. in
  Fig.~\ref{alg:protocol:pay:outofband},
  line~\ref{alg:protocol:pay:sendinvoice}, when the first message is
  $\left(\textsc{pay}, \bob, x, \overrightarrow{\mathtt{path}},
  \_\right)$ and \bob{} is corrupted), or if the handling of the
  message results in sending (\textsc{submit}) to \ledger{} (e.g. in
  Fig.~\ref{alg:protocol:pay:push}, line~\ref{alg:protocol:pushfulfill:submit}
  when the first message is (\textsc{pushFulfill}, \textit{pchid}) and
  counterparty has gone on-chain). In that case, the (\textsc{state}) message is
  simply ignored (Fig.~\ref{alg:sim:resolvepay},
  line~\ref{alg:sim:resolvepay:mayberesolve}) and does not influence execution
  in any way.

  In the case when $\left(\textsc{state}, \Sigma\right)$ is handled,
  $\simulator_{\mathrm{LN - Reg - Open}}$ attempts to specify who was charged
  for each pending payment, based on the information that the potentially paying
  party sees in its view of the \ledger{} state (Fig.~\ref{alg:sim:resolvepay},
  lines~\ref{alg:sim:resolvepay:everystate}-\ref{alg:sim:resolvepay:loopend}).
  The resolution is then sent to $\fpaynet{}_{\mathrm{, Pay}}$ with the message
  (\textsc{resolvePays}, \texttt{charged}). $\fpaynet{}_{\mathrm{, Pay}}$
  handles this message in Fig.~\ref{alg:fpaynet:resolvepay}
  and~\ref{alg:fpaynet:resolvepay:loops}, where, if it does not halt
  (Fig.~\ref{alg:fpaynet:resolvepay:honestpayer},
  lines~\ref{alg:fpaynet:resolvepay:halt:ds},~\ref{alg:fpaynet:resolvepay:halt:rel}
  and~\ref{alg:fpaynet:resolvepay:halt:abs} and
  Fig.~\ref{alg:fpaynet:resolvepay:loops},
  lines~\ref{alg:fpaynet:resolvepay:loops:halt:do},~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:halt}
  and~\ref{alg:fpaynet:resolvepay:loops:indiffs:credit:halt}), it
  updates the state of each affected channel
  (Fig.~\ref{alg:fpaynet:resolvepay:loops},
  line~\ref{alg:fpaynet:resolvepay:loops:update:do}) and does not send any
  message, thus control returns to \environment. We will prove that, under $\neg
  P \wedge \neg Q \wedge \neg R \wedge \neg S$, $\fpaynet{}_{\mathrm{, Pay}}$
  does not halt and thus conclude that the handling of a (\textsc{state})
  message does not introduce opportunity for distinguishability.

  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:ds} of
  Fig.~\ref{alg:fpaynet:resolvepay:honestpayer} if the honest player \dave{} was
  charged for a payment over a channel that was closed without using a
  commitment transaction. Like $E$, this event is a subset of $P$, thus cannot
  happen given $\neg P$.

  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:rel} of
  Fig.~\ref{alg:fpaynet:resolvepay:honestpayer} if the player \dave{} charged is
  an honest member of the payment path, has \textsc{poll}ed in time to catch a
  malicious closure (event $A$) but a malicious closure succeeded (event $B$).
  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:abs} of
  Fig.~\ref{alg:fpaynet:resolvepay:honestpayer} if \dave{} is not the payer, no
  malicious closure succeeded ($\neg B$) and \dave{} has \textsc{poll}ed in time
  twice to learn the preimage of the HTLC early enough (event $C$) and has
  attempted to fulfill on chain at the right moment (event $D$).
  $\fpaynet{}_{\mathrm{, Pay}}$ also halts if the two expiries do not have the
  expected distance (event $F$) -- i.e. halts in the event $(A \wedge B) \vee
  (\neg B \wedge (F \vee (C \wedge D)))$. $\simulator_{\mathrm{LN - Reg -
  Open}}$ decides that \dave{} is charged if his previous counterparty did a
  malicious closure to a channel version without the HTLC and spent their
  (delayed) output ($B$), or if his next counterparty fulfilled (event $G$) and
  his previous counterparty timed out the HTLC (event $H$)
  (Fig.~\ref{alg:sim:resolvepay}, line~\ref{alg:sim:resolvepay:negligent}), --
  i.e. \dave{} is charged in the event $B \vee (G \wedge H)$.

  We will now show that $\Pr[A \wedge B | \neg P \wedge \neg Q \wedge \neg R
  \wedge \neg S] = 0 \wedge \Pr[(C \wedge D) \wedge (G \wedge H) | \neg P \wedge
  \neg Q \wedge \neg R \wedge \neg S] = 0 \wedge \Pr[F \wedge (G \wedge H) |
  \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$, from which we can
  deduce that $\Pr[(A \wedge B) \vee ((F \vee (C \wedge D)) \wedge (G \wedge H))
  | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$ and thus $\Pr[((A
  \wedge B) \vee (\neg B \wedge (F \vee (C \wedge D)))) \wedge (B \vee (G \wedge
  H)) | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$. This last step
  holds because $(A \wedge B) \vee ((F \vee (C \wedge D)) \wedge (G \wedge H)) =
  (A \wedge B) \vee ((F \vee (C \wedge D) \wedge G \wedge H)$ and $((A \wedge B)
  \vee (\neg B \wedge (F \vee (C \wedge D)))) \wedge (B \vee (G \wedge H)) = (A
  \wedge B) \vee (\neg B \wedge (F \vee (C \wedge D)) \wedge G \wedge H)$ and
  the latter is a subset of the former.

  The analysis of the event $A \wedge B$ is identical to the one we did
  previously for the events $E'_1, E'_2$, with $A$ corresponding to $E'_2$ and
  $B$ to $E'_1$. We thus deduce that $\Pr[A \wedge B | \neg P \wedge \neg Q
  \wedge \neg R \wedge \neg S] = 0$.

  Event $F$ is true only if $\mathtt{IncomingCltvExpiry} -
  \mathtt{OutgoingCltvExpiry} < \mathtt{relayDelay}(\alice) + \tochain$. This
  cannot happen however for any honest \alice, since \simulator{} will simulate
  line~\ref{alg:protocol:pay:updateAddHtlc:slack} of
  Fig.~\ref{alg:protocol:pay:updateAddHtlc:checks} with \alice's ITI before
  having her agree to participate as an intermediary in the multi-hop payment.
  Therefore $\Pr[F \wedge (G \wedge H) | \neg P \wedge \neg Q \wedge \neg R
  \wedge \neg S] = 0$.

  The only way for event $C$ to be true is if \environment{} sends
  (\textsc{poll}) to \dave{} during the prescribed time period
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:height}) -- note that
  the addition to \texttt{polls}(\dave) during registration
  (Fig.~\ref{alg:fpaynet:support}, line~\ref{alg:fpaynet:support:read}) cannot
  be within the desired range due to the fact that \texttt{OutgoingCltvExpiry}
  is not smaller than the chain height when the corresponding (\textsc{invoice})
  was received (Fig.~\ref{alg:protocol:pay:invoice},
  line~\ref{alg:protocol:pay:invoice:cltv}), registration happens necessarily
  before handling (\textsc{invoice}) (Fig.~\ref{alg:fpaynet:support},
  line~\ref{alg:fpaynet:support:unreg}) and the element added to
  \texttt{polls}(\dave) at registration is the chain height at that time
  (Fig.~\ref{alg:fpaynet:support}, line~\ref{alg:fpaynet:support:read}). When
  \dave{} receives (\textsc{poll}), $\fpaynet{}_{\mathrm{, Pay}}$ always sends
  (\textsc{getClosedFunds}) to $\simulator_{\mathrm{LN - Reg - Open}}$
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:send}) (since, as we
  saw earlier, $\fpaynet{}_{\mathrm{, Pay}}$ never halts).

  Event $H$ happens only when the previous counterparty successfully appends
  \texttt{HTLC-timeout} to $\Sigma_{\dave}$, which is a valid transaction only
  from the block of height $\mathtt{IncomingCltvExpiry} + 1$ and on, or if the
  previous counterparty learns the preimage of the HTLC and forges a signature
  valid by \dave's public HTLC key, or if the previous counterparty forges a
  signature valid by \dave's public revocation key; the two latter scenarios can
  never happen. Thus, given that $G$ happens until a moment when
  $|\Sigma_{\dave}| \leq \mathtt{IncomingCltvExpiry} - \tochain{}$, \dave{} has
  the time to successfully fulfill the HTLC. Given $C$, \dave{} has
  \textsc{poll}ed at two moments $h_1, h_2 \in$ [\texttt{OutgoingCltvExpiry},
  \texttt{IncomingCltvExpiry} - (2 + $r$)\texttt{windowSize}], such that $h_2
  \geq h_1 + \tochain{}$. If $\Sigma_{\dave}$ contains the preimage at moment
  $h_1$ or $h_2$, then \dave{} may try to update the previous channel off-chain
  if he receives a (\textsc{pushFulfill}) for that channel
  (Fig.~\ref{alg:protocol:pay:push},
  lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:submit}),
  and if the off-chain update is never attempted (because (\textsc{pushFulfill})
  and (\textsc{commit}) are not received) or fails (because the previous
  counterparty does not send (\textsc{revokeAndAck})), then the
  (\textsc{fulfillOnChain}) that he receives according to $D$ will make him
  submit \texttt{HTLC-success} (Fig.~\ref{alg:protocol:pay:foc},
  lines~\ref{alg:protocol:pay:foc:top}-\ref{alg:protocol:pay:foc:submit}) and
  have it on-chain by block of height \texttt{IncomingCltvExpiry}
  (Proposition~\ref{prop:tochain}). Furthermore, in the case that the
  \texttt{HTLC-success} is not found at the (\textsc{poll}) of $h_1$, \dave{}
  immediately submits \texttt{HTLC-timeout}
  (Fig.~\ref{alg:protocol:poll:closedch},
  line~\ref{alg:protocol:poll:htlc:submit}), which either ends up in
  $\Sigma_{\dave}$ by block height $h_1 + \tochain{}$
  (Proposition~\ref{prop:tochain}) or is rejected because the counterparty
  managed to append \texttt{HTLC-success} before it. In the first case, \dave{}
  is not charged for the payment. In the second case, the second (\textsc{poll})
  (at block height $h_2$) necessarily reveals the \texttt{HTLC-success} to
  \dave{} and subsequently the (\textsc{fulfillOnChain}) causes \dave{} to
  fulfill the HTLC with the previous counterparty, as argued above. Therefore in
  no case \dave{} is charged for the payment, i.e. $\Pr[(C \wedge D) \wedge (G
  \wedge H) | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$.

  We will now show that the halt of
  line~\ref{alg:fpaynet:resolvepay:failed:reported} in
  Fig.~\ref{alg:fpaynet:resolvepay} does not occur with non-negligible
  probability. If the check of line~\ref{alg:fpaynet:resolvepay:failed:if}
  succeeds, this means that line~\ref{alg:sim:pay:failed} of
  Fig.~\ref{alg:sim:pay} was executed by \simulator{}, therefore the payment
  referred to by \textit{payid} failed, therefore neither \alice{} nor \bob{}
  saw the relevant HTLC being fulfilled; call this event $T$. If now the check
  of line~\ref{alg:fpaynet:resolvepay:failed:reported:if} succeeds, this means
  that \fpaynet{} has received the relevant entry from \simulator{} in a
  \textsc{newPayments} message (Fig.~\ref{alg:fpaynet:payments},
  line~\ref{alg:fpaynet:payments:add:pendingdiffs}). This in turn happens in one
  of the following cases: line~\ref{alg:sim:foc:report} of
  Fig.~\ref{alg:sim:pay}, line~\ref{alg:sim:poll:report} of
  Fig.~\ref{alg:sim:pay}, line~\ref{alg:sim:pushfulfill:report} of
  Fig.~\ref{alg:sim:push}, and line~\ref{alg:sim:push:report:payments} of
  Fig.~\ref{alg:sim:push}. Line~\ref{alg:sim:foc:report} of
  Fig.~\ref{alg:sim:pay} can only be executed if the simulated \alice{} or
  \bob{} has successfully fulfilled on chain the relevant HTLC
  (Fig.~\ref{alg:protocol:pay:foc},
  line~\ref{alg:protocol:pay:foc:payment:loop}), which however is incompatible
  with $T$. Line~\ref{alg:sim:poll:report} of Fig.~\ref{alg:sim:pay} is executed
  if the simulated \alice{} has executed line~\ref{alg:protocol:poll:report:pay}
  of Fig.~\ref{alg:protocol:poll:closedch}, which means that the relevant
  (offered) HTLC has been spent (i.e. fulfilled)
  (line~\ref{alg:protocol:poll:htlc:spent:loop},
  Fig.~\ref{alg:protocol:poll:closedch}), which is incompatible with $T$.
  Line~\ref{alg:sim:pushfulfill:report} of Fig.~\ref{alg:sim:push} is executed
  if the simulated \bob{} executes line~\ref{alg:protocol:pushfulfill:report} of
  Fig.~\ref{alg:protocol:pay:push}, which happens only if a relevant entry
  exists in \texttt{gotPaid} (line~\ref{alg:protocol:pushfulfill:check:gotpaid},
  Fig.~\ref{alg:protocol:pay:push}), which in turn can only be added in
  line~\ref{alg:protocol:pay:updateAddHtlc:gotpaid} of
  Fig.~\ref{alg:protocol:pay:updateAddHtlc}. In order to reach that point of the
  execution however, all \textsc{updateAddHtlc} checks must have passed, which
  is incompatible with $T$. The last possible case in which the entry is added
  to \texttt{pendingDiffs} is line~\ref{alg:sim:push:report:payments} of
  Fig.~\ref{alg:sim:push}. This is executed if
  line~\ref{alg:protocol:pay:raa:report:payments} of
  Fig.~\ref{alg:protocol:pay:revokeAndAck} is executed either in the simulated
  \alice{} or in the simulated \bob. The field \texttt{updateDiffs} can be
  populated only in line~\ref{alg:protocol:pushfulfill:updatediffs} of
  Fig.~\ref{alg:protocol:pay:push} for \alice{} or
  line~\ref{alg:protocol:pay:updateFulfillHtlc:updatediffs} of
  Fig.~\ref{alg:protocol:pay:updateFulfillHtlc} for \bob. The former case can
  only happen if there was a corresponding entry in \texttt{gotPaid}, which, as
  we saw before, is incompatible with $T$. Likewise, the latter can only happen
  if \alice{} receives an \textsc{updateFulfillHtlc} message for the HTLC
  corresponding to the payment, which can only happen if no
  \textsc{updateAddHtlc} fails, which is contrary to $T$. Therefore the halt of
  Fig.~\ref{alg:fpaynet:resolvepay},
  line~\ref{alg:fpaynet:resolvepay:failed:reported} cannot happen.

  Moving on, we have to prove that the halt of
  line~\ref{alg:fpaynet:resolvepay:loops:halt:do} in
  Fig.~\ref{alg:fpaynet:resolvepay:loops} does not occur with non-negligible
  probability. Indeed, \simulator{} only reports the payment as resolved in
  \textsc{resolvePays} if a party has been irrevocably charged for it
  (Fig.~\ref{alg:sim:resolvepay},
  lines~\ref{alg:sim:resolvepay:corrupted},~\ref{alg:sim:resolvepay:negligent},
  or~\ref{alg:sim:resolvepay:honest}). In all three cases, all channels that
  follow the \texttt{charged} party on the $\overrightarrow{\mathtt{path}}$ have
  either been closed or irrevocably updated to a newer version that includes the
  new balance. Since \fpaynet{} may only halt for a \texttt{channel} that has
  not been declared or confirmed as closed
  (Fig.~\ref{alg:fpaynet:resolvepay:loops},
  lines~\ref{alg:fpaynet:resolvepay:loops:update:loop}
  and~\ref{alg:fpaynet:resolvepay:loops:halt:loop}), all channels that can cause
  a halt are channels that have the update of this payment irrevocably
  committed. This only happens when both sides send a \textsc{revokeAndAck} that
  updates the channel from a version that contains the relevant HTLC to a
  version that doesn't; and when an honest party receives such a
  \textsc{revokeAndAck} message, it logs the new receipt in
  \texttt{updatesToReport} (Fig.~\ref{alg:protocol:pay:revokeAndAck},
  line~\ref{alg:protocol:pay:raa:report:updates}) which causes \simulator{} to
  report the update to \fpaynet{} (Fig.~\ref{alg:sim:push},
  line~\ref{alg:sim:push:report:updates}). We therefore conclude that \fpaynet{}
  never halts on line~\ref{alg:fpaynet:resolvepay:loops:halt:do} of
  Fig.~\ref{alg:fpaynet:resolvepay:loops}.

  It remains to be proven that \fpaynet{} does not halt with
  non-negligible probability in
  lines~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:halt}
  and~\ref{alg:fpaynet:resolvepay:loops:indiffs:credit:halt} of
  Fig.~\ref{alg:fpaynet:resolvepay:loops}. For the halt of
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:halt} to occur, the
  player charged must be the payer (as intended by the original \textsc{pay}
  messsage) and honest, but its \texttt{pendingDiffs} must not contain a
  corresponding entry for that payment. This however cannot happen for the
  following reason. As execution is in the loop of
  Fig.~\ref{alg:fpaynet:resolvepay},
  line~\ref{alg:fpaynet:resolvepay:innerloop}, it is $(\dave, \mathit{payid})
  \in \mathtt{charged}(\alice)$. As the code of
  Fig.~\ref{alg:fpaynet:resolvepay:loops} is being run, either
  line~\ref{alg:fpaynet:resolvepay:corrupted:gotoloops} of
  Fig.~\ref{alg:fpaynet:resolvepay}
  or~\ref{alg:fpaynet:resolvepay:honest:gotoloops} of
  Fig.~\ref{alg:fpaynet:resolvepay:honestpayer} has been executed, so
  line~\ref{alg:fpaynet:resolvepay:continue} has not been executed in the same
  iteration of the loop, therefore $\dave \neq \bot$. Additionally, since
  \fpaynet{} received a \textsc{resolvePays} message, \simulator{} has executed
  Fig.~\ref{alg:sim:resolvepay} and added (\dave, \textit{payid}) to
  \texttt{charged}(\alice) in exactly one of
  lines~\ref{alg:sim:resolvepay:corrupted:do},~\ref{alg:sim:resolvepay:negligent:do},
  or~\ref{alg:sim:resolvepay:honest:do}. Furthermore, since $\alice \notin
  \mathtt{corrupted}$ (Fig.~\ref{alg:fpaynet:resolvepay:loops},
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:cond}), the condition of
  Fig.~\ref{alg:sim:resolvepay:corrupted:fig} does not hold and since \alice{}
  is the payer ($\dave{} = \alice$), there is no channel ``before'' her,
  therefore the condition of Fig.~\ref{alg:sim:resolvepay:nofulfill} does not
  hold either. Therefore the only way for \texttt{charged}(\alice) to contain
  (\alice, \textit{payid}) is if the condition of
  Fig~\ref{alg:sim:resolvepay:honest:fig} is true. The condition holds either
  when \alice{} has received \textsc{updateFulfillHtlc} on the fulfilment of the
  payment, followed by a \textsc{revokeAndAck}, or if her counterparty has
  fulfilled on-chain and she has checked the blockchain since. In the first
  case, the tuple (\textit{expayid}, \textit{payid}, \_) would have been added
  to \texttt{pendingDiffs}(\alice) as \simulator{} would have simulated
  line~\ref{alg:protocol:pay:updateFulfillHtlc:updatediffs} of
  Fig.~\ref{alg:protocol:pay:updateFulfillHtlc} on receiving
  \textsc{updateFulfillHtlc}, thus adding the tuple to \texttt{updateDiffs}, and
  line~\ref{alg:protocol:pay:raa:report:payments} of
  Fig.~\ref{alg:protocol:pay:revokeAndAck}, thus prompting \simulator{} to send
  the tuple to \fpaynet{} (Fig.~\ref{alg:sim:push},
  line~\ref{alg:sim:push:report:payments}), which would subsequently add it to
  \texttt{pendingDiffs} (Fig.~\ref{alg:fpaynet:pay},
  line~\ref{alg:fpaynet:payments:add:pendingdiffs}). Therefore in this case the
  halt is impossible. In the alternative case, since \alice{} must have
  \textsc{poll}ed after her counterparty's \texttt{HTLC-success} was settled
  on-chain (Fig.~\ref{alg:sim:resolvepay:honest:fig},
  line~\ref{alg:sim:resolvepay:honest:cond}) and therefore the loop of
  line~\ref{alg:protocol:poll:closedch:loop} in
  Fig.~\ref{alg:protocol:poll:closedch} must have been executed by \simulator{}
  while simulating \alice, as well as the loop of
  line~\ref{alg:protocol:poll:htlc:spent:loop} of the same figure and eventually
  line~\ref{alg:protocol:poll:report:pay} in that figure, which would have
  prompted in turn \simulator{} to send the relevant \textsc{newPayments}
  message to \fpaynet{} (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:poll:report}). In that case however the tuple
  (\texttt{expayid}, \texttt{payid}, \_) would be in
  \texttt{pendingDiffs}(\alice) and the check of
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:cond},
  Fig.~\ref{alg:fpaynet:resolvepay:loops} would fail, therefore preventing the
  functionality from halting.

  We will now prove that the halt of
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:credit:halt} in
  Fig.~\ref{alg:fpaynet:resolvepay:loops} does not occur. This halt would take
  place if the payee \bob{} is honest but was not previously informed of the
  payment, i.e. the tuple (\textit{expayid}, \textit{payid}, \_) is not in
  \texttt{pendingDiffs}(\bob). Similarly to the argument for
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:debit:halt}, \simulator{} added
  (\dave, \textit{payid}) to \texttt{charged}(\bob) in exactly one of
  lines~\ref{alg:sim:resolvepay:corrupted:do},~\ref{alg:sim:resolvepay:negligent:do},
  or~\ref{alg:sim:resolvepay:honest:do} of Fig.~\ref{alg:sim:resolvepay}. In the
  first case, there was a player on the path that fulfilled the payment. This
  can only happen if first \bob{} has fulfilled the payment and irrevocably
  committed to a channel version that resolves the HTLC to his favour, therefore
  \bob{} has either sent a relevant \textsc{updateFulfillHtlc} and
  \textsc{revokeAndAck} or has fulfilled on-chain. As we saw previously, both
  these scenarios would lead to \texttt{pendingDiffs}(\bob) containing the
  (\texttt{expayid}, \texttt{payid}, \_) tuple. In the second and third cases
  (line~\ref{alg:sim:resolvepay:nofulfill:cond},
  Fig.~\ref{alg:sim:resolvepay:nofulfill} and
  line~\ref{alg:sim:resolvepay:honest:cond},
  Fig.~\ref{alg:sim:resolvepay:honest:fig}) once again the conditions describe
  situations which are possible only if \bob{} has already successfully
  fulfilled, which means that he has necessarily caused \simulator{} to send the
  payment to \fpaynet{}, which has added it to \texttt{pendingDiffs}(\bob). We
  conclude that the halt of
  line~\ref{alg:fpaynet:resolvepay:loops:indiffs:credit:halt},
  Fig.~\ref{alg:fpaynet:resolvepay:loops} cannot occur.

  To conclude, given $\neg P \wedge \neg Q \wedge \neg R \wedge \neg S$, it is
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open}}, \environment} = \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
  \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment}$. If we
  allow for forgeries again, i.e. if we allow the event $P \vee Q \vee R \vee
  S$, we observe that $\Pr[P \vee Q \vee R \vee S] \leq nm \cdot \mathrm{E
  \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) + nmp \cdot \mathrm{E
  \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm \cdot \mathrm{E \mhyphen
  master}(k)$, where $n$ is the number of players, $m$ is the maximum channels a
  player can open and $p$ is the maximum number of updates a player can perform.
  We thus deduce that
  \begin{gather*}
    \forall k \in \mathbb{N}, \text{ PPT } \environment, \\
    |\Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open}}, \environment} = 1] -
    \ifelseieee{\\ -}{}
    \Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment} = 1]|
    \leq \\
    nm \cdot \mathrm{E \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) +
    \\
    nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm
    \cdot \mathrm{E \mhyphen master}(k) \enspace.
  \end{gather*}
\end{proof}
