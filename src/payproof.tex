\begin{figure}[H]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{registered}, \textsc{openChannel}, \textsc{channelAnnounced},
      \textsc{checkNew}, \textsc{poll}, \textsc{pay}, \textsc{pushAdd},
      \textsc{pushFulfill}, \textsc{fulfillOnChain} and \textsc{commit}, act
      like \fpaynet{}.
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - pay}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving $\left(\textsc{fulfillOnChain}, t, \alice\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \label{alg:sim:pay:foc:top}
      \Indent
        \State execute
        lines~\ref{alg:protocol:pay:foc:tosubmit}-\ref{alg:protocol:pay:foc:submit}
        of Fig.~\ref{alg:protocol:pay:push} as \alice{}, using $t$ from message
        \label{alg:sim:pay:foc:run}
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State add ($\overrightarrow{\mathtt{path}}$, \textit{payid}) to
        \texttt{payids}
        \State strip \textit{payid}, simulate receiving the message with
        \alice{} ITI and further execute the parts of $\Pi_{\mathrm{LN}}$ that
        correspond to honest parties (Fig.~\ref{alg:protocol:pay:invoice}-
        Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \label{alg:sim:pay:simulate}
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until \bob{} processes
        \textsc{updateAddHtlc}} \Comment{payment failed}
          \State add $\left(\bot, \mathit{payid}\right)$ to
          \texttt{charged}(\alice)
          \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid}) from
          \texttt{payids}
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{getClosedFunds}, \texttt{toReport},
      $\Sigma_{\alice}$, \alice, \textit{reportid}) from $\fpaynet{}_{\mathrm{,
      Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:poll},
        lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:beforesubmit}
        on input (\textsc{poll}), using $\Sigma_{\alice}$ from the message, with
        \alice's ITI
        \label{alg:sim:poll:run}
        \State add all channels in \texttt{toSubmit} of \alice's ITI to
        \texttt{details}(\alice)
        \label{alg:sim:poll:save}
        \State The next time we receive a message from $\fpaynet{}_{\mathrm{,
        Pay}}$ that contains a $\Sigma_{\alice}$ that contains all txs in
        \texttt{toSubmit}, concatenate (\textsc{channelsClosed},
        \texttt{details}(\alice), \textit{reportid}) to the first subsequent
        message to $\fpaynet{}_{\mathrm{, Pay}}$ and clear
        \texttt{details}(\alice)
        \label{alg:sim:poll:inform}
        \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger{} as \alice
        \label{alg:sim:poll:submit}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - push}
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:end}
        on input (\textsc{pushFulfill}, \textit{pchid}) with \alice's ITI and
        handle subsequent messages by simulating respective ITIs of honest
        players or sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:fulfill}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{pushAdd}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushadd:start}-\ref{alg:protocol:pushadd:end} on
        input (\textsc{pushAdd}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:add}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{commit}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:commit} on input
        (\textsc{commit}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:commit}
        \If{during the simulation above, line~\ref{alg:protocol:pay:raa:report}
        of Fig.~\ref{alg:protocol:pay:revokeAndAck} is simulated in \alice's
        ITI}
          \State send (\textsc{update}, \texttt{receipt}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{receipt} is the receipt
          just added to the simulated \texttt{updatesToReport}
          (Fig.~\ref{alg:protocol:pay:revokeAndAck},
          line~\ref{alg:protocol:pay:raa:report})
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:push}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - resolve
  payments}
    \begin{algorithmic}[1]
      \State Upon receiving any message with a concatenated (\textsc{state},
      $\Sigma$) part from $\fpaynet{}_{\mathrm{, Pay}}$: \Comment{\textsc{pay},
      \textsc{pushFulfill}, \textsc{pushAdd}, \textsc{commit}}
        \Indent
        \State handle first part of the message normally
        \label{alg:sim:resolvepay:firstmsg}
        \If{at the end of the simulation above, control is still held by
        \simulator}
        \label{alg:sim:resolvepay:mayberesolve}
          \ForAll{$\Sigma_{\alice} \in \Sigma$}
          \label{alg:sim:resolvepay:everystate}
            \ForAll{$(\overrightarrow{\mathtt{path}}, \mathit{payid}) \in
            \mathtt{payids} : \alice \in \overrightarrow{\mathtt{path}}$}
              \If{\alice{} sent \textsc{updateFulfillHtlc} to a corrupted player
              and either (got the fulfillment of the HTLC irrevocably committed
              OR fulfilled the HTLC on-chain (i.e. \texttt{HTLC-success} is in
              $\Sigma_{\alice}$)), AND the next honest player \bob{} down the
              line successfully timed out the HTLC on-chain (i.e.
              \texttt{HTLC-timeout} is in $\Sigma_{\bob}$)} \Comment{no or bad
              communication with \bob's previous player}
                \State add to \texttt{charged}(\alice) a tuple
                (\texttt{corrupted}, \textit{payid}) where \texttt{corrupted} is
                set to one of the corrupted parties between \alice{} and \bob{}
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \ElsIf{$\Sigma_{\alice}$ contains an old $\mathtt{remoteCom}_m$ of
              the channel before \alice{} (closer to payer) on the
              $\overrightarrow{\mathtt{path}}$ that does not contain the
              relevant HTLC and a tx that spends the delayed output of
              $\mathtt{remoteCom}_m \vee$ (($\Sigma_{\alice}$ contains the most
              recent $\mathtt{remoteCom}_n$ or $\mathtt{localCom}_n$ of the
              channel before \alice{} and the \texttt{HTLC-success} of the
              relevant HTLC $\vee$ \alice's latest irrevocably committed
              $\mathtt{remoteCom}_n$ for the channel before \alice{} does not
              contain the HTLC) $\wedge \Sigma_{\alice}$ contains the most
              recent $\mathtt{remoteCom}_l$ or $\mathtt{localCom}_l$ and (the
              \texttt{HTLC-timeout} or an \texttt{HTLC-success} that pays the
              counterparty) for HTLC of the channel after \alice{})}
              \Comment{\alice{} did not fulfill in time}
                \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \ElsIf{\alice{} is the payer in $\overrightarrow{\mathtt{path}}$
              AND ((she has received \textsc{updateFulfillHtlc} AND has
              subsequently sent \textsc{commit} and \textsc{revokeAndAck}) OR
              player after \alice{} has irrevocably fulfilled the HTLC on-chain
              (i.e. his \texttt{HTLC-success} is in $\Sigma_{\alice}$)}
              \Comment{honest payment completed}
                \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \EndIf
            \EndFor
          \EndFor
        \EndIf
        \State clear \texttt{charged} and send $\left(\textsc{resolvePays},
        \mathtt{charged}\right)$ to $\fpaynet{}_{\mathrm{, Pay}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open}}, \environment} \overset{c}{\approx}
  \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN -
  Reg - Open - Pay}}, \environment}$
\end{lemma}

\begin{proof}
  When \environment{} sends $\left(\textsc{pay}, \bob, x,
  \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to \alice{} in the
  ideal world, \simulator{} is always notified (Fig.~\ref{alg:fpaynet:pay},
  line~\ref{alg:fpaynet:pay:send}) and simulates the relevant execution of the
  real world (Fig.~\ref{alg:sim:pay}, line~\ref{alg:sim:pay:simulate}). No
  messages to \ledger{} or \environment{} that differ from the real world are
  generated in the process. At the end of this simulation, no further messages
  are sent (and the control returns to \environment). Therefore, when
  \environment{} sends \textsc{pay}, no opportunity for distinguishability
  arises.

  When \environment{} sends any message of (\textsc{pushAdd}, \textit{pchid}),
  (\textsc{pushFulfill}, \textit{pchid}), (\textsc{commit}, \textit{pchid}) to
  \alice{} in the ideal world, it is forwarded to \simulator{}
  (Fig.~\ref{alg:fpaynet:daemon},
  lines~\ref{alg:fpaynet:daemon:fulfill},~\ref{alg:fpaynet:daemon:add},~\ref{alg:fpaynet:daemon:commit}
  respectively), who in turn simulates \alice's real-world execution with her
  simulated ITI and the handling of any subsequent messages sent by \alice's ITI
  (Fig.~\ref{alg:sim:push},
  lines~\ref{alg:sim:push:fulfill},~\ref{alg:sim:push:add},~\ref{alg:sim:push:commit}).
  Neither $\fpaynet{}_{\mathrm{, Pay}}$ nor \simulator{} alter their state as a
  result of these messages, apart from the state of \alice's simulated ITI and
  the state of other simulated ITIs that receive and handle messages that were
  sent as a result of \alice's ITI simulation. The states of these ITIs are
  modified in the exact same way as they would in the real world. We deduce that
  these three messages do not introduce any opportunity for \environment{} to
  distinguish the real and the ideal world.

  When \environment{} sends (\textsc{fulfillOnChain}) to \alice{} in the real
  world, lines~\ref{alg:protocol:pay:foc:top}-\ref{alg:protocol:pay:foc:submit}
  of Fig.~\ref{alg:protocol:pay:push} are executed by \alice. In the ideal world
  on the other hand, $\fpaynet{}_{\mathrm{, Pay}}$ sends (\textsc{read}) to
  \ledger{} (Fig.~\ref{alg:fpaynet:daemon},
  line~\ref{alg:fpaynet:daemon:foc:read}) as \alice{} and subsequently lets
  \simulator{} simulate \alice{}'s ITI receiving (\textsc{fulfillOnChain})
  (Fig.~\ref{alg:sim:pay},
  lines~\ref{alg:sim:pay:foc:top}-\ref{alg:sim:pay:foc:run}). Observe that
  during this simulation a second (\textsc{read}) message to \ledger{} (that
  would not match any message in the real world) is avoided because \simulator{}
  skips line~\ref{alg:protocol:pay:foc:read} of
  Fig.~\ref{alg:protocol:pay:push}, using as $t$ the one received from
  $\fpaynet{}_{\mathrm{, Pay}}$ in the message (\textsc{fulfillOnChain}, $t$,
  \alice). Since $\fpaynet{}_{\mathrm{, Pay}}$ sends (\textsc{read}) to
  \ledger{} as \alice{} and given that after \ledger{} replies, control is given
  directly to \simulator{}, the $t$ used during the simulation of \alice's ITI
  is identical to the one that \alice{} would obtain in the real-world
  execution. The rest of the simulation is thus identical with the real-world
  execution, therefore \textsc{fulfillOnChain} does not introduce any
  opportunity for distinghuishability.

  When \environment{} sends (\textsc{poll}) to \alice, the first action is
  sending (\textsc{read}) as \alice{} to \ledger{} both in the ideal
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:read}) and the real
  (Fig.~\ref{alg:protocol:poll}, line~\ref{alg:protocol:poll:read}) worlds.
  Subsequently, in the real world
  lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:submit} of
  Fig.~\ref{alg:protocol:poll} are executed by \alice, whereas in the ideal
  world the functionality compiles a list of closed-but-not-acted-upon channels
  (Fig.~\ref{alg:fpaynet:poll},
  lines~\ref{alg:fpaynet:poll:id}-\ref{alg:fpaynet:poll:malicious}) and then,
  given that the check of line~\ref{alg:fpaynet:poll:badevent} does not lead to
  a bad event (and thus given that the functionality does not halt in
  line~\ref{alg:fpaynet:poll:halt}), a (\textsc{getClosedFunds}) message is sent
  to \simulator. We will prove later that $\fpaynet{}_{\mathrm{, Pay}}$ halts
  here only with negligible probability. Upon receiving
  (\textsc{getClosedFunds}), \simulator{} simulates receiving (\textsc{poll})
  with \alice's ITI (Fig.~\ref{alg:sim:pay}, line~\ref{alg:sim:poll:run}), but
  does not \textsc{read} from \ledger{} and uses instead the $\Sigma_{\alice}$
  provided along with the message. A reasoning identical to that found in the
  previous paragraph shows that this $\Sigma_{\alice}$ is exactly the same as
  that which \alice's ITI would obtain had it executed
  line~\ref{alg:protocol:poll:read} of Fig.~\ref{alg:protocol:poll} and thus the
  simulation of \alice's ITI is identical to what would happen in the same case
  in the real world, up to and including
  line~\ref{alg:protocol:poll:beforesubmit} of Fig.~\ref{alg:protocol:poll}.
  Then (Fig.~\ref{alg:sim:pay},
  lines~\ref{alg:sim:poll:save}-\ref{alg:sim:poll:inform}) \simulator{} prepares
  to inform $\fpaynet{}_{\mathrm{, Pay}}$ which channels are being closed; this
  information will be given to the functionality when \simulator{} learns that
  the closing transactions have become part of $\Sigma_{\alice}$. Finally
  \simulator{} submits to \ledger{} the closing transactions that \alice's
  simulated ITI specified (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:poll:submit}). Since \texttt{toSubmit} is copied from
  \alice's ITI and given the fact that \simulator{} does not yield control of
  the execution after completing \alice's ITI simulation and before sending
  (\textsc{submit}), exactly the same transactions are submitted to \ledger{} as
  those in the real world execution.

  Let $E$ the ``bad'' event in which $\fpaynet{}_{\mathrm{, Pay}}$ executes
  line~\ref{alg:fpaynet:poll:halt} of Fig.~\ref{alg:fpaynet:poll} and halts. We
  will now prove that, during $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
  \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment}$, it is
  $\Pr[E] \leq \negl$. The condition of Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:badevent} is triggered if the delayed output (that
  of the malicious party) of $\mathtt{tx}_1$ has been spent by the transaction
  $\mathtt{tx}_2$ in $\Sigma_{\alice}$ (event $E_1$) and \texttt{polls}(\alice)
  contains an element in $\left[h_1 + k, h_1 + k +
  \mathtt{delay}\left(\alice\right) - 1\right]$, where $h_1$ is the block height
  where $\mathtt{tx}_1$ is (event $E_2$). Observe that $E = E_1 \wedge E_2$. We
  note that the elements in \texttt{polls}(\alice) correspond to the block
  heights of $\Sigma_{\alice}$ at the moments when \alice{} \textsc{poll}s
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:height}). Consider
  the following two events: $E_{1,1}: \mathtt{tx}_2$ spends the delayed output
  with a signature valid by the delayed payment public key after the locktime
  expires. $E_{1,2}: \mathtt{tx}_2$ spends the delayed output with a signature
  valid by the revocation public key $p_{\alice, \mathrm{rev}}$. Note that $E_1
  = E_{1,1} \vee E_{1,2}$ and $E_{1,1}, E_{1,2}$ are mutually exclusive (since
  the same output cannot be spent twice). Observe that, since only \alice{}
  knows the revocation secret key $s_{\alice, \mathrm{rev}}$, forgery of the
  signature required in $E_{1,2}$ can happen only with negligible probability,
  i.e. $\Pr\left[E_{1,2}\right] \leq \negl$. We now concetrate on the event
  $E_{1,1}$. Due to the fact that $\mathtt{tx}_2$ spends an output locked with a
  relative timelock of length $\mathtt{delay}\left(\alice\right) + k +
  \tochain$, the commitment transaction $\mathtt{tx}_1$ can reside in a block
  of maximum height $h_1 \leq h_2 - \mathtt{delay}\left(\alice\right) - k -
  \tochain$, where $h_2$ is the block height where $\mathtt{tx}_2$ is. If
  \alice{} \textsc{poll}s on a moment when $|\Sigma_{\alice}| \geq h_1 + k,
  \Sigma_{\alice}$ necessarily contains $\mathtt{tx}_1$. Furthermore, if
  \alice{} \textsc{poll}s on a moment when $|\Sigma_{\alice}| \leq h_1 + k +
  \mathtt{delay}\left(\alice\right) - 1 \leq h_2 - \tochain{} - 1$, she sees
  $\mathtt{tx}_1$ and directly submits the punishment transaction
  $\mathtt{tx}_3$ (which she has, given that a maliciously closed channel is
  defined as one where the non-closing party has the punishment transaction)
  (Fig.~\ref{alg:protocol:poll:closedch},
  lines~\ref{alg:protocol:poll:mal:tx}-\ref{alg:protocol:poll:mal:submit}).
  Given that $\mathtt{tx}_3$ is broadcast when $|\Sigma_{\alice}| \leq h_2 -
  \tochain{} - 1$, it is guaranteed to be on-chain in a block $h_3 \leq h_2 - 1$
  (according to Proposition~\ref{prop:tochain}). Since $\mathtt{tx}_3$ spends
  the same funds as $\mathtt{tx}_2$, the two cannot be part of the chain
  simultaneously. Since $E_{1,1} \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_2$ and $E_2 \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_3$, $E_{1,1}$ and $E_2$ are mutually exclusive. Therefore
  $\Pr\left[E\right] = \Pr\left[\left(E_{1,1} \vee E_{1,2}\right) \wedge
  E_2\right] = \Pr\left[\left(E_{1,1} \wedge E_2\right) \vee \left(E_{1,2}
  \wedge E_2\right)\right] \leq \Pr\left[E_{1,1} \wedge E_2\right] +
  \Pr\left[E_{1,2} \wedge E_2\right] = \Pr\left[E_{1,2} \wedge E_2\right] \leq
  \Pr\left[E_{1,2}\right] \leq \negl$. We conclude that \textsc{poll} introduces
  only a negligible opportunity for distinghuishability.

  \TODO{prove state - resolvePays, channelsclosed}
\end{proof}
