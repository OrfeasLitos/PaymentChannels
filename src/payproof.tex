\begin{figure}[!htbp]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{toppedUp}, \textsc{openChannel}, \textsc{channelAnnounced},
      \textsc{checkForNew}, \textsc{poll}, \textsc{pay}, \textsc{pushAdd},
      \textsc{pushFulfill}, \textsc{fulfillOnChain} and \textsc{commit}, act
      like \fpaynet{}, but skip lines that call \texttt{checkClosed}().
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[!htbp]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - pay}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving $\left(\textsc{fulfillOnChain}, t, \alice\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \label{alg:sim:pay:foc:top}
      \Indent
        \State execute
        lines~\ref{alg:protocol:pay:foc:tosubmit}-\ref{alg:protocol:pay:foc:submit}
        of Fig.~\ref{alg:protocol:pay:push} as \alice{}, using $t$ from message
        \label{alg:sim:pay:foc:run}
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State add ($\overrightarrow{\mathtt{path}}$, \textit{payid}) to
        \texttt{payids}
        \State strip \textit{payid}, simulate receiving the message with
        \alice{} ITI and further execute the parts of $\Pi_{\mathrm{LN}}$ that
        correspond to honest parties (Fig.~\ref{alg:protocol:pay:outofband}-
        Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \label{alg:sim:pay:simulate}
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until \bob{} processes
        \textsc{updateAddHtlc}} \Comment{payment failed}
          \State add $\left(\bot, \mathit{payid}\right)$ to
          \texttt{charged}(\alice)
          \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid}) from
          \texttt{payids}
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{poll}, $\Sigma_{\alice}$, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:poll},
        lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:submit}
        receiving (\textsc{poll}), using $\Sigma_{\alice}$ from the message,
        with \alice's ITI
        \label{alg:sim:poll:run}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{figure}[!htbp]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - push}
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:end}
        on input (\textsc{pushFulfill}, \textit{pchid}) with \alice's ITI and
        handle subsequent messages by simulating respective ITIs of honest
        players or sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:fulfill}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{pushAdd}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushadd:start}-\ref{alg:protocol:pushadd:end} on
        input (\textsc{pushAdd}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:add}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{commit}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:commit} on input
        (\textsc{commit}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:push:commit}
        \If{during the simulation above, line~\ref{alg:protocol:pay:raa:report}
        of Fig.~\ref{alg:protocol:pay:revokeAndAck} is simulated in \alice's
        ITI}
          \State send (\textsc{update}, \texttt{receipt}, \alice) to
          $\fpaynet{}_{\mathrm{, Pay}}$, where \texttt{receipt} is the receipt
          just added to the simulated \texttt{updatesToReport}
          (Fig.~\ref{alg:protocol:pay:revokeAndAck},
          line~\ref{alg:protocol:pay:raa:report})
          \label{alg:sim:push:report}
          \State upon receiving (\textsc{continue}) from $\fpaynet{}_{\mathrm{,
          Pay}}$, carry on with the simulation
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:push}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - resolve
  payments}
    \begin{algorithmic}[1]
      \State Upon receiving any message with a concatenated (\textsc{state},
      $\Sigma$) part from $\fpaynet{}_{\mathrm{, Pay}}$: \Comment{\textsc{pay},
      \textsc{pushFulfill}, \textsc{pushAdd}, \textsc{commit}}
        \Indent
        \State handle first part of the message normally
        \label{alg:sim:resolvepay:firstmsg}
        \If{at the end of the simulation above, control is still held by
        $\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$}
        \label{alg:sim:resolvepay:mayberesolve}
          \ForAll{$\Sigma_{\alice} \in \Sigma$}
          \label{alg:sim:resolvepay:everystate}
            \ForAll{$(\overrightarrow{\mathtt{path}}, \mathit{payid}) \in
            \mathtt{payids} : \alice \in \overrightarrow{\mathtt{path}}$}
              \If{\alice{} sent \textsc{updateFulfillHtlc} to a corrupted player
              and either (got the fulfillment of the HTLC irrevocably committed
              OR fulfilled the HTLC on-chain (i.e. \texttt{HTLC-success} is in
              $\Sigma_{\alice}$)), AND the next honest player \bob{} down the
              line successfully timed out the HTLC on-chain (i.e.
              \texttt{HTLC-timeout} is in $\Sigma_{\bob}$)} \Comment{no or bad
              communication with \bob's previous player}
              \label{alg:sim:resolvepay:corrupted}
                \State add to \texttt{charged}(\alice) a tuple
                (\texttt{corrupted}, \textit{payid}) where \texttt{corrupted} is
                set to one of the corrupted parties between \alice{} and \bob{}
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \ElsIf{$\Sigma_{\alice}$ contains an old $\mathtt{remoteCom}_m$ of
              the channel before \alice{} (closer to payer) on the
              $\overrightarrow{\mathtt{path}}$ that does not contain the
              relevant HTLC and a tx that spends the delayed output of
              $\mathtt{remoteCom}_m \vee$ (($\Sigma_{\alice}$ contains the most
              recent $\mathtt{remoteCom}_n$ or $\mathtt{localCom}_n$ of the
              channel before \alice{} and the \texttt{HTLC-success} of the
              relevant HTLC $\vee$ \alice's latest irrevocably committed
              $\mathtt{remoteCom}_n$ for the channel before \alice{} does not
              contain the HTLC) $\wedge \Sigma_{\alice}$ contains the most
              recent $\mathtt{remoteCom}_l$ or $\mathtt{localCom}_l$ and (the
              \texttt{HTLC-timeout} or an \texttt{HTLC-success} that pays the
              counterparty) for HTLC of the channel after \alice{})}
              \Comment{\alice{} did not fulfill in time}
              \label{alg:sim:resolvepay:negligent}
                \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \ElsIf{\alice{} is the payer in $\overrightarrow{\mathtt{path}}$
              AND ((she has received \textsc{updateFulfillHtlc} AND has
              subsequently sent \textsc{commit} and \textsc{revokeAndAck}) OR
              player after \alice{} has irrevocably fulfilled the HTLC on-chain
              (i.e. his \texttt{HTLC-success} is in $\Sigma_{\alice}$)}
              \Comment{honest payment completed}
              \label{alg:sim:resolvepay:honest}
                \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
                \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
                from \texttt{payids}
              \EndIf
            \EndFor
          \EndFor
          \label{alg:sim:resolvepay:loopend}
        \EndIf
        \State clear \texttt{charged} and send $\left(\textsc{resolvePays},
        \mathtt{charged}\right)$ to $\fpaynet{}_{\mathrm{, Pay}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  \begin{gather*}
    \forall k \in \mathbb{N}, \text{ PPT } \environment, \\
    |\Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open}}, \environment} = 1] -
    \Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment} = 1]|
    \leq \\
    nm \cdot \mathrm{E \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) +
    \\
    nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm
    \cdot \mathrm{E \mhyphen master}(k) \enspace.
  \end{gather*}
\end{lemma}

\begin{proof}
  Before focusing on individual messages sent by \environment, we will first
  prove that four particular forgery events happen with negligible probability.
  Let $P$ be the event in which at some point during the execution a transaction
  that has the following two characteristics appears in $\Sigma_{\alice}$, for
  some honest player \alice: it spends a funding transaction of a channel that
  contains \alice{} (and thus has a $p_{\alice, F}$ public key) and it was never
  signed by \alice. Suppose that $m$ is the maximum number of channels that a
  player can open and $\exists \text{ PPT } \environment_P: \Pr[P] = a$. We show
  in Proposition~\ref{prop:forgery:ds} that $\forall \environment, \Pr[P] \leq
  nm \cdot \mathrm{E \mhyphen ds}(k)$.

  Let $Q$ be the event in which at some point during the execution a transaction
  that has the following two characteristics appears in $\Sigma_{\alice}$, for
  some honest player \alice: it spends a simple output, delayed output or htlc
  output tied with a public key that was created by \alice{} ($p_{\alice,
  \mathrm{pay}, n}, p_{\alice, \mathrm{dpay}, n}, p_{\alice, \mathrm{htlc}, n}$
  respectively) and it was never signed by \alice. Suppose that $p$ is the
  maximum total number of opens and updates that a player can perform and that
  $\exists \text{ PPT } \environment_Q: \Pr[Q] = b$. We show
  in Proposition~\ref{prop:forgery:ibs} that $\forall \environment, \Pr[Q] \leq
  3np \cdot \mathrm{E \mhyphen ibs}(k)$.

  Let $R$ be the event in which at some point during the execution a transaction
  that has the following characteristic appears in $\Sigma_{\alice}$, for some
  honest player \alice: it spends the revocation output of a local (for
  \alice{}) commitment transaction for a channel that contains \alice{} and
  \bob{} (and thus has a $p_{\bob, \mathrm{rev}, n}$ key). Observe that, since
  \alice{} is honest and according to both the real and the ideal execution, if
  \alice{} submits her local commitment transaction $\mathtt{localCom}_n$ to the
  ledger, under no circumstances does she subsequently go on to send $s_{\alice,
  \mathrm{com}, n}$ to any party. (This secret information could be used by
  \bob{} to efficiently compute $s_{\bob, \mathrm{rev}, n}$ with
  \textsc{CombineKey}($pb_{\bob, \mathrm{rev}}, sb_{\bob, \mathrm{rev}},
  p_{\alice, \mathrm{com}, n}, s_{\alice, \mathrm{com}, n}$).) Suppose that $p$
  is the maximum total number of opens and updates that a player can perform,
  $m$ is the maximum number of opens a player can perform and $\exists \text{
  PPT } \environment_R: Pr[R] = c$. We show in
  Proposition~\ref{prop:forgery:share} that $\forall \environment, \Pr[R] \leq
  nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k)$.

  Lastly, let $S$ be the event in which at some point during the execution a
  transaction that has the following two characteristics appears in
  $\Sigma_{\alice}$, for some honest player \alice: (a) it spends the revocation
  output of a remote (for \alice{}) commitment transaction for a channel that
  contains \alice{} (and thus has a $p_{\alice, \mathrm{rev}, n}$ key) and (b)
  it was never signed by \alice. Observe that, since \alice{} is honest, she has
  never sent $s_{\alice, \mathrm{rev}, n}$ to any party. Suppose that $m$ is the
  maximum total number of opens and updates that a player can perform and that
  $\exists \text{ PPT } \environment_S: \Pr[S] = d$. We show in
  Proposition~\ref{prop:forgery:master} that $\forall \environment, \Pr[S] \leq
  nm \cdot \mathrm{E \mhyphen master}(k)$.

  We can now move on to treating individual messages sent by \environment{}
  during the execution. When \environment{} sends $\left(\textsc{pay}, \bob, x,
  \overrightarrow{\mathtt{path}}, \mathit{payid}\right)$ to \alice{} in the
  ideal world, $\simulator_{\mathrm{LN - Reg - Open}}$ is always notified
  (Fig.~\ref{alg:fpaynet:pay}, line~\ref{alg:fpaynet:pay:send}) and simulates
  the relevant execution of the real world (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:pay:simulate}). No messages to \ledger{} or \environment{}
  that differ from the real world are generated in the process. At the end of
  this simulation, no further messages are sent (and the control returns to
  \environment). Therefore, when \environment{} sends \textsc{pay}, no
  opportunity for distinguishability arises.

  When \environment{} sends any message of (\textsc{pushAdd}, \textit{pchid}),
  (\textsc{pushFulfill}, \textit{pchid}), (\textsc{commit}, \textit{pchid}) to
  \alice{} in the ideal world, it is forwarded to $\simulator_{\mathrm{LN - Reg
  - Open}}$ (Fig.~\ref{alg:fpaynet:daemon},
  lines~\ref{alg:fpaynet:daemon:fulfill},~\ref{alg:fpaynet:daemon:add},~\ref{alg:fpaynet:daemon:commit}
  respectively), who in turn simulates \alice's real-world execution with her
  simulated ITI and the handling of any subsequent messages sent by \alice's ITI
  (Fig.~\ref{alg:sim:push},
  lines~\ref{alg:sim:push:fulfill},~\ref{alg:sim:push:add},~\ref{alg:sim:push:commit}).
  Neither $\fpaynet{}_{\mathrm{, Pay}}$ nor $\simulator_{\mathrm{LN - Reg -
  Open}}$ alter their state as a result of these messages, apart from the state
  of \alice's simulated ITI and the state of other simulated ITIs that receive
  and handle messages that were sent as a result of \alice's ITI simulation. The
  states of these ITIs are modified in the exact same way as they would in the
  real world. We deduce that these three messages do not introduce any
  opportunity for \environment{} to distinguish the real and the ideal world.

  When \environment{} sends (\textsc{fulfillOnChain}) to \alice{} in the real
  world, lines~\ref{alg:protocol:pay:foc:top}-\ref{alg:protocol:pay:foc:submit}
  of Fig.~\ref{alg:protocol:pay:push} are executed by \alice. In the ideal world
  on the other hand, $\fpaynet{}_{\mathrm{, Pay}}$ sends (\textsc{read}) to
  \ledger{} (Fig.~\ref{alg:fpaynet:daemon},
  line~\ref{alg:fpaynet:daemon:foc:read}) as \alice{} and subsequently instructs
  $\simulator_{\mathrm{LN - Reg - Open}}$ to simulate the receiving of
  (\textsc{fulfillOnChain}) with \alice{}'s ITI (Fig.~\ref{alg:sim:pay},
  lines~\ref{alg:sim:pay:foc:top}-\ref{alg:sim:pay:foc:run}). Observe that
  during this simulation a second (\textsc{read}) message to \ledger{} (that
  would not match any message in the real world) is avoided because
  $\simulator_{\mathrm{LN - Reg - Open}}$ skips
  line~\ref{alg:protocol:pay:foc:read} of Fig.~\ref{alg:protocol:pay:push},
  using as $t$ the one received from $\fpaynet{}_{\mathrm{, Pay}}$ in the
  message (\textsc{fulfillOnChain}, $t$, \alice). Since $\fpaynet{}_{\mathrm{,
  Pay}}$ sends (\textsc{read}) to \ledger{} as \alice{} and given that after
  \ledger{} replies, control is given directly to $\simulator_{\mathrm{LN - Reg
  - Open}}$, the $t$ used during the simulation of \alice's ITI is identical to
  the one that \alice{} would obtain in the real-world execution. The rest of
  the simulation is thus identical with the real-world execution, therefore
  \textsc{fulfillOnChain} does not introduce any opportunity for
  distinghuishability.

  When \environment{} sends (\textsc{poll}) to \alice, the first action is
  sending (\textsc{read}) as \alice{} to \ledger{} both in the ideal
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:read}) and the real
  (Fig.~\ref{alg:protocol:poll}, line~\ref{alg:protocol:poll:read}) worlds.
  Subsequently, in the real world
  lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:submit} of
  Fig.~\ref{alg:protocol:poll} are executed by \alice, whereas in the ideal
  world, given that the checks of lines~\ref{alg:fpaynet:poll:haspolled}
  and~\ref{alg:fpaynet:poll:ifdsforgery} do not lead to a bad event (and thus
  given that the functionality does not halt in
  lines~\ref{alg:fpaynet:poll:haspolled:halt}
  or~\ref{alg:fpaynet:poll:dsforgery}), a (\textsc{poll}) message is sent to
  $\simulator_{\mathrm{LN - Reg - Open}}$. We will prove later that
  $\fpaynet{}_{\mathrm{, Pay}}$ does not halt here. Upon receiving
  (\textsc{poll}), $\simulator_{\mathrm{LN - Reg - Open}}$ simulates receiving
  (\textsc{poll}) with \alice's ITI (Fig.~\ref{alg:sim:pay},
  line~\ref{alg:sim:poll:run}), but does not \textsc{read} from \ledger{} and
  uses instead the $\Sigma_{\alice}$ provided along with the message. A
  reasoning identical to that found in the previous paragraph shows that this
  $\Sigma_{\alice}$ is exactly the same as that which \alice's ITI would obtain
  had it executed line~\ref{alg:protocol:poll:read} of
  Fig.~\ref{alg:protocol:poll} and thus the simulation of \alice's ITI is
  identical to what would happen in the same case in the real world, up to and
  including line~\ref{alg:protocol:poll:submit} of Fig.~\ref{alg:protocol:poll}.

  The event $E$ in which $\fpaynet{}_{\mathrm{, Pay}}$ executes
  line~\ref{alg:fpaynet:poll:dsforgery} of Fig.~\ref{alg:fpaynet:poll} and
  halts can only happen if there is a non-commitment transaction that contains a
  valid signature by the $p_{\alice, F}$ key that is needed to spend the funding
  transaction of an open channel. According to $\Pi_{LN}$, \alice{} signs with
  her $s_{\alice, F}$ key only commitment transactions. Therefore $E \subset P
  \Rightarrow \Pr[E | \neg P] = 0$.

  Let $E'$ the ``bad'' event in which $\fpaynet{}_{\mathrm{, Pay}}$ executes
  line~\ref{alg:fpaynet:poll:haspolled:halt} of Fig.~\ref{alg:fpaynet:poll} and
  halts. We will now prove that, during $\textsc{Exec}^{\fpaynet{}_{\mathrm{,
  Pay}}, \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment}$,
  it is $\Pr[E | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$. The
  condition of Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:haspolled} is triggered if the delayed output (that
  of the malicious party) of $\mathtt{tx}_1$ has been spent by the transaction
  $\mathtt{tx}_2$ in $\Sigma_{\alice}$ (event $E'_1$) and \texttt{polls}(\alice)
  contains an element in $\left[h_1, h_1 + \mathtt{delay}\left(\alice\right) -
  1\right]$, where $h_1$ is the block height where $\mathtt{tx}_1$ is (event
  $E'_2$). Observe that $E' = E'_1 \wedge E'_2$. We note that the elements in
  \texttt{polls}(\alice) correspond to the block heights of $\Sigma_{\alice}$ at
  the moments when \alice{} \textsc{poll}s (Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:height}). Consider the following two events:
  $E'_{1,1}: \mathtt{tx}_2$ spends the delayed output with a signature valid by
  the delayed payment public key after the locktime expires. $E'_{1,2}:
  \mathtt{tx}_2$ spends the delayed output with a signature valid by the
  revocation public key $p_{\alice, \mathrm{rev}}$. Note that $E'_1 = E'_{1,1}
  \vee E'_{1,2}$ and $E'_{1,1}, E'_{1,2}$ are mutually exclusive (since the same
  output cannot be spent twice). Observe that $E'_{1,2} \subset S$, thus
  $\Pr\left[E'_{1,2} | \neg S\right] = 0$. We now concetrate on the event
  $E'_{1,1}$. Due to the fact that $\mathtt{tx}_2$ spends an output locked with
  a relative timelock of length $\mathtt{delay}\left(\alice\right) + \tochain$,
  the commitment transaction $\mathtt{tx}_1$ can reside in a block of maximum
  height $h_1 \leq h_2 - \mathtt{delay}\left(\alice\right) - \tochain$, where
  $h_2$ is the block height where $\mathtt{tx}_2$ is. If \alice{} \textsc{poll}s
  on a moment when $|\Sigma_{\alice}| \geq h_1, \Sigma_{\alice}$ necessarily
  contains $\mathtt{tx}_1$. Furthermore, if \alice{} \textsc{poll}s on a moment
  when $|\Sigma_{\alice}| \leq h_1 + \mathtt{delay}\left(\alice\right) - 1 \leq
  h_2 - \tochain{} - 1$, she sees $\mathtt{tx}_1$ and directly submits the
  punishment transaction $\mathtt{tx}_3$ (which she has, given that a
  maliciously closed channel is defined as one where the non-closing party has
  the punishment transaction) (Fig.~\ref{alg:protocol:poll:closedch},
  lines~\ref{alg:protocol:poll:mal:tx}-\ref{alg:protocol:poll:mal:submit}).
  Given that $\mathtt{tx}_3$ is broadcast when $|\Sigma_{\alice}| \leq h_2 -
  \tochain{}$, it is guaranteed to be on-chain in a block $h_3 \leq h_2$
  (according to Proposition~\ref{prop:tochain}). Since $\mathtt{tx}_3$ spends
  the same funds as $\mathtt{tx}_2$, the two cannot be part of the chain
  simultaneously. Since $E'_{1,1} \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_2$ and $E'_2 \Rightarrow \Sigma_{\alice}$ contains
  $\mathtt{tx}_3$, $E'_{1,1}$ and $E'_2$ are mutually exclusive. Therefore,
  assuming $\neg P \wedge \neg Q \wedge \neg R \wedge \neg S$, it is
  $\Pr\left[E'\right] = \Pr\left[\left(E'_{1,1} \vee E'_{1,2}\right) \wedge
  E'_2\right] = \Pr\left[\left(E'_{1,1} \wedge E'_2\right) \vee \left(E'_{1,2}
  \wedge E'_2\right)\right] \leq \Pr\left[E'_{1,1} \wedge E'_2\right] +
  \Pr\left[E'_{1,2} \wedge E'_2\right] = \Pr$ $\left[ E'_{1,2} \wedge
  E'_2\right] \leq \Pr\left[E'_{1,2}\right] = 0$. We conclude that, given $\neg
  P \wedge \neg Q \wedge \neg R \wedge \neg S$ \textsc{poll} introduces no
  opportunity for distinghuishability.

  We now treat the effects of the (\textsc{state}, $\Sigma$) message that
  $\fpaynet{}_{\mathrm{, Pay}}$ sends to $\simulator_{\mathrm{LN - Reg -
  Open}}$, appended to \textsc{pay}, \textsc{pushFulfill}, \textsc{pushAdd} and
  \textsc{commit} messages. We first observe that the (\textsc{state}) message
  is handled after handling the first message (which is of one of the four
  aforementioned types) (Fig.~\ref{alg:sim:resolvepay},
  line~\ref{alg:sim:resolvepay:firstmsg}). It may be the case that at the end of
  the handling of line~\ref{alg:sim:resolvepay:firstmsg},
  $\simulator_{\mathrm{LN - Reg - Open}}$ does not have control of the
  execution. That can happen if a simulated ITI sends a message to a corrupted
  player and that player does not respond (e.g. in
  Fig.~\ref{alg:protocol:pay:outofband},
  line~\ref{alg:protocol:pay:sendinvoice}, when the first message is
  $\left(\textsc{pay}, \bob, x, \overrightarrow{\mathtt{path}}\right)$ and
  \bob{} is corrupted), or if the handling of the message results in sending
  (\textsc{submit}) to \ledger{} (e.g. in Fig.~\ref{alg:protocol:pay:push},
  line~\ref{alg:protocol:pushfulfill:submit} when the first message is
  (\textsc{pushFulfill}, \textit{pchid}) and counterparty has gone on-chain). In
  that case, the (\textsc{state}) message is simply ignored
  (Fig.~\ref{alg:sim:resolvepay}, line~\ref{alg:sim:resolvepay:mayberesolve})
  and does not influence execution in any way.

  In the case when $\left(\textsc{state}, \Sigma\right)$ is handled,
  $\simulator_{\mathrm{LN - Reg - Open}}$ attempts to specify who was charged
  for each pending payment, based on the information that the potentially paying
  party sees in its view of the \ledger{} state (Fig.~\ref{alg:sim:resolvepay},
  lines~\ref{alg:sim:resolvepay:everystate}-\ref{alg:sim:resolvepay:loopend}).
  The resolution is then sent to $\fpaynet{}_{\mathrm{, Pay}}$ with the message
  (\textsc{resolvePays}, \texttt{charged}). $\fpaynet{}_{\mathrm{, Pay}}$
  handles this message in Fig.~\ref{alg:fpaynet:resolvepay}
  and~\ref{alg:fpaynet:resolvepay:loops}, where, if it does not halt
  (Fig.~\ref{alg:fpaynet:resolvepay},
  lines~\ref{alg:fpaynet:resolvepay:halt:ds},~\ref{alg:fpaynet:resolvepay:halt:rel}
  and~\ref{alg:fpaynet:resolvepay:halt:abs} and
  Fig.~\ref{alg:fpaynet:resolvepay:loops},
  line~\ref{alg:fpaynet:resolvepay:loops:halt:do}), it updates the state of each
  affected channel (Fig.~\ref{alg:fpaynet:resolvepay:loops},
  line~\ref{alg:fpaynet:resolvepay:loops:update:do}) and does not send any
  message, thus control returns to \environment. We will prove that, under $\neg
  P \wedge \neg Q \wedge \neg R \wedge \neg S$, $\fpaynet{}_{\mathrm{, Pay}}$
  does not halt and thus conclude that the handling of a (\textsc{state})
  message does not introduce opportunity for distinguishability.

  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:ds} of
  Fig.~\ref{alg:fpaynet:resolvepay} if the honest player \dave{} was charged for
  a payment over a channel that was closed without using a commitment
  transaction. Like $E$, this event is a subset of $P$, thus cannot happen given
  $\neg P$.

  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:rel} of
  Fig.~\ref{alg:fpaynet:resolvepay} if the player \dave{} charged is an honest
  member of the payment path, has \textsc{poll}ed in time to catch a malicious
  closure (event $A$) but a malicious closure succeeded (event $B$).
  $\fpaynet{}_{\mathrm{, Pay}}$ halts in
  line~\ref{alg:fpaynet:resolvepay:halt:abs} of
  Fig.~\ref{alg:fpaynet:resolvepay} if \dave{} is not the payer, no malicious
  closure succeeded ($\neg B$) and \dave{} has \textsc{poll}ed in time twice to
  learn the preimage of the HTLC early enough (event $C$) and has attempted to
  fulfill on chain at the right moment (event $D$). $\fpaynet{}_{\mathrm{,
  Pay}}$ also halts if the two expiries do not have the expected distance (event
  $F$) -- i.e. halts in the event $(A \wedge B) \vee (\neg B \wedge (F \vee (C
  \wedge D)))$. $\simulator_{\mathrm{LN - Reg - Open}}$ decides that \dave{} is
  charged if his previous counterparty did a malicious closure to a channel
  version without the HTLC and spent their (delayed) output ($B$), or if his
  next counterparty fulfilled (event $G$) and his previous counterparty timed
  out the HTLC (event $H$) (Fig.~\ref{alg:sim:resolvepay},
  line~\ref{alg:sim:resolvepay:negligent}), -- i.e. \dave{} is charged in the
  event $B \vee (G \wedge H)$.

  We will now show that $\Pr[A \wedge B | \neg P \wedge \neg Q \wedge \neg R
  \wedge \neg S] = 0 \wedge \Pr[(C \wedge D) \wedge (G \wedge H) | \neg P \wedge
  \neg Q \wedge \neg R \wedge \neg S] = 0 \wedge \Pr[F \wedge (G \wedge H) |
  \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$, from which we can
  deduce that $\Pr[(A \wedge B) \vee ((F \vee (C \wedge D)) \wedge (G \wedge H))
  | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$ and thus $\Pr[((A
  \wedge B) \vee (\neg B \wedge (F \vee (C \wedge D)))) \wedge (B \vee (G \wedge
  H)) | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$. This last step
  holds because $(A \wedge B) \vee ((F \vee (C \wedge D)) \wedge (G \wedge H)) =
  (A \wedge B) \vee ((F \vee (C \wedge D) \wedge G \wedge H)$ and $((A \wedge B)
  \vee (\neg B \wedge (F \vee (C \wedge D)))) \wedge (B \vee (G \wedge H)) = (A
  \wedge B) \vee (\neg B \wedge (F \vee (C \wedge D)) \wedge G \wedge H)$ and
  the latter is a subset of the former.

  The analysis of the event $A \wedge B$ is identical to the one we did
  previously for the events $E'_1, E'_2$, with $A$ corresponding to $E'_2$ and
  $B$ to $E'_1$. We thus deduce that $\Pr[A \wedge B | \neg P \wedge \neg Q
  \wedge \neg R \wedge \neg S] = 0$.

  Event $F$ is true only if $\mathtt{IncomingCltvExpiry} -
  \mathtt{OutgoingCltvExpiry} < \mathtt{relayDelay}(\alice) + \tochain$. This
  cannot happen however for any honest \alice, since \simulator{} will simulate
  line~\ref{alg:protocol:pay:updateAddHtlc:slack} of
  Fig.\ref{alg:protocol:pay:updateAddHtlc:checks} with \alice's ITI before
  having her agree to participate as an intermediary in the multi-hop payment.
  Therefore $\Pr[F \wedge (G \wedge H) | \neg P \wedge \neg Q \wedge \neg R
  \wedge \neg S] = 0$.

  The only way for event $C$ to be true is if \environment{} sends
  (\textsc{poll}) to \dave{} during the prescribed time period
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:height}) -- note that
  the addition to \texttt{polls}(\dave) during registration
  (Fig.~\ref{alg:fpaynet:support}, line~\ref{alg:fpaynet:support:lastpoll})
  cannot be within the desired range due to the fact that
  \texttt{OutgoingCltvExpiry} is not smaller than the chain height when the
  corresponding (\textsc{invoice}) was received
  (Fig.~\ref{alg:protocol:pay:invoice},
  line~\ref{alg:protocol:pay:invoice:cltv}), registration happens necessarily
  before handling (\textsc{invoice}) (Fig.~\ref{alg:fpaynet:support},
  line~\ref{alg:fpaynet:support:unreg}) and the element added to
  \texttt{polls}(\dave) at registration is the chain height at that time
  (Fig.~\ref{alg:fpaynet:support}, line~\ref{alg:fpaynet:support:lastpoll}).
  When \dave{} receives (\textsc{poll}), $\fpaynet{}_{\mathrm{, Pay}}$ always
  sends (\textsc{getClosedFunds}) to $\simulator_{\mathrm{LN - Reg - Open}}$
  (Fig.~\ref{alg:fpaynet:poll}, line~\ref{alg:fpaynet:poll:send}) (since, as we
  saw earlier, $\fpaynet{}_{\mathrm{, Pay}}$ never halts).

  Event $H$ happens only when the previous counterparty successfully appends
  \texttt{HTLC-timeout} to $\Sigma_{\dave}$, which is a valid transaction only
  from the block of height $\mathtt{IncomingCltvExpiry} + 1$ and on, or if the
  previous counterparty learns the preimage of the HTLC and forges a signature
  valid by \dave's public HTLC key, or if the previous counterparty forges a
  signature valid by \dave's public revocation key; the two latter scenarios can
  never happen. Thus, given that $G$ happens until a moment when
  $|\Sigma_{\dave}| \leq \mathtt{IncomingCltvExpiry} - \tochain{}$, \dave{} has
  the time to successfully fulfill the HTLC. Given $C$, \dave{} has
  \textsc{poll}ed at two moments $h_1, h_2 \in$ [\texttt{OutgoingCltvExpiry},
  \texttt{IncomingCltvExpiry} - (2 + $r$)\texttt{windowSize}], such that $h_2
  \geq h_1 + \tochain{}$. If $\Sigma_{\dave}$ contains the preimage at moment
  $h_1$ or $h_2$, then \dave{} may try to update the previous channel off-chain
  if he receives a (\textsc{pushFulfill}) for that channel
  (Fig.~\ref{alg:protocol:pay:push},
  lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:submit}),
  and if the off-chain update is never attempted (because (\textsc{pushFulfill})
  and (\textsc{commit}) are not received) or fails (because the previous
  counterparty does not send (\textsc{revokeAndAck})), then the
  (\textsc{fulfillOnChain}) that he receives according to $D$ will make him
  submit \texttt{HTLC-success} (Fig.~\ref{alg:protocol:pay:push},
  lines~\ref{alg:protocol:pay:foc:top}-\ref{alg:protocol:pay:foc:submit}) and
  have it on-chain by block of height \texttt{IncomingCltvExpiry}
  (Proposition~\ref{prop:tochain}). Furthermore, in the case that the
  \texttt{HTLC-success} is not found at the (\textsc{poll}) of $h_1$, \dave{}
  immediately submits \texttt{HTLC-timeout}
  (Fig.~\ref{alg:protocol:poll:closedch},
  line~\ref{alg:protocol:poll:htlc:submit}), which either ends up in
  $\Sigma_{\dave}$ by block height $h_1 + \tochain{}$
  (Proposition~\ref{prop:tochain}) or is rejected because the counterparty
  managed to append \texttt{HTLC-success} before it. In the first case, \dave{}
  is not charged for the payment. In the second case, the second (\textsc{poll})
  (at block height $h_2$) necessarily reveals the \texttt{HTLC-success} to
  \dave{} and subsequently the (\textsc{fulfillOnChain}) causes \dave{} to
  fulfill the HTLC with the previous counterparty, as argued above. Therefore in
  no case \dave{} is charged for the payment, i.e. $\Pr[(C \wedge D) \wedge (G
  \wedge H) | \neg P \wedge \neg Q \wedge \neg R \wedge \neg S] = 0$.

  It remains to be proven that the halt of
  line~\ref{alg:fpaynet:resolvepay:loops:halt:do} in
  Fig.~\ref{alg:fpaynet:resolvepay:loops} does not occur with non-negligible
  probability. Indeed, \simulator{} only reports the payment as resolved in
  \textsc{resolvePays} if a party has been irrevocably charged for it
  (Fig.~\ref{alg:sim:resolvepay},
  lines~\ref{alg:sim:resolvepay:corrupted},~\ref{alg:sim:resolvepay:negligent},
  or~\ref{alg:sim:resolvepay:honest}). In all three cases, all channels that
  follow the \texttt{charged} party on the $\overrightarrow{\mathtt{path}}$ have
  either been closed or irrevocably updated to a newer version that includes the
  new balance. Since \fpaynet{} may only halt for a \texttt{channel} that has
  not been declared or confirmed as closed
  (Fig.~\ref{alg:fpaynet:resolvepay:loops},
  lines~\ref{alg:fpaynet:resolvepay:loops:update:loop}
  and~\ref{alg:fpaynet:resolvepay:loops:halt:loop}), all channels that can cause
  a halt are channels that have the update of this payment irrevocably
  committed. This only happens when both sides send a \textsc{revokeAndAck} that
  updates the channel from a version that contains the relevant HTLC to a
  version that doesn't; and when an honest party receives such a
  \textsc{revokeAndAck} message, it logs the update in \texttt{updatesToReport}
  (Fig.~\ref{alg:protocol:pay:revokeAndAck},
  line~\ref{alg:protocol:pay:raa:report}) which causes \simulator{} to report
  the update to \fpaynet{} (Fig.~\ref{alg:sim:push},
  line~\ref{alg:sim:push:report}). We therefore conclude that \fpaynet{} never
  halts on line~\ref{alg:fpaynet:resolvepay:loops:halt:do} of
  Fig.~\ref{alg:fpaynet:resolvepay:loops}.

  To conclude, given $\neg P \wedge \neg Q \wedge \neg R \wedge \neg S$, it is
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open}}, \environment} = \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
  \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment}$. If we
  allow for forgeries again, i.e. if we allow the event $P \vee Q \vee R \vee
  S$, we observe that $\Pr[P \vee Q \vee R \vee S] \leq nm \cdot \mathrm{E
  \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) + nmp \cdot \mathrm{E
  \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm \cdot \mathrm{E \mhyphen
  master}(k)$, where $n$ is the number of players, $m$ is the maximum channels a
  player can open and $p$ is the maximum number of updates a player can perform.
  We thus deduce that
  \begin{gather*}
    \forall k \in \mathbb{N}, \text{ PPT } \environment, \\
    |\Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open}}, \environment} = 1] -
    \Pr[\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}},
    \ledger}_{\simulator_{\mathrm{LN - Reg - Open - Pay}}, \environment} = 1]|
    \leq \\
    nm \cdot \mathrm{E \mhyphen ds}(k) + 3np \cdot \mathrm{E \mhyphen ibs}(k) +
    \\
    nmp \cdot \mathrm{E \mhyphen share}(k) + \mathrm{E \mhyphen prf}(k) + nm
    \cdot \mathrm{E \mhyphen master}(k) \enspace.
  \end{gather*}
\end{proof}
