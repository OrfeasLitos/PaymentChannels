\begin{figure}[H]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{pay}, \textsc{push} and \textsc{commit}, act
      like \fpaynet{}.
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      from $\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$:
      \Indent
        \State strip \textit{payid}, simulate receiving the message with
        \alice{} ITI and further execute the parts of $\Pi_{\mathrm{LN}}$ that
        correspond to honest parties (Fig.~\ref{alg:protocol:pay:invoice}-
        Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until receiver processes
        \textsc{updateAddHtlc} OR any added HTLC on the path times out before it
        is committed} \Comment{payment failed}
          \State $\mathtt{charged} = \bot$
        \ElsIf{An honest player that sent \textsc{updateFulfillHtlc} to a
        corrupted player gets the fulfillment of the HTLC irrevocably committed,
        but the next honest player down the line successfully times out the HTLC
        on-chain (due to no or bad communication from the corrupted player) OR
        An honest player fails to irrevocably commit the fulfillment of the HTLC
        (due to no or bad communication from the corrupted counterparty) and
        successfully fulfills on-chain, but the next honest player down the line
        successfully times out the HTLC on-chain}
          \State $\mathtt{charged} = \adversary$
        \ElsIf{player before \charlie{} (closer to payer) goes on-chain with an
        older version (that doesn't contain the HTLC) and \charlie{} doesn't
        \textsc{poll} in time to revoke (is negligent) OR player after
        \charlie{} (closer to receiver) fulfills the HTLC on-chain and
        \charlie{} doesn't \textsc{poll} in time to learn preimage and send
        \textsc{updateFulfillHtlc} (is relay-negligent)}
          \State $\mathtt{charged} = \charlie$
        \Else
          \State $\mathtt{charged} = \alice$
        \EndIf
        \State send $\left(\textsc{resolvePay}, \mathit{payid},
        \mathtt{charged}\right)$ to $\simulator{}_{\mathrm{LN - Reg - Open -
        Pay}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}},
  \ledger}_{\simulator_{\mathrm{LN - Reg - Open}}, \environment} =
  \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open - Pay}}, \environment}$
\end{lemma}

\begin{proof}
\end{proof}
