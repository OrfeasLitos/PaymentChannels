\begin{figure}[H]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{registered}, \textsc{openChannel}, \textsc{channelAnnounced},
      \textsc{checkNew}, \textsc{poll}, \textsc{pay}, \textsc{pushAdd},
      \textsc{pushFulfill}, \textsc{fulfillOnChain} and \textsc{commit}, act
      like \fpaynet{}.
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - pay}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving $\left(\textsc{fulfillOnChain}, t, \alice\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \label{alg:sim:pay:foc:top}
      \Indent
        \State execute
        lines~\ref{alg:protocol:pay:foc:tosubmit}-\ref{alg:protocol:pay:foc:submit}
        of Fig.~\ref{alg:protocol:pay:push} as \alice{}, using $t$ from message
        \label{alg:sim:pay:foc:run}
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State strip \textit{payid}, simulate receiving the message with
        \alice{} ITI and further execute the parts of $\Pi_{\mathrm{LN}}$ that
        correspond to honest parties (Fig.~\ref{alg:protocol:pay:invoice}-
        Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \label{alg:sim:pay:simulate}
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until receiver processes
        \textsc{updateAddHtlc}} \Comment{payment failed}
          \State add $\left(\bot, \mathit{payid}\right)$ to
          \texttt{charged}(\alice)
        \Else
          \State add ($\overrightarrow{\mathtt{path}}$, \textit{payid}) to
          \texttt{payids}
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{getClosedFunds}, \texttt{toReport},
      $\Sigma_{\alice}$, \alice, \textit{reportid}) from $\fpaynet{}_{\mathrm{,
      Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:poll},
        lines~\ref{alg:protocol:poll:afterread}-\ref{alg:protocol:poll:beforesubmit}
        on input (\textsc{poll}), using $\Sigma_{\alice}$ from the message, with
        \alice's ITI
        \State add all channels in \texttt{toSubmit} to \texttt{details}(\alice)
        \State The first time we receive a message from $\fpaynet{}_{\mathrm{,
        Pay}}$ that contains $\Sigma_{\alice}$ that is at least $k$ blocks
        longer than the current one, concatenate (\textsc{channelsClosed},
        \texttt{details}(\alice), \texttt{reportid}) to the first subsequent
        message to $\fpaynet{}_{\mathrm{, Pay}}$ and clear
        \texttt{details}(\alice)
        \State send (\textsc{submit}, \texttt{toSubmit}) to \ledger{} as \alice
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushfulfill:start}-\ref{alg:protocol:pushfulfill:end}
        on input (\textsc{pushFulfill}, \textit{pchid}) with \alice's ITI and
        handle subsequent messages by simulating respective ITIs of honest
        players or sending to \adversary{} the messages for corrupted players
        \label{alg:sim:pay:fulfill}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{pushAdd}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:push},
        lines~\ref{alg:protocol:pushadd:start}-\ref{alg:protocol:pushadd:end} on
        input (\textsc{pushAdd}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:pay:add}
      \EndIndent
      \Statex

      \State Upon receiving (\textsc{commit}, \textit{pchid}, \alice) from
      $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:pay:commit} on input
        (\textsc{commit}, \textit{pchid}) with \alice's ITI and handle
        subsequent messages by simulating respective ITIs of honest players or
        sending to \adversary{} the messages for corrupted players
        \label{alg:sim:pay:commit}
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$ - resolve
  payments}
    \begin{algorithmic}[1]
      \State Upon receiving any message with a concatenated (\textsc{state},
      $\Sigma$) part from $\fpaynet{}_{\mathrm{, Pay}}$: \Comment{\textsc{pay},
      \textsc{getClosedFunds}, \textsc{pushFulfill}, \textsc{pushAdd},
      \textsc{commit}}
        \Indent
        \State handle first part of the message normally
        \ForAll{$\Sigma_{\alice} \in \Sigma$}
          \ForAll{$(\overrightarrow{\mathtt{path}}, \mathit{payid}) \in
          \mathtt{payids} : \alice \in \overrightarrow{\mathtt{path}}$}
            \If{\alice{} sent \textsc{updateFulfillHtlc} to a corrupted player
            and either (got the fulfillment of the HTLC irrevocably committed OR
            fulfilled the HTLC on-chain (i.e. permanently added
            \texttt{HTLC-success} to \ledger)), AND the next honest player
            \bob{} down the line successfully timed out the HTLC on-chain (i.e.
            permanently added the relevant \texttt{HTLC-Timeout} to \ledger)
            (due to no or bad communication from the previous player)}
              \State add to \texttt{charged}(\alice) a tuple
              (\texttt{corrupted}, \textit{payid}) where \texttt{corrupted} is
              set to one of the corrupted parties between \alice{} and \bob{}
              \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
              from \texttt{payids}
            \ElsIf{(player before \alice{} (closer to payer) has put in block
            $h_{\mathrm{com}}$ of $\Sigma_{\alice}$ an older \texttt{commitment}
            tx (that doesn't contain the HTLC) AND \simulator{} hasn't received
            (\textsc{getClosedFunds}, \texttt{report}, \alice,
            \textit{reportid}) from $\fpaynet{}_{\mathrm{, Pay}}$ with the
            offending tx in \texttt{report} during $\left[h_{\mathrm{com}} + k,
            h_{\mathrm{com}} + k + \mathtt{AliceDelay} - 1\right]$) OR (player
            after \alice{} (closer to receiver) has irrevocably fulfilled the
            HTLC on-chain with the \texttt{HTLC-success} tx in block
            $h_{\mathrm{fulfill}}$ of $\Sigma_{\alice}$ AND \simulator{} hasn't
            received (\textsc{fulfillOnChain}, $\mathrm{cltvExpiry} - 2k -
            \tochain - 1$, \alice) from $\fpaynet{}_{\mathrm{, Pay}}$, where
            cltvExpiry is the incoming CLTV expiry of \alice{} in
            $\overrightarrow{\mathtt{path}}$)}
              \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
              \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
              from \texttt{payids}
            \ElsIf{\alice{} is the payer in $\overrightarrow{\mathtt{path}}$ AND
            ((she has received \textsc{updateFulfillHtlc} AND has subsequently
            sent \textsc{commit} and \textsc{revokeAndAck}) OR player after
            \alice{} has irrevocably fulfilled the HTLC on-chain with the
            \texttt{HTLC-success} tx)} \Comment{honest payment completed}
              \State add (\alice, \textit{payid}) to \texttt{charged}(\alice)
              \State remove ($\overrightarrow{\mathtt{path}}$, \textit{payid})
              from \texttt{payids}
            \EndIf
          \EndFor
        \EndFor
        \State append $\left(\textsc{resolvePays}, \mathtt{charged}\right)$ to
        the message to be sent, clear \texttt{charged} and send message to
        $\fpaynet{}_{\mathrm{, Pay}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:resolvepay}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open}}, \environment} \overset{c}{\approx}
  \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN -
  Reg - Open - Pay}}, \environment}$
\end{lemma}

\begin{proof}
  When \environment{} sends $\left(\textsc{pay}, \bob, x,
  \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to \alice{} in the
  ideal world, \simulator{} is always notified (Fig.~\ref{alg:fpaynet:pay},
  line~\ref{alg:fpaynet:pay:send}) and simulates the relevant execution of the
  real world (Fig.~\ref{alg:sim:pay}, line~\ref{alg:sim:pay:simulate}). No
  messages to \ledger{} or \environment{} that differ from the real world are
  generated in the process. At the end of this simulation, no further messages
  are sent (and the control returns to \environment). Therefore, when
  \environment{} sends \textsc{pay}, no opportunity for distinguishability
  arises.

  When \environment{} sends any message of (\textsc{pushAdd}, \textit{pchid}),
  (\textsc{pushFulfill}, \textit{pchid}), (\textsc{commit}, \textit{pchid}) to
  \alice{} in the ideal world, it is forwarded to \simulator{}
  (Fig.~\ref{alg:fpaynet:daemon},
  lines~\ref{alg:fpaynet:daemon:fulfill},~\ref{alg:fpaynet:daemon:add},~\ref{alg:fpaynet:daemon:commit}
  respectively), who in turn simulates \alice's real-world execution with her
  simulated ITI and the handling of any subsequent messages sent by \alice's ITI
  (Fig.~\ref{alg:sim:pay},
  lines~\ref{alg:sim:pay:fulfill},~\ref{alg:sim:pay:add},~\ref{alg:sim:pay:commit}).
  Neither $\fpaynet{}_{\mathrm{, Pay}}$ nor \simulator{} alter their state as a
  result of these messages, apart from the state of \alice's simulated ITI and
  the state of other simulated ITIs that receive and handle messages that were
  sent as a result of \alice's ITI simulation. The states of these ITIs are
  modified in the exact same way as they would in the real world. We deduce that
  these three messages do not introduce any opportunity for \environment{} to
  distinguish the real and the ideal world.

  \TODO{continue}
  When \environment{} sends (\textsc{fulfillOnChain}) to \alice{}

  When \environment{} sends (\textsc{poll}) to \alice{}
\end{proof}
