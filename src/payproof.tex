\begin{figure}[H]
  \begin{systembox}{$\fpaynet{}_{\mathrm{, Pay}}$}
    \begin{algorithmic}[1]
      \State For messages \textsc{register}, \textsc{registerDone},
      \textsc{registered}, \textsc{openChannel}, \textsc{channelAnnounced},
      \textsc{checkNew}, \textsc{poll}, \textsc{pay}, \textsc{pushAdd},
      \textsc{pushFulfill}, \textsc{fulfillOnChain} and \textsc{commit}, act
      like \fpaynet{}.
      \Statex

      \State Upon receiving any other message $M$ from \alice:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from a player}
          \State send ($M, \alice$) to \simulator
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving any other message ($M, \alice$) from \simulator:
      \Indent
        \If{$M$ is a valid \fpaynet{} message from \simulator}
          \State send $M$ to \alice
        \EndIf
      \EndIndent
    \end{algorithmic}
  \end{systembox}
  \caption{}
  \label{alg:proof:fpaynet:pay}
\end{figure}

\begin{figure}[H]
  \begin{simulatorbox}{$\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$}
    Like $\simulator{}_{\mathrm{LN - Reg - Open}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving $\left(\textsc{fulfillOnChain}, t, \alice\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State Execute
        lines~\ref{alg:protocol:pay:foc:tosubmit}-\ref{alg:protocol:pay:foc:submit}
        of Fig.~\ref{alg:protocol:pay:push} as \alice{}, using $t$ from message
      \EndIndent
      \Statex

      \State Upon receiving $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      from $\fpaynet{}_{\mathrm{, Pay}}$:
      \Indent
        \State strip \textit{payid}, simulate receiving the message with
        \alice{} ITI and further execute the parts of $\Pi_{\mathrm{LN}}$ that
        correspond to honest parties (Fig.~\ref{alg:protocol:pay:invoice}-
        Fig.~\ref{alg:protocol:pay:updateFulfillHtlc})
        \If{any ``ensure'' in $\Pi_{\mathrm{LN}}$ fails until receiver processes
        \textsc{updateAddHtlc}} \Comment{payment failed}
          \State send $\left(\textsc{resolvePay}, \mathit{payid}, \bot\right)$
          to $\fpaynet{}_{\mathrm{, Pay}}$
        \EndIf
      \EndIndent
      \Statex

      \State Upon receiving btw $\Sigma_{\charlie}$ from $\fpaynet{}_{\mathrm{,
      Pay}}$: \TODO{fix the two ifs to care only about \charlie}
        \Indent
        \State $\mathtt{charged} \gets \emptyset$
        \ForAll{\textit{payid}s}
          \If{honest $\charlie{} \in \overrightarrow{\mathtt{path}}$ that sent
          \textsc{updateFulfillHtlc} to a corrupted player either (gets the
          fulfillment of the HTLC irrevocably committed OR fulfills the HTLC
          on-chain), AND the next honest player \dave{} down the line
          successfully times out the HTLC on-chain (i.e. adds the relevant
          \texttt{HTLC-Timeout} to \ledger) (due to no or bad communication from
          the corrupted player)}
            \State set \texttt{charged} to one of the corrupted parties between
            \charlie{} and \dave{}
          \ElsIf{(player before \charlie{} (closer to payer) puts in block
          $h_{\mathrm{com}}$ an older channel commitment tx (that doesn't
          contain the HTLC) AND \simulator{} hasn't received
          (\textsc{getClosedFunds}, \texttt{report}, \charlie,
          \textit{reportid}) from $\fpaynet{}_{\mathrm{, Pay}}$ with the
          offending tx in \texttt{report} during $\left[h_{\mathrm{com}} + k,
          h_{\mathrm{com}} + \mathtt{CharlieDelay} + k - 1\right]$\TODO{fix}) OR
          (player after \charlie{} (closer to receiver) fulfills the HTLC
          on-chain AND \simulator{} hasn't received (\textsc{fulfillOnChain},
          $\mathrm{cltvExpiry} - 2k - \tochain - 1$, \charlie) from
          $\fpaynet{}_{\mathrm{, Pay}}$, where cltvExpiry is the outgoing CLTV
          expiry of \charlie{} in $\overrightarrow{\mathtt{path}}$)}
            \State (\charlie, \textit{payid}) add to \texttt{charged}
          \Else
            \State let \alice{} the payer in $\overrightarrow{\mathtt{path}}$ of
            \textit{payid}
            \State (\alice, \textit{payid}) add to \texttt{charged}
          \EndIf
        \EndFor
        \State send $\left(\textsc{resolvePays}, \mathtt{charged}\right)$ to
        $\fpaynet{}_{\mathrm{, Pay}}$
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:pay}
\end{figure}

\begin{lemma}
  \label{lemma:pay}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Open}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open}}, \environment} \overset{c}{\approx}
  \textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN -
  Reg - Open - Pay}}, \environment}$
\end{lemma}

\begin{proof}
  \TODO{continue}
  When \environment{} sends $\left(\textsc{pay}, \bob, x,
  \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$

  When \environment{} sends (\textsc{poll})

  When \environment{} sends (\textsc{pushAdd}, \textit{pchid})

  When \environment{} sends (\textsc{pushFulfill}, \textit{pchid})

  When \environment{} sends (\textsc{fulfillOnChain})

  When \environment{} sends (\textsc{commit}, \textit{pchid})
\end{proof}
