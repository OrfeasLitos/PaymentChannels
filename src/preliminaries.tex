\section{Preliminaries}
  In this section we will give a brief overview of the tools and frameworks that
  we use in this work.

  \subsection{Universal Composability framework}
    Simulation-based security~\cite{howtosimulateit} is a paradigm that enables
    us to prove a protocol $\Pi$ secure in the presence of an ``adversary''
    \adversary, who may corrupt some parties and make them act arbitrarily.
    \orfeas{Simulation-based security~\cite{howtosimulateit} is a paradigm that
    allows for the expression of formal guarantees regarding the security of a
    protocol in the presence of an adversary.} More concretely, we define an
    ideal ``functionality'' $\mathcal{F}$, a trusted third party that gets the
    inputs of all parties and returns the outputs they would get in the real
    world, by running the protocol. This functionality expresses the intended
    purpose of the protocol. Then we prove that, no matter what the adversary
    does, we can define a ``simulator'' \simulator{} (that is the interface
    between the functionality and the adversary) such that an external observer
    cannot distinguish between the real world and the ideal world. We then say
    that the protocol ``realizes'' the functionality.

    Albeit a powerful tool, simulation-based security only works when a single
    instance of the protocol is run in isolation. However, real-world systems
    almost always run several programs concurrently, which furthermore may run
    different instances of the same protocol. Universal Composability~\cite{uc}
    provides a formal framework to overcome this issue. In particular it
    replaces $\mathcal{F}$, $\Pi$, \adversary{}, \simulator{} and the external
    observer with Interactive Turing Machines (ITMs). The external observer is
    now called ``environment'' \environment{} and can interactively communicate
    with $\Pi$ or $\mathcal{F}$, as opposed to simply providing inputs and
    expecting outputs. \environment{} is allowed to act arbitrarily, thus
    encapsulating anything that may happen in the system in parallel with the
    protocol. The central result in UC allows us to prove that $\Pi$
    ``UC-realizes'' $\mathcal{F}$, which is enough to ensure that security holds
    no matter what \environment{} executes. More importantly, $\Pi$ may
    internally use another functionality $\mathcal{G}$ (called a ``hybrid''). If
    protocol $\Pi'$ has been proven to UC-realize $\mathcal{G}$, then the
    Universal Composition theorem guarantees that \environment{} cannot
    distinguish between an interaction with $\Pi$ using $\Pi'$ and one with
    $\Pi$ using $\mathcal{G}$. We thus avoid proving again the security of
    $\Pi'$ in the context of $\Pi$. Put differently, we have the power to
    compose protocols. In this work we choose to use the UC framework in order
    to leverage previous results on the security of blockchains.

  \subsection{Hybrid functionalities used}
    Both our main protocol and the corresponding functionality use
    \ledger~\cite{BMTZ17,genesis} as a hybrid. \ledger{} formalizes an ideal
    distributed append-only data structure akin to a blockchain. Any
    participating party can read from \ledger, which returns an ordered list
    of transactions. Furthermore parties can submit new transactions which, if
    valid, will be added to the ledger at the discretion of the adversary, but
    necessarily within a predefined time window. This property is called
    liveness. Once a transaction is added to the ledger, it becomes visible to
    all parties at the discretion of the adversary, but within another
    predefined time window, and cannot be removed or reordered. This is called
    persistence. The exact definition can be found in
    Appendix~\ref{appendix:ledger}.

    Furthermore, \ledger{} needs two more functionalities: \Fclock and
    $\FnetworkEd^\Delta$. \Fclock models the notion of time. Every participating
    party can request to read the current time (which is initialized to 0) and
    inform \Fclock that her round is over. \Fclock increments the time by one
    once all parties have declared the end of their round. $\FnetworkEd^\Delta$
    provides an abstraction of the network. A party can send
    $\FnetworkEd^\Delta$ a message to be multicast to all other participants of
    the network. A party can also fetch its new messages from
    $\FnetworkEd^\Delta$. $\FnetworkEd^\Delta$ makes a message available to be
    fetched immediately after its arrival, but the adversary may delay the
    arrival for up to $\Delta$ rounds. \adversary{} can choose different delays
    for different players and reorder messages. Additionally, he has the power
    to send his own messages to selected subsets of players.

    The protocol and functionality defined in the current work do not make
    direct use of \Fclock or $\FnetworkEd^\Delta$. We therefore omit these two
    in the statements of Lemmas~\ref{lemma:dummy}-\ref{lemma:close} and
    Theorem~\ref{theorem:simulation} for simplicity of notation; they should
    normally appear as hybrids along with \ledger. Their exact definition can be
    found in Appendix~\TODO{TODO}.

  \subsection{Transaction structure}
    \ledger{} does not define what is a valid transaction, but leaves it as a
    system parameter. Importantly, no notion of coins is built in \ledger. We
    therefore specify a valid transaction, closely following concepts put forth
    in Bitcoin~\ref{bitcoin}, but avoiding specifying the entire Bitcoin script.

    At a high level, every transaction consists of inputs and outputs. Each
    output has an associated value in coins and a number of ``spending
    methods''. A spending method specifies the exact requirements for spending
    the output. Each input must be connected to exactly one output and satisfy
    one of its spending methods.

    Transactions in \ledger{} form a DAG. A new transaction is valid only if
    each of its inputs correctly spends an output with no other connected input
    and the sum of the values of its outputs does not exceed the sum of the
    values of the outputs connected to its inputs. We refer the reader to
    Appendix~\ref{appendix:txstructure} for a complete overview.

  \subsection{Identity Based Signatures}
    In the Lightning Network specification, a custom scheme for deriving keys is
    used. Its syntax and security aims closely match those of previously studied
    Identity Based Signature schemes~\cite{ibsshamir,ibspaterson}, thus we use
    the latter to abstract away the complexity of the construction and highlight
    the security requirements it satisfies. We slightly modify previous IBS
    schemes by adding an algorithm that, on input of the public parameters $mpk$
    and a label $l$, returns the verification key $pk_l$. Such an IBS scheme
    provides 5 algorithms:
    \begin{itemize}
      \item $(mpk, msk) \leftarrow \textsc{Setup}(1^k)$: master keypair
      generation
      \item $(pk_l, sk_l) \leftarrow \textsc{KeyDer}(mpk, msk, l)$: keypair
      derivation with label $l$
      \item $pk_l \leftarrow \textsc{PubKeyDer}(mpk, l)$: verification key
      derivation with label $l$
      \item $\sigma \leftarrow \textsc{SignIBS}(m, sk_l)$: signature generation
      with signing key $sk_l$
      \item $\{0, 1\} \leftarrow \textsc{VerifyIBS}(\sigma, m, pk_l)$: signature
      verification
    \end{itemize}
    We refer the reader to~\cite{ibspaterson} for more details. \orfeas{Anything
    missing? Correctness? Security game? mention that we believe their
    construction realizes IBS, but we don't prove it?} 
    \aggelos{looks good. we should add correctness + security game because we need
    them in our LN proof. It makes sense to make a statement about their
    scheme as well. That can be in the appendix in a separate section. }
