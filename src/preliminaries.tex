\section{Preliminaries}
  In this section we will give a brief overview of the tools and frameworks that
  we use in this work.

  \subsection{Universal Composability framework}
    Simulation-based security~\cite{howtosimulateit} is a paradigm that enables
    us to prove a protocol $\Pi$ secure in the presence of an ``adversary''
    \adversary, who may corrupt some parties and make them act arbitrarily.
    \orfeas{Simulation-based security~\cite{howtosimulateit} is a paradigm that
    allows for the expression of formal guarantees regarding the security of a
    protocol in the presence of an adversary.} More concretely, we define an
    ideal ``functionality'' $\mathcal{F}$, a trusted third party that gets the
    inputs of all parties and returns the outputs they would get in the real
    world, by running the protocol. This functionality expresses the intended
    purpose of the protocol. Then we prove that, no matter what the adversary
    does, we can define a ``simulator'' \simulator{} (that is the interface
    between the functionality and the adversary) such that an external observer
    cannot distinguish between the real world and the ideal world. We then say
    that the protocol ``realizes'' the functionality.

    Albeit a powerful tool, simulation-based security only works when a single
    instance of the protocol is run in isolation. However, real-world systems
    almost always run several programs concurrently, which furthermore may run
    different instances of the same protocol. Universal Composability~\cite{uc}
    provides a formal framework to overcome this issue. In particular it
    replaces $\mathcal{F}$, $\Pi$, \adversary{}, \simulator{} and the external
    observer with Interactive Turing Machines (ITMs). The external observer is
    now called ``environment'' \environment{} and can interactively communicate
    with $\Pi$ or $\mathcal{F}$, as opposed to simply providing inputs and
    expecting outputs. \environment{} is allowed to act arbitrarily, thus
    encapsulating anything that may happen in the system in parallel with the
    protocol. The central result in UC allows us to prove that $\Pi$
    ``UC-realizes'' $\mathcal{F}$, which is enough to ensure that security holds
    no matter what \environment{} executes. More importantly, $\Pi$ may
    internally use another functionality $\mathcal{G}$ (called a ``hybrid''). If
    protocol $\Pi'$ has been proven to UC-realize $\mathcal{G}$, then the
    Universal Composition theorem guarantees that \environment{} cannot
    distinguish between an interaction with $\Pi$ using $\Pi'$ and one with
    $\Pi$ using $\mathcal{G}$. We thus avoid proving again the security of
    $\Pi'$ in the context of $\Pi$. Put differently, we have the power to
    compose protocols. In this work we choose to use the UC framework in order
    to leverage previous results on the security of blockchains.

  \subsection{valid tx}
  \subsection{hybrids}
  \subsection{IBS}
