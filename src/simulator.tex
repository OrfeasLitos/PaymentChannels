\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item register(pubKey, hashList)
      \item setDelay(delay)
      \item createChannel(self, peer, selfCoins, peerCoins, selfDelay, forFundTX)
      \item endorseChannel(peer, self, peerCoins, selfCoins, selfDelay)
      \item breakChannel(receipt)
      \item pay(peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \State Initialisation:
      \Indent
      \ForAll{$V \in \mathcal{P}$}
        \State $\mathtt{blocked}\left(V\right),
        \mathtt{onChainBalance}\left(V\right), \mathtt{delay}\left(V\right)
        \gets 1\mathrm{day}$ \Comment{default delay}
        \State $\mathtt{pubKey}\left(V\right), \mathtt{hashList}\left(V\right)
        \gets \bot$
      \EndFor
      \State $\mathtt{pendingOpen}, \mathtt{pendingClose}, \mathtt{channels}
      \gets \emptyset$
      \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}, Alice\right)$ from
    $\mathcal{F}_{\mathrm{PayNet}}$:
    \Indent
      \State \Comment{TODO}
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State send $\left(\textsc{register}, Alice\right)$ to $\mathcal{S}$
      \State assign reply to $\left(\mathtt{pubkey}\left(Alice\right),
      \mathtt{hashList}\left(Alice\right)\right)$
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State ignore message if $Alice$ has not registered
      \State send (\textsc{Read}) to $\mathcal{G}_{\mathrm{Ledger}}$ as $Alice$
      and assign reply to $\Sigma_{Alice}$
      \State count all coins currently exclusively spendable by $Alice$ in
      $\Sigma_{Alice}$ (with $\mathtt{pubKey}\left(Alice\right)$ and possibly a
      preimage of a hash in $\mathtt{hashList}\left(Alice\right)$) and assign
      result to $\mathtt{onChainBalance}\left(Alice\right)$ \Comment{TOASK:
      should I specify further?}
    \EndIndent
    \State

    \State BEGIN LIGHTNING FUNCTIONALITY-SPECIFIC
    \State Upon receiving $\left(\textsc{setDelay}, \mathrm{delay}\right)$
    from $Alice$:
    \Indent
      \State $\mathtt{delay}\left(Alice\right) \gets \mathrm{delay}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{createChannel}, Alice, Bob, x\right)$
    from $Alice$:
    \Indent
      \State ensure $\mathrm{onChainBalance}\left(Alice\right) \geq x$
      \State choose unique channel ID chid
      \State send $\left(\textsc{getForFundTX}, Alice, x\right)$ to
      $\mathcal{S}$ and assign reply to forFundTX
      \State $\left(pk_a, sk_a\right) \gets \mathrm{KeyGen}\left(\right)$
      \State $\left(pk_b, sk_b\right) \gets \mathrm{KeyGen}\left(\right)$
      \State $F \gets \mathrm{forFundTX}.\mathrm{addOutput}\left(\mathrm{value}
      = x, \mathrm{spMethod} = \left[\left(pk_a \wedge
      pk_b\right)\right]\right)$
      \State send $\left(\textsc{submit}, F\right)$ as $Alice$ to
      $\mathcal{G}_{\mathrm{Ledger}}$
      \State add $\left(Alice, Bob, x, 0, \mathtt{delay}\left(Alice\right),
      \mathtt{delay}\left(Bob\right), \left(pk_a, sk_a\right), \left(pk_a,
      sk_a\right), F, \mathrm{chid}\right)$ to \texttt{pendingOpen}
      \State send $\left(\textsc{pendingOpen}, Alice, Bob, F,
      \mathrm{chid}\right)$ to $\mathcal{S}$ \Comment{May not need chid}
      % Simulator has to keep track of which participant hasn't received receipt
      % yet
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}\right)$ from $Alice$:
    \Indent
      \State send $\left(\textsc{poll}, Alice\right)$ to $\mathcal{S}$ and
      assign reply to (updates, opens)
      \State $\mathrm{ret} \gets \emptyset$
      \For{(chid, $x$, justReported) in updates}
        \If{justReported}
          \State move $x$ coins from 1st to 2nd player of the chid channel,
          increment sequence number, save new version to \texttt{channels}
          % TODO: receive/generate and store needed txs for update
        \EndIf
        \State add $Alice$'s \texttt{receipt} from the latest state of channel
        chid to ret
      \EndFor
      \For{(chid, justReported) in opens}
        \If{justReported}
          % NOTE: checking the ledger for F may be redundant
          \State Let $F$ the funding transaction in chid entry of
          \texttt{pendingOpen}
          \State send (\textsc{read}) as $Alice$ to $\mathcal{G}_{Ledger}$ and
          assign reply to $\Sigma_{Alice}$
          \State ensure that $F$ is in $\Sigma_{Alice}$
          \State $\mathrm{onChainBalance}\left(Alice\right) \gets
          \mathrm{onChainBalance}\left(Alice\right) - x$
          \State append sequence number 0 to chid entry in \texttt{pendingOpen}
          and move it to \texttt{channels}
        \EndIf
        \State add $Alice$'s \texttt{receipt} from channel chid to ret
      \EndFor
      % NOTE: here are the receipt contents
      %\State $\mathtt{receipt} \gets \left(Alice, Bob, x, 0,
      %\mathrm{chid}\right)$
      \State \Return (\textsc{poll}, ret) $Alice$
    \EndIndent
    \State END LIGHTNING FUNCTIONALITY-SPECIFIC
    \State

    \State BEGIN ROBUST FUNCTIONALITY-SPECIFIC
    \State TODO: remove forFundTX from Alice (c.f. above)
    \State Upon receiving $\left(\textsc{createChannel}, Alice, Bob, x, y,
    \mathrm{AliceDelay}, \mathrm{forFundTX}\right)$ from $Alice$:
    \Indent
      \State ensure that forFundTX has inputs spendable by $Alice$ of total
      value at least $x$ and by $Bob$ of total value at least $y$
      \State ensure that it is possible to add a $x + y$-valued output to
      forFundTX
      \State ensure that there is no $\left(Alice, Bob, \_, \_, \_, \_\right)$
      in \texttt{pending}
      \State choose unique temporary ID tempid
      \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
      \mathrm{forFundTX}, \mathrm{tempid}\right)$ to \texttt{pending}
      \State $\mathtt{blocked}\left(Alice\right) \leftarrow
      \mathtt{blocked}\left(Alice\right) + x$
      \State \Return $\left(\textsc{endorseChannel}, Alice, Bob, x, y,
      \mathrm{AliceDelay}, \mathrm{tempid}\right)$ to $Bob$ \Comment{DISCUSS:
      return to Bob but Alice called?}
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{endorseChannel}, Alice, Bob, x, y,
    \mathrm{BobDelay}, \mathrm{tempid}\right)$ from $Bob$: \Comment{This message
    does not exist in LND, because only one side funds the channel there.}
    \Indent
      \State ensure that $\left(Alice, Bob, x, y, \_, \_, \mathrm{tempid}\right)
      \in \mathtt{pending}$
      \State ensure that $\mathtt{onChainBalance}\left(Alice\right) \geq
      \mathtt{blocked}\left(Alice\right) + x$
      \State ensure that $\mathtt{onChainBalance}\left(Bob\right) \geq
      \mathtt{blocked}\left(Bob\right)$
      \State AliceDelay, forFundTX $\gets$ last 2 elements in $\left(Alice,
      Bob, x, y, \_, \_\right)$
      \State remove $\left(Alice, Bob, x, y, \_, \_, \mathrm{tempid}\right)$
      from \texttt{pending}
      \State $\mathrm{onChainBalance}\left(Alice\right) \gets
      \mathrm{onChainBalance}\left(Alice\right) - x$
      \State $\mathrm{onChainBalance}\left(Bob\right) \gets
      \mathrm{onChainBalance}\left(Alice\right) - y$
      \State $\mathtt{blocked}\left(Alice\right) \gets
      \mathtt{blocked}\left(Alice\right) - x$
      \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
      reply to $\tau$
      \State send $\left(\textsc{openChannel}, Alice, Bob, x, y,
      \mathrm{forFundTX}, \tau\right)$ to $\mathcal{A}$ \Comment{Keys generated
      and tx submitted by simulator TODO: may need delays}
      % for Simulator
      %\State $\mathtt{tx} \gets \left(\textsc{Funding}\left(x, y, pa_F, pb_F,
      %\mathrm{forFundTX}\right), \tau_L\right)$
      %\State add \texttt{tx} to \texttt{buffer}
      \State forget tempid
      \State choose a unique channel ID chid
      \State $\mathtt{channel} \gets \left(Alice, Bob, x, y,
      \mathrm{AliceDelay}, \mathrm{BobDelay}, 0, \mathrm{chid}\right)$
      \State add \texttt{channel} to \texttt{channels}
      \State $\mathtt{receipt} \gets \left(Alice, Bob, x, y, 0,
      \mathrm{chid}\right)$
      \State \Return $\left(\textsc{Receipt}, \mathtt{receipt}\right) \text{
      to } Alice \text{ and } Bob$
      \Comment{Multiple returns?}
    \EndIndent
    \State END ROBUST FUNCTIONALITY-SPECIFIC

    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State ensure that $\mathtt{receipt}$ corresponds to a channel \texttt{ch}
      between $Alice$ and $\overrightarrow{\mathtt{path}}\left[1\right]$.
      \State ensure that $Alice$ has at least $x$ in \texttt{ch}.
      \State send $\left(\textsc{pay}, Bob, x, \overrightarrow{\mathtt{path}},
      \mathtt{receipt}\right)$ to $\mathcal{S}$ and ensure reply is
      \textsc{okPay}
      % TODO for Simulator: keep track of malicious differences with what
      % F_PayNet keeps track of
      \ForAll{$\left(Carol, Dave\right)$ pairs in
      $\overrightarrow{\mathtt{path}}$}
        % if F_PayNet thinks that both are honest
        %   build Carol -> Dave msg and send it to Simulator
        %   expect simple OK for reply (all replies will come whenever,
        %   shouldn't block here)
        %   build Dave -> Carol msg and ... repeat until hop is over
        % else if F_PayNet thinks that only Carol is honest
        %   build Carol -> Dave msg and send it to Simulator
        %   expect whatever the protocol Carol would expect as reply from Dave
        %   build Carol -> Dave ... repeat until hop is over
        % else if F_PayNet thinks that only Dave is honest
        %   send (nextHop, Carol, Dave, <other payment data>) to Simulator
        %   expect whatever the protocol Dave would expect as 1st msg for hop from Dave
        %   build Dave -> Carol msg and send it to Simulator
        %   expect whatever the protocol Dave would expect as 2nd msg for hop from Dave
        %   ... repeat until hop is over
        % else if F_PayNet thinks both are malicious
        %   send (nextHop, Carol, Dave, <other payment data>) to Simulator
        %   expect simple OK for reply
        %   ... repeat <number of messages needed> times
      \EndFor
      \ForAll{$\left(Carol, Dave\right)$ pairs in
      $\overrightarrow{\mathtt{path}}$ in reverse order}
        % if F_PayNet thinks that both are honest
        %   build Dave -> Carol msg and send it to Simulator
        %   expect simple OK for reply (all replies will come whenever,
        %   shouldn't block here)
        %   build Carol -> Dave msg and  send it to Simulator
        %   expect simple OK for reply
        %   build Dave -> Carol ... repeat until hop is over
        % else if F_PayNet thinks that only Carol is honest
        %   send (nextHop, Carol, Dave, <other payment data>) to Simulator
        %   expect whatever the protocol Carol would expect as reply from Dave
        %   build Carol -> Dave msg and send it to Simulator
        %   send ... repeat until hop is over
        % else if F_PayNet thinks that only Dave is honest
        %   build Dave -> Carol msg and send it to Simulator
        %   expect whatever the protocol Dave would expect as 1st msg for hop from Dave
        %   build Dave -> Carol msg and ... repeat until hop is over
        % else if F_PayNet thinks both are malicious
        %   send (nextHop, Carol, Dave, <other payment data>) to Simulator
        %   expect simple OK for reply
        %   ... repeat <number of messages needed> times
        \State $\mathtt{oldCh} \gets \left(Carol, Dave, y, z,
        \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq},
        \mathrm{chid}\right) \in \mathtt{channels}$
        \State $\mathtt{newCh} \gets \left(Carol, Dave, y - x, z + x,
        \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq} + 1,
        \mathrm{chid}\right)$
        \State add \texttt{newCh} to \texttt{channels}
        \State send $\left(Carol, Dave, y - x, z + x, \mathrm{seq} + 1,
        \mathrm{chid}\right)$ to $Carol$ and $Dave$ \Comment{DISCUSS: sending,
        not returning. TODO: add message label}
      \EndFor
      \State send message $\left(\textsc{payed}, Bob, x\right)$ to $Alice$
      \Comment{DISCUSS: which messages to send and how?}
      \State send message $\left(\textsc{payedFrom}, Alice, x\right)$ to $Bob$
    \EndIndent
    \State

    \State Upon receiving (\textsc{breakChannel}, \texttt{receipt}) from $Alice$:
    \Indent
      \State ensure that \texttt{receipt} contains $Alice$ and corresponds to a
      \texttt{channel} in \texttt{channels} (i.e. there is a \texttt{channel}
      that contains the \texttt{receipt} elements)
      \State AliceDelay $\gets$ AliceDelay of \texttt{channel}
      \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
      reply to $\tau$
      \State send $\left(\textsc{closeChannel}, \mathtt{channel},
      \tau\right)$ to $\mathcal{A}$
      \State Upon receiving (\textsc{breakChannel}, \texttt{receipt'}) from
      $Bob$ within AliceDelay blocks: \Comment{DISCUSS: what is a block?}
      \If{\texttt{receipt'} corresponds to a \texttt{channel'} in
      \texttt{channels} and (\texttt{receipt}, \texttt{receipt'}) have the
      same chid and \texttt{receipt'} has a greater sequence number than
      \texttt{receipt}}
        \State $\mathrm{onChainBalance}\left(Bob\right) \gets
        \mathrm{onChainBalance}\left(Bob\right) + x$, where $x$ is the total
        coins in $\texttt{channel'}$
        \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
        reply to $\tau'$
        \State send $\left(\textsc{revokeChannel}, \mathtt{channel'},
        \tau'\right)$ to $\mathcal{A}$
      \Else
        \State $x, y \gets Alice$'s and $Bob$'s coins in \texttt{channel}
        respectively
        \State $\mathrm{onChainBalance}\left(Alice\right) \gets
        \mathrm{onChainBalance}\left(Alice\right) + x$
        \State $\mathrm{onChainBalance}\left(Bob\right) \gets
        \mathrm{onChainBalance}\left(Bob\right) + y$
      \EndIf
      \State remove all items in \texttt{channels} with the same chid as
      \texttt{receipt}
    \EndIndent
  \end{algorithmic}
\end{functionality}
