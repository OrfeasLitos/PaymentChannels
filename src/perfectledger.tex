\section{A Perfect Ledger is unrealisable}
\label{appendix:perfectledger}
  As already mentioned, previous attempts at formalising payment channels in
  UC~\cite{DBLP:conf/ccs/DziembowskiFH18,perun,Malavolta:2017:CPP:3133956.3134096,sprites}
  assume a variant of a ledger functionality with instant finality. We here
  define a reasonable variant \perfectledger{} (Fig.~\ref{fig:perfectledger})
  and argue that such a functionality is unrealisable, even under strong network
  assumptions, i.e. a multicast synchronous network.

  \begin{figure}[H]
    \begin{systembox}{\perfectledger}
      \begin{algorithmic}[1]
        \State State: List of txs $\mathcal{L}$
        \Statex

        \State Upon receiving (\textsc{Submit}, $m$) from \alice, append $m$ to
        $\mathcal{L}$ and send (\textsc{Submit}, \alice, $m$) to \adversary
        \Statex

        \State Upon receiving (\textsc{Submit}, $m$) from \adversary, append $m$
        to $\mathcal{L}$
        \Statex

        \State Upon receiving (\textsc{Read}) from \alice, send (\textsc{Read},
        $\mathcal{L}$) to \alice
        \Statex

        \orfeas{next three entries are what I assume to be boilerplate for all
        UC functionalities -- correct me if I'm wrong}
        \State Upon receiving (\textsc{corrupt}, \alice) from \adversary, mark
        \alice{} as \texttt{corrupted} and route all future messages directed to
        \alice{} to \adversary
        \Statex

        \State Upon receiving any message (\textsc{handle}, \alice, $M$) from
        \adversary, if \alice{} is corrupted, handle message $M$ as incoming
        from \alice{} and if it creates an outgoing message $M'$ to
        \texttt{dest}, send ($M'$, \texttt{dest}) to \adversary{} instead
        \Statex

        \State Upon receiving any message (\textsc{forward}, \alice, $M$) from
        \adversary, if \alice{} is corrupted, send ($M$) to \alice
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{fig:perfectledger:func}
  \end{figure}

  \begin{theorem}[Perfect Ledger is Unrealisable]
    \label{theorem:perfectledger}
    For any ITM \perfectprot{} there exist ITMs \perfectenv,
    \perfectadv{} such that for any ITM \simulator
    \begin{equation*}
      \textsc{Exec}^{\FnetworkEd^1, \gFclock}_{\perfectprot, \adversary,
      \environment} \not\approx \textsc{Exec}^{\perfectledger}_{\simulator,
      \environment}
    \end{equation*}
  \end{theorem}

  \begin{proofsketch}
    We take advantage of the \adversary's ability to selectively send messages
    to specific players. The attack is as follows: \environment{} flips a coin.
    In one case, it \textsc{submit}s a random string through honest player
    \alice{} and \textsc{read}s through another player \bob,
    whereas in the other, it has \adversary{} \textsc{multicast} through
    $\FnetworkEd^1$ a random string only to \alice and then instructs either
    \alice{} or \bob{} (chosen again at random) to \textsc{read}. \environment{}
    returns 1 when the player that was asked coincides with the player that was
    initially informed \TODO{complete or delete}
  \end{proofsketch}

  \begin{proof}
    We first define the offending environment and adversary and subsequently
    show how they can distinguish the ideal from the real world.
    \begin{figure}[H]
      \begin{titlebox}{Environment \normalfont \perfectenv}{commonbox}{normal}
        Spawn two players, \alice{} and \bob. Flip a coin. If it returns 0,
        execute \texttt{writeWithPlayer}, otherwise execute
        \texttt{writeWithAdversary}.
        \begin{algorithmic}[1]
          \Procedure{writeWithPlayer}{}
            \State First activation:
            \Indent
              \State choose random number $m \overset{\$}{\gets} \{0, 1\}^k$
              \State send (\textsc{submit}, $m$) to \alice
            \EndIndent
            \State Second activation:
            \Indent
              \State send (\textsc{read}) to \bob{} and assign result to
              $\mathcal{L}$
              \If{$m \in \mathcal{L}$}
                \State \Return 0 \Comment{players communicated}
              \Else
                \State \Return 1 \Comment{players did not communicate}
              \EndIf
            \EndIndent
          \EndProcedure
          \Statex

          \Procedure{writeWithAdversary}{}
            \State First activation:
            \Indent
              \State choose random number $m \overset{\$}{\gets} \{0, 1\}^k$
              \State send (\textsc{leak}, $m$) to \adversary{} \Comment{will
              \textsc{multicast} to \alice}
            \EndIndent
            \State Second activation:
            \Indent
              \State assign to $P$ a random choice from \{\alice, \bob\}
              \State send (\textsc{read}) to $P$ and assign result to
              $\mathcal{L}$
              \If{($m \in \mathcal{L}$ and $P$ = \bob) or ($m \notin
              \mathcal{L}$ and $P$ = \alice)}
                \State \Return 0 \Comment{unexpected}
              \Else
                \State \Return 1 \Comment{expected}
              \EndIf
            \EndIndent
          \EndProcedure
        \end{algorithmic}
      \end{titlebox}
      \caption{}
      \label{fig:perfectledger:env}
    \end{figure}

    \begin{figure}[H]
      \begin{titlebox}{Adversary \normalfont \perfectadv}{commonbox}{normal}
        Upon receiving (\textsc{leak}, $m$) from \perfectenv, send
        (\textsc{multicast}, ($m$, \alice)) to $\FnetworkEd^1$
      \end{titlebox}
      \caption{}
      \label{fig:perfectledger:adv}
    \end{figure}

    \TODO{continue}
  \end{proof}
