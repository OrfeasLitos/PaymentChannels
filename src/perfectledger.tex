\section{A Perfect Ledger is unrealisable}
\label{appendix:perfectledger}
  As already mentioned, previous attempts at formalising payment channels in
  UC~\cite{DBLP:conf/ccs/DziembowskiFH18,perun,Malavolta:2017:CPP:3133956.3134096,sprites}
  assume a variant of a ledger functionality with instant finality. We here
  define a reasonable variant \perfectledger{} (Fig.~\ref{fig:perfectledger})
  and argue that such a functionality is unrealisable, even under strong network
  assumptions, i.e. a multicast synchronous network.

  \begin{figure}[H]
    \begin{systembox}{\perfectledger}
      \begin{algorithmic}[1]
        \State State: List of txs $\mathcal{L}$
        \Statex

        \State Upon receiving (\textsc{Submit}, $m$) from \alice or \adversary,
        append $m$ to $\mathcal{L}$ and send (\textsc{Submit}, \alice or
        \adversary, $m$) to \adversary
        \Statex

        \State Upon receiving (\textsc{Read}) from \alice, send (\textsc{Read},
        $\mathcal{L}$) to \alice
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{fig:perfectledger:func}
  \end{figure}

  \begin{theorem}[Perfect Ledger is Unrealisable]
    \label{theorem:perfectledger}
    For any ITM \perfectprot{} there exist ITMs \perfectenv,
    \perfectadv{} such that for any ITM \simulator
    \begin{equation*}
      \textsc{Exec}^{\FnetworkEd^1, \gFclock}_{\perfectprot, \adversary,
      \environment} \not\approx \textsc{Exec}^{\perfectledger,
      \gFclock}_{\simulator, \environment}
    \end{equation*}
  \end{theorem}

  We refer the reader to Appendix~\ref{appendix:ledger} for the definition of
  $\FnetworkEd^1$.

  \begin{proofsketch}
    We take advantage of the \adversary's ability to selectively send messages
    to specific players. The attack is as follows: \environment{} flips a coin.
    In one case, it \textsc{submit}s a random string through honest player
    \alice{} and \textsc{read}s through another player \bob,
    whereas in the other, it has \adversary{} \textsc{multicast} through
    $\FnetworkEd^1$ a random string only to \alice and then instructs either
    \alice{} or \bob{} (chosen again at random) to \textsc{read}. \environment{}
    returns 1 when the player that was asked coincides with the player that was
    initially informed \TODO{complete or delete}
  \end{proofsketch}

  \begin{proof}
    We first define the offending environment and adversary and subsequently
    show how they can distinguish the ideal from the real world.
    \begin{figure}[H]
      \begin{titlebox}{Environment \normalfont \perfectenv}{commonbox}{normal}
        Spawn two players, \alice{} and \bob. Flip a coin. If it returns 0,
        execute \texttt{writeWithPlayer}, otherwise execute
        \texttt{writeWithAdversary}.
        \begin{algorithmic}[1]
          \Procedure{writeWithPlayer}{}
            \State First activation:
            \Indent
              \State choose random number $m \overset{\$}{\gets} \{0, 1\}^k$
              \State assign at random names \alice, \bob{} to two players
              \State send (\textsc{submit}, $m$) to \alice
            \EndIndent
            \State Second activation:
            \Indent
              \State send (\textsc{read}) to \bob
              \If{\bob{} does not give subroutine output}
                \State \Return 0 \Comment{real world}
                \label{fig:perfectledger:env:coin0:real}
              \ElsIf{\bob's subroutine output $\mathcal{L}$ contains $m$}
                \State \Return 1 \Comment{players communicated}
                \label{fig:perfectledger:env:coin0:comm}
              \ElsIf{$\mathcal{L}$ does not contain $m$}
                \State \Return 0 \Comment{players did not communicate}
                \label{fig:perfectledger:env:coin0:nocomm}
              \EndIf
            \EndIndent
          \EndProcedure
          \Statex

          \Procedure{writeWithAdversary}{}
            \State First activation:
            \Indent
              \State choose random number $m \overset{\$}{\gets} \{0, 1\}^k$
              \State assign at random names \alice, \bob{} to two players
              \State send (\textsc{leak}, $m$, \alice) to \adversary{}
              \Comment{in real world \adversary{} will \textsc{multicast} to
              \alice}
            \EndIndent
            \State Second activation:
            \Indent
              \State send (\textsc{read}) to \bob
            \EndIndent
            \State Third activation:
            \Indent
              \If{\bob{} does not give subroutine output}
                \State \Return 0 \Comment{real world}
                \label{fig:perfectledger:env:coin1:real1}
              \ElsIf{\bob's subroutine output $\mathcal{L}_{\bob}$ contains $m$}
                \State \Return 1 \Comment{ideal world}
                \label{fig:perfectledger:env:coin1:ideal1}
              \EndIf
              \State send (\textsc{read}) to \alice
              \If{\alice{} does not give subroutine output}
                \State \Return 0 \Comment{real world}
                \label{fig:perfectledger:env:coin1:real3}
              \ElsIf{\alice's subroutine output $\mathcal{L}_{\alice}$ contains
              $m$}
                \State \Return 0 \Comment{real world}
                \label{fig:perfectledger:env:coin1:real2}
              \ElsIf{$\mathcal{L}_{\alice}$ does not contain $m$}
                \State \Return 1 \Comment{ideal world or real \alice{}
                misbehaving}
                \label{fig:perfectledger:env:coin1:ideal2}
              \EndIf
            \EndIndent
          \EndProcedure
        \end{algorithmic}
      \end{titlebox}
      \caption{}
      \label{fig:perfectledger:env}
    \end{figure}

    \begin{figure}[H]
      \begin{titlebox}{Adversary \normalfont \perfectadv}{commonbox}{normal}
        Upon receiving (\textsc{leak}, $m$, \alice) from \perfectenv, simulate
        \perfectprot{} reacting to (\textsc{submit}, $m$). If it attempts to
        send a message (\textsc{multicast}, $m'$) to $\FnetworkEd^1$, send
        (\textsc{multicast}, ($m'$, \alice)) to $\FnetworkEd^1$.
      \end{titlebox}
      \caption{}
      \label{fig:perfectledger:adv}
    \end{figure}

    Since we quantify over all possible \simulator{} and \perfectprot, we have
    to refer to the probabilities of them taking specific actions of interest:
    \begin{gather*}
      \pssubmits = \Pr[\text{Upon receiving (\textsc{leak}, $m$) from
      \environment,} \\
      \text{\simulator{} sends (\textsc{submit}, $m$) to $\mathcal{L}$}] \\
      \ppsubmits = \Pr[\text{Upon receiving (\textsc{submit}, $m$) from
      \environment,} \\
      \text{\perfectprot{} sends (\textsc{multicast}, $f(m)$) to
      $\FnetworkEd^1$ for some function $f$}]
      \\
      \ppfetches = \Pr[\text{Upon receiving (\textsc{read}) from \environment,}
      \\
      \text{\perfectprot{} sends (\textsc{fetch}) to $\FnetworkEd^1$ for result
      } [m_1', \dots, m_n'] \\
      \text{and sends back to \environment{} a (\textsc{read}, $\mathcal{L}$)
      such that} \\
      \text{for the last $n$ elements of $\mathcal{L}, (m_1, \dots, m_n)$ it is
      } f(m_i) = m_i']
    \end{gather*}

    We first analyze the event in which the initial coin flip of \environment{}
    results in 0, $\mathrm{Coin}_0$. In the ideal world, the submitted message
    $m$ always ends up in the ledger right away and therefore when
    \environment{} has \bob{} \textsc{read}, it always sees $m$ in the answer,
    therefore (Fig.~\ref{fig:perfectledger:env},
    line~\ref{fig:perfectledger:env:coin0:in})
    \begin{equation}
    \label{eq:coin0:ideal}
      \Pr[\textsc{Exec}^{\perfectledger}_{\simulator, \perfectenv} = 1 |
      \mathrm{Coin}_0] = 1 \enspace.
    \end{equation}

    In the real world, in order for the submitted message $m$ to be in \bob's
    response to \textsc{read}, he must have fetched from $\FnetworkEd^1$ and
    \alice{} must have sent $m$ to $\FnetworkEd^1$ when she received
    (\textsc{submit}, $m$), therefore
    \begin{equation}
    \label{eq:coin0:real}
      \Pr[\textsc{Exec}^{\FnetworkEd^1, \gFclock}_{\perfectprot, \perfectadv,
      \perfectenv} = 1 | \mathrm{Coin}_0] = \ppsubmits \ppfetches \enspace.
    \end{equation}

    We now move on to the event in which the initial coin flip results in 1,
    $\mathrm{Coin}_1$. In the ideal world, if \simulator{} submits the received
    $m$ to the ledger then both \environment's \textsc{read} requests will be
    answered with an output that contains $m$, therefore
    \begin{equation}
    \label{eq:coin1:ideal}
      \Pr[\textsc{Exec}^{\perfectledger}_{\simulator, \perfectenv} = 1 |
      \mathrm{Coin}_1] = \pssubmits \ppfetches \ppfetches \enspace.
    \end{equation}
  \end{proof}
