\ \\ \noindent {$\Pi_{\mathrm{LN}}$} The protocol is executed by player $Alice$.
  \label{alg:lightningprot}
  \begin{algorithmic}[1]
    \State Initialisation:
    \Indent
      \State $\mathrm{blocked} \leftarrow 0$
      \State $G \leftarrow \left(\left\{\mathrm{pid}_{Alice}\right\}, \emptyset\right)$
    \EndIndent
    \State
    \State Upon receiving $\left(\mathtt{open}, \mathrm{pid}_{Alice}, \mathrm{pid}_{Bob},
    \mathrm{initTX}, \mathrm{forFundTX}, \mathrm{coins}, \mathrm{delay},
    \mathrm{bcast}\right)$
    \Indent
      \Indent
        \State from $\mathcal{E}$:
      \EndIndent
    \EndIndent
    \Indent
      \If{$\mathcal{G}_{\mathrm{Ledger}}.\mathrm{balance}(\mathrm{pid}_{Alice}) -
      \mathrm{blocked} \geq x$}
        \State $\mathrm{blocked} \leftarrow \mathrm{blocked} + x$
        \State $\left(\mathrm{txid}, \mathrm{success}\right) \gets
        \textsc{OpenChannel}\left(\mathrm{pid}_{Alice}, \mathrm{pid}_{Bob},\right.$
        \Indent
          \Indent
            \State $\left.\mathrm{initTX}, \mathrm{forFundTX}, \mathrm{coins},
            \mathrm{delay}, \mathrm{bcast}\right)$
          \EndIndent
        \EndIndent
        \If{sucess = True}
          \State $G \leftarrow G \cup \left(\left\{\mathrm{pid}_{Bob}\right\},
          \left\{\left(\mathrm{txid}, \left(\mathrm{pid}_{Alice}, \mathrm{coins}\right),
          \left(\mathrm{pid}_{Bob}, 0\right)\right)\right\}\right)$
          \State Send $\left(\mathtt{opened}, \mathrm{pid}_{Alice}, \mathrm{pid}_{Bob},
          \mathrm{coins}, \mathrm{delay}, \mathrm{bcast}, \mathrm{txid}\right)$ to
          $\mathcal{E}$
        \Else
          \State Send $\left(\mathtt{notOpened}, \mathrm{pid}_{Alice}, \mathrm{pid}_{Bob},
          \mathrm{coins}, \mathrm{delay}, \mathrm{bcast}\right)$ to $\mathcal{E}$
        \EndIf
        \State $\mathrm{blocked} \leftarrow \mathrm{blocked} - x$
      \Else
        \State Send $\left(\mathtt{noFunds}, \mathrm{pid}_{Alice}, \mathrm{coins}\right)$
        to $\mathcal{E}$
      \EndIf
    \EndIndent
    \State
    \Function{OpenChannel}{source, dest, initTX, forFundTX, coins, delay, bcast}
      \State $\left(\left(pa_F, sa_F\right), \left(pa_{\mathrm{pay}},
      sa_{\mathrm{pay}}\right), \left(pa_{\mathrm{dpay}},
      sa_{\mathrm{dpay}}\right),\right.$
      \Indent
        \State $\left.\left(pa_{\mathrm{htlc}}, sa_{\mathrm{htlc}}\right),
        \left(pa_{\mathrm{com}1}, sa_{\mathrm{com}1}\right), \left(pa_{\mathrm{rev}},
        sa_{\mathrm{rev}}\right)\right) \gets \textsc{GetOpenKeys}\left(\right)$
      \EndIndent
      \State Send (\texttt{openChannel}, coins, delay, bcast,
      \Indent
        \State $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
        pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$) to dest
      \EndIndent
      \State assert(response = (\texttt{acceptChannel}, minDepth(TODO), delay,
      \Indent
        \State $pb_F, pb_{\mathrm{pay}}, pb_{\mathrm{dpay}}, pb_{\mathrm{htlc}},
        pb_{\mathrm{com}1}, pb_{\mathrm{rev}}$) $\And$
        \State $\forall i \in \left\{F, \mathrm{pay}, \mathrm{dpay}, \mathrm{htlc},
        \mathrm{com}1, \mathrm{rev}\right\},
        \mathcal{F}_{\mathrm{Wallet}}.\mathrm{isValidPubKey}\left(pb_i\right)$)
      \EndIndent
      \State $\left(F, \mathrm{idx}, \mathrm{sig}\right) \gets
      \textsc{GetFunding}\left(\mathrm{forFundTX}, \mathrm{coins}, sa_F, pa_F,
      pb_F\right)$
      \State Send (\texttt{fundingCreated}, $F$, idx, sig) to dest
      % delete start
      \State $\left(F, C1b, RD1b\right) \gets
      \textsc{GetOpenTXsSend}\left(\mathrm{initTX}, pa_1, sa_1, pb_1, pa_2, sa_2,
      pb_2, pb_3, \mathrm{funds}\right)$
      \State Send (\texttt{openSendTXs}, $\left(F, C1b, RD1b\right)$) to dest
      \State Wait for response
      \State assert(response = (\texttt{openResponseTXs}, $\left(C1a, RD1a\right)$)
      \Indent
        \State $\And \textsc{isValidOpenTXsResponse}\left(\left(C1a, RD1a\right), pb_2,
        pa_2, pa_3, \mathrm{funds}\right)$)
      \EndIndent
      \State Send (\texttt{fundingSig}, $\mathcal{F}_{\mathrm{Wallet}}.\text{sigForP2WPKH}
      \left(\mathrm{outpoint}\left(\mathrm{initTX}, 0\right), sa_0\right)$
      \State Wait for $F$ to be confirmed on-chain
      \State assert($F$ confirmed) \Comment{dest broadcasts $F$ TODO: correct way to
      Wait?}
      % delete end
    \EndFunction
    \State
    \Function{GetOpenKeys}{}
    % TODO: move elsewhere
%      \State $\left(\mathrm{initTX}, \left(pa_0, sa_0\right)\right) \gets
%      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{getTXandKeyWithValue}
%      \left(\mathrm{funds}\right)$ \Comment{Returns tx with 1 P2WPKH output of value funds
%      and the keypair that spends it for funding tx input}
\State TODO: improve comments
      \State $\left(pa_F, sa_F\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For $F$ output}
      \State $\left(pa_{\mathrm{pay}}, sa_{\mathrm{pay}}\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For payment}
      \State $\left(pa_{\mathrm{dpay}}, sa_{\mathrm{dpay}}\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For delayed
      payment}
      \State $\left(pa_{\mathrm{htlc}}, sa_{\mathrm{htlc}}\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For htlc}
      \State $\left(pa_{\mathrm{com}}, sa_{\mathrm{com}}\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For commitment
      tx}
      \State $\left(pa_{\mathrm{rev}}, sa_{\mathrm{rev}}\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For revocation
      tx}
      \State \Return $\left(\left(pa_F, sa_F\right), \left(pa_{\mathrm{pay}},
      sa_{\mathrm{pay}}\right), \left(pa_{\mathrm{dpay}},
      sa_{\mathrm{dpay}}\right),\right.$
      \Indent
        \State $\left.\left(pa_{\mathrm{htlc}}, sa_{\mathrm{htlc}}\right),
        \left(pa_{\mathrm{com}}, sa_{\mathrm{com}}\right), \left(pa_{\mathrm{rev}},
        sa_{\mathrm{rev}}\right)\right)$
      \EndIndent
    \EndFunction
    \State
    \Function{GetFunding}{coins, tx, $sa_F, pa_F, pb_F$}
      \State $\left(F, \mathrm{idx}\right) \gets
      \mathcal{F}_{\mathrm{Wallet}}$.addOutputToTX(tx, 2-of-2-msig$\left(pa_F, pb_F,
      \mathrm{coins}\right)$)
      % TODO: move elsewhere
        %\State inputs: $\left[\left(\mathrm{outpoint}\left(\mathrm{initTX}, 0\right),
        %\bot\right)\right]$
      \State $\mathrm{sig} \gets \mathcal{F}_{\mathrm{Wallet}}.\textsc{Sign}\left(F,
      \mathrm{idx}, sa_F\right)$
      \State \Return $\left(F, \mathrm{idx}, \mathrm{sig}\right)$
    \EndFunction
    \State
    \Function{GetOpenTXsSend}{$\mathrm{initTX}, pa_1, sa_1, pb_1, pa_2, sa_2, pb_2, pb_3,
    \mathrm{funds}$}
      \State $C1b \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(F, 0\right),
      \text{sigFor2-of-2-msig}\left(\mathrm{outpoint}\left(F, 0\right), 0,
      sa_1\right)\right)\right]$
      \State outputs: $\left[\mathrm{P2WPKH}\left(pa_2, \mathrm{funds}\right),
      \mathrm{RSMC}\left(pa_2, pb_2, 0\right)\right]$
      \State )\}
      \State $RD1b \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(C1b, 0\right),
      \text{sigForP2WPKH}\left(\mathrm{outpoint}\left(C1b, 0\right),
      sa_2\right)\right)\right]$
      \State outputs: $\left[\mathrm{Delay}\left(pb_3, \mathrm{funds}\right)\right]$
      \State )\}
      \State \Return $\left(F, C1b, RD1b\right)$
    \EndFunction
    \State
    \Function{GetOpenTXsRespond}{$F, sb_1, pa_2, pb_2, sb_2, pa_3, \mathrm{funds}$}
      \State $C1a \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(F, 0\right),
      \text{sigFor2-of-2-msig}\left(\mathrm{outpoint}\left(F, 0\right), 1,
      sb_1\right)\right)\right]$
      \State outputs: $\left[\mathrm{P2WPKH}\left(pb_2, 0\right), \mathrm{RSMC}\left(pb_2,
      pa_2, \mathrm{funds}\right)\right]$
      \State )\}
      \State $RD1a \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(C1a, 0\right),
      \text{sigForP2WPKH}\left(\mathrm{outpoint}\left(C1b, 0\right),
      sb_2\right)\right)\right]$
      \State outputs: $\left[\mathrm{Delay}\left(pa_3, 0\right)\right]$
      \State )\}
      \State \Return $\left(C1b, RD1b\right)$
    \EndFunction
    \State
    \Function{isValidOpenTXsSend}{$\left(F, C1b, RD1b\right), pa_1, pb_1, pa_2, pb_2,
    pb_3, \mathrm{funds}$}
      \State assert($F$ has exactly 1 output)
      \State assert($F_0 = \text{2-of-2-msig}\left(pa_1, pb_1, \mathrm{funds}\right)$)
      \State assert($C1b$ has exactly 2 outputs)
      \State assert($C1b_0 = \mathrm{P2WPKH}\left(pa_2, 0\right)$)
      \State assert($C1b_1 = \mathrm{RSMC}\left(pa_2, pb_2, \mathrm{funds}, t\right)$)
      ????
      \State assert($RD1b$ has exactly 1 output)
      \State assert($RD1b_0 = \mathrm{Delay}\left(pb_3, t, \mathrm{funds}\right)$) ????
      \State \Return True
    \EndFunction
    \State
    \Function{isValidOpenTXsResponse}{$\left(C1a, RD1a\right), pb_2, pa_2, pa_3,
    \mathrm{funds}$}
      \State assert($C1a$ has exactly 2 outputs)
      \State assert($C1a_0 = \mathrm{P2WPKH}\left(pb_2, 0\right)$)
      \State assert($C1a_1 = \mathrm{RSMC}\left(pb_2, pa_2, 0, t\right)$)
      \State assert($RD1a$ has exactly 1 output)
      \State assert($RD1a_0 = \mathrm{Delay}\left(pa_3, t, 0\right)$)
      \State \Return True
    \EndFunction
    \State
    \Function{P2WPKH}{$pk, \mathrm{funds}$}
      \State \Return \{coins: funds, address: $H\left(pk\right)$\}
    \EndFunction
    \State
    \State TOASK: (a) isValidPubKey() as predicate? (b) t parameter for protocol and all
    functions? where to pass it? (c) P2WSH used normally. Should it be simplified? (I
    think yes) (d) temp\_chan\_id needed? (I think not) (e) how to make Sigma protocols
    images?
    \State TODO: Bob's side, P2WPKH(), msig(), sigFor\_(), use actual spec
    \State
    \State Upon receiving (\texttt{opening}, $x$, tx) from $Bob$:
      \State Wait for tx to be confirmed
      \State $G \leftarrow G \cup \left(\left\{\mathrm{pid}_{Bob}\right\},
      \left\{\left(\mathcal{H}\left(\mathrm{tx}\right), \left(\mathrm{pid}_{Alice},
      0\right), \left(\mathrm{pid}_{Bob}, x\right)\right)\right\}\right)$ \Comment{Add
      $\mathrm{pid}_{Bob}$ to nodes, new channel to edges}
      \State Send (\texttt{opened}, $Alice$, $Bob$, 0, x,
      $\mathcal{H}\left(\mathrm{tx}\right))$ to $\mathcal{E}$
    \State
    \State Upon receiving (\texttt{newChannel}, txid, $\mathrm{pid}_{Charlie},
    \mathrm{pid}_{Dave}$) from $Bob$:
      \If{there exists a tx with $\mathcal{H}\left(\mathrm{tx}\right) = \mathrm{txid}$ on
      $\mathcal{G}_{\mathrm{Ledger}}$ and is a valid funding transaction}
        \State $G \leftarrow G \cup \left(\left\{\mathrm{pid}_{Charlie},
        \mathrm{pid}_{Dave}\right\}, \left\{\left(\mathrm{txid},
        \left(\mathrm{pid}_{Charlie}, \bot\right), \left(\mathrm{pid}_{Dave},
        \bot\right)\right)\right\}\right)$ \Comment{State of channel unknown, thus
        balances are $\bot$}
      \EndIf
    \State
    \State Upon receiving (\texttt{closedChannel}, txid) from $Bob$:
      \If{there exists a tx with $\mathcal{H}\left(\mathrm{tx}\right) = \mathrm{txid}$ on
      $\mathcal{G}_{\mathrm{Ledger}}$ that closes a funding tx' that corresponds to edge
      $e$ in $G$}
        \State $G \leftarrow G \setminus \left\{e\right\}$
      \EndIf
    \State
    \State Upon receiving (\texttt{pay}, $Bob$, $x$) from $\mathcal{E}$:
      \State Send (\texttt{SendInvoice}, $x$) to $Bob$
      \State Wait for response (\texttt{invoice}, $x$, hash) from $Bob$:
      \If{$\exists e := \left(\mathrm{txid}, \left(\mathrm{pid}_{Alice},
      y\right), \left(\mathrm{pid}_{Bob}, z\right)\right) \in G: y \geq x$}
        \State Update $e$ to $e' := \left(\mathrm{txid},
        \left(\mathrm{pid}_{Alice}, y - x\right),
        \left(\mathrm{pid}_{Bob}, z + x\right)\right)$ \Comment{Primitive
        for Update}
      \ElsIf{there is an $\left(Alice, Charlie, \dots, Bob\right)$ path in $G$ where the
      first hop is of weight at least $x$}
        \State Send a Sphinx~\cite{sphinx} message with the correct HTLCs (containing
        hash) for $Bob$
        \State \Comment{Sane fees and timeouts as requested by each hop}
        \State Wait for (preimage) from $Charlie$
        \If{$\mathcal{H}\left(\mathrm{preimage}\right) = \mathrm{hash}$}
          \State Let $e := \left(\mathrm{txid}, \left(\mathrm{pid}_{Alice}, y\right),
          \left(\mathrm{pid}_{Charlie}, z\right)\right)$ $Alice$'s channel with $Charlie$
          \State Update $e$ to pay $Charlie$ $x$ \Comment{use HTLC primitive}
          \State $G \leftarrow G \setminus \left\{e\right\}$
          \State $G \leftarrow G \cup \left\{\left(\mathrm{txid},
          \left(\mathrm{pid}_{Alice}, y - x\right), \left(\mathrm{pid}_{Charlie}, z +
          x\right)\right)\right\}$
          \State Send (\texttt{paymentSent}, $Bob$, $x$) to $\mathcal{E}$
        \Else
          \State Send (\texttt{paymentFailed}, $Bob$, $x$) to $\mathcal{E}$
        \EndIf
      \Else
        \State Send (\texttt{noPath}, $Bob$, $x$) to $\mathcal{E}$
      \EndIf
    \State
    \State Upon receiving (\texttt{SendInvoice}, $x$) from $Bob$:
      \State $\mathrm{preimage} \overset{r}{\leftarrow}
      \left\{0,1\right\}^{\mathrm{gazillion}}$
      \State $\mathrm{hash} \leftarrow \mathcal{H}\left(\mathrm{preimage}\right)$
      \State Send (\texttt{invoice}, $x$, hash) to $Bob$
      \State Wait for update of any channel $e := \left(\mathrm{txid},
      \left(\mathrm{pid}_{Alice}, y\right), \left(\mathrm{pid}_{Charlie}, z\right)\right)$
      to $e' := \left(\mathrm{txid}, \left(\mathrm{pid}_{Alice}, y + x\right),
      \left(\mathrm{pid}_{Charlie}, z - x\right)\right)$ conditional on $Alice$'s
      knowledge of the preimage of the hash
      \State Send (\texttt{preimage}) to $Charlie$
      \State Wait for update of $e'$ to $e'' := \left(\mathrm{txid},
      \left(\mathrm{pid}_{Alice}, y + x\right), \left(\mathrm{pid}_{Charlie}, z -
      x\right)\right)$ unconditional
      \If{$Charlie$ does not update the channel to $e''$}
        \State Settle $e'$ on-chain with the preimage and take $x$ from the HTLC provided
        by $Charlie$
      \EndIf
      \State Send (\texttt{paymentReceived}, $Bob$, $x$) to $\mathcal{E}$
    \State
    \State Upon receiving (\texttt{close}, id) from $Alice$:
      \If{$\mathcal{G}_{Ledger}$ has a valid funding tx with
      $\mathcal{H}\left(\mathrm{tx}\right) = \mathrm{id}$}
        \State Try to close cooperatively \Comment{TODO}
        \If{cooperative closing fails} \Comment{TODO}
          \State Close unilaterally \Comment{TODO}
        \EndIf
      \EndIf
  \end{algorithmic}
\hrulefill
\ \\ \noindent {Connection with $\mathcal{F}_{\mathrm{Ledger}}$}
  \label{alg:temp:formalfledger}
  \begin{algorithmic}[1]
    \State $\mathcal{F}_{\mathrm{Ledger}}\mathrm{.balance}\left(Alice\right)$:
    \State
    \State Send (\texttt{READ}, pid) to $\mathcal{F}_{\mathrm{Ledger}}$ \Comment{Whose
    pid? List is not created by Alice}
    \State Wait for response $\mathrm{state}_{pid}$
    \State Find \texttt{list} of txs in UTXO spendable by $Alice$ (using
    $\mathrm{Dec}\left(\mathrm{state}_{pid}\right)$) \Comment{blockify() is system
    parameter, how to better specify above?}
    \State \Return sum of outputs in \texttt{list} spendable by $Alice$ \Comment{Only
    P2WPKH? Or any kind (e.g. multisigs, funding txs)?}
    \State
    \State
    \State Send (\texttt{pay}, $Alice$, $Bob$, $x$) to $\mathcal{F}_{\mathrm{Ledger}}$:
    \State
    \State Create and sign transaction \texttt{tx} that pays $x$ from $Alice$ to $Bob$
    \Comment{Clear enough? How to sign? Is signature needed?}
    \State Send (\texttt{SUBMIT}, $pid_{Alice}$ \texttt{tx}) to
    $\mathcal{F}_{\mathrm{Ledger}}$
  \end{algorithmic}
\hrulefill
