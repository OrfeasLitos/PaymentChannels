\ \\ \noindent {$\Pi_{\mathrm{LN}}$}
  \label{alg:lightningprot}
  \begin{algorithmic}[1]
    \State Initialisation:
    \Indent
      \State $\mathtt{pending} \gets \emptyset$
      \State $\mathtt{channels} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, \mathrm{pid}_{Alice},
    \mathrm{pid}_{Bob}, x, y, \mathrm{AliceDelay}, \mathrm{forFundTX}\right)$
    from $\mathcal{E}$ (self is $Alice$):
    \Indent
      \State ensure that forFundTX has inputs spendable by $Alice$ of total
      value at least $x$ and by $Bob$ of total value at least $y$
      \State ensure that it is possible to add a $x + y$-valued output to
      forFundTX
      \State \Comment{TODO: [Both funding] changes protocol start from [adding
      an output to given tx] to [creating an entirely new tx] after key
      negotiation}
      \State ensure that there is no $\left(Alice, Bob, \dots\right)$
      in \texttt{pending}
      \State choose unique temporary ID tempid
      \State $\left(\left(pa_F, sa_F\right), \left(pa_{\mathrm{pay}},
      sa_{\mathrm{pay}}\right), \left(pa_{\mathrm{dpay}},
      sa_{\mathrm{dpay}}\right), \left(pa_{\mathrm{htlc}},
      sa_{\mathrm{htlc}}\right), \left(pa_{\mathrm{com}1},
      sa_{\mathrm{com}1}\right),\right.$ $\left.\left(pa_{\mathrm{rev}},
      sa_{\mathrm{rev}}\right)\right) \gets \textsc{GetKeys}\left(\right)$
      \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
      \mathrm{forFundTX}, \left(pa_F, sa_F\right), \left(pa_{\mathrm{pay}},
      sa_{\mathrm{pay}}\right),\right.$ $\left.\left(pa_{\mathrm{dpay}},
      sa_{\mathrm{dpay}}\right), \left(pa_{\mathrm{htlc}},
      sa_{\mathrm{htlc}}\right), \left(pa_{\mathrm{com}1},
      sa_{\mathrm{com}1}\right),\right.$ $\left.\left(pa_{\mathrm{rev}},
      sa_{\mathrm{rev}}\right), \mathrm{tempid}\right)$ to \texttt{pending}
      \State Send (\textsc{openChannel}, $x, y$, AliceDelay, bcast, $pa_F,
      pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
      pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$, tempid) to $Bob$
    \EndIndent
    \State

    \State Upon receiving (\textsc{openChannel}, $x, y$, AliceDelay, bcast,
    $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
    pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$, tempid) from $Alice$ (self is
    $Bob$):
    \Indent
      \State ensure that there is no $\left(\dots, \mathrm{tempid}\right)$ in
      \texttt{pending}
      \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay}, \mathrm{bcast},
      pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
      pa_{\mathrm{com}1}, pa_{\mathrm{rev}}, \mathrm{tempid}\right)$ to
      \texttt{pending}
      \State Send (\textsc{endorseChannel}, $\mathrm{pid}_{Alice},
      \mathrm{pid}_{Bob}, x, y$, AliceDelay, bcast, tempid) to $\mathcal{E}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{endorseChannel}, \mathrm{pid}_{Alice},
    \mathrm{pid}_{Bob}, x, y, \mathrm{BobDelay}, \mathrm{tempid}\right)$ from
    $\mathcal{E}$ (self is $Bob$)
    \Indent
      \State ensure that there is a unique $\left(\dots, \mathrm{tempid}\right)$
      entry in \texttt{pending} with elements as should be after handling an
      \textsc{openChannel} message from $Alice$
      \State $\left(\left(pb_F, sb_F\right), \left(pb_\mathrm{pay},
      sb_\mathrm{pay}\right), \left(pb_\mathrm{dpay}, sb_\mathrm{dpay}\right),
      \left(pb_\mathrm{htlc}, sb_\mathrm{htlc}\right),\right.$
      \State $\left.\left(pb_\mathrm{com}1, sb_\mathrm{com}1\right),
      \left(pb_\mathrm{rev}, sb_\mathrm{rev}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$
      \State add generated keys to \texttt{pending} entry
      \State Send (\texttt{acceptChannel}, BobDelay, $pb_F,
      pb_{\mathrm{pay}}, pb_{\mathrm{dpay}}, pb_{\mathrm{htlc}},
      pb_{\mathrm{com}1}, pb_{\mathrm{rev}}$, tempid) to $Alice$
    \EndIndent
    \State

    \State Upon receiving (\textsc{acceptChannel}, BobDelay, $pb_F,
    pb_{\mathrm{pay}}, pb_{\mathrm{dpay}}, pb_{\mathrm{htlc}},
    pb_{\mathrm{com}1}, pb_{\mathrm{rev}}$, tempid) from $Bob$ (self is
    $Alice$):
    \Indent
      \State ensure that there is a unique $\left(\dots, \mathrm{tempid}\right)$
      entry in \texttt{pending} with elements as should be after handling an
      \textsc{openChannel} message from $\mathcal{E}$
      \State retrieve elements of entry
      \State add output $\left(pa_F \wedge pb_F\right)$ to forFundTX and assign
      result to $F$
      \State let idx be the position of the output in the transaction
      \State $\mathrm{chid} \gets \mathcal{H}\left(F\right) \oplus \mathrm{idx}$
      \Comment{This is how chid is derived in LND}
      \State $\mathrm{AliceSig} \gets \mathrm{sign}\left(F, sa_F\right)$
      \State Send (\texttt{fundingCreated}, tempid, $\mathcal{H}\left(F\right)$,
      idx, AliceSig) to $Bob$
    \EndIndent
    \State

      \State assert(response = (\texttt{fundingSigned}, chid, sig)
      \Indent
        \State $\And \textsc{isValid2-of-2Sig}\left(\mathrm{sig},
        \textsc{GetCommitment}\left(\right.\right.$
        \State $\left.\left.\mathcal{H}\left(F\right),\mathrm{idx}, pa_{pay},
        pb_{pay}\right), 0\right)$) TODO: may change
      \EndIndent
      \State $\mathcal{F}_{\mathrm{Ledger}}.\mathrm{Broadcast}\left(F\right)$
      \State Wait for minDepth confirmations on $F$
      \State $\left(pa_{\mathrm{com}2}, sa_{\mathrm{com}2}\right) \gets
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$
      \State In parallel:
      \Indent
        \State Send (\texttt{fundingLocked}, chid, $pa_{\mathrm{com}2}$) to
        fundee
        \State assert(response = (\texttt{fundingLocked}, chid,
        $pb_{\mathrm{com}2}$) $\And$
        \Indent
          \State $\mathcal{F}_{\mathrm{Wallet}}.\mathrm{isValidPubKey}
          \left(pb_{\mathrm{com}2}\right)$)
        \EndIndent
      \EndIndent
      \State \Return ($\mathcal{H}\left(F\right)$, chid, True)
    \EndFunction
    \State
    \Function{GetKeys}{}
      \State $\left(pa_F, sa_F\right) \gets \mathrm{genKey}\left(\right)$
      \Comment{For $F$ output}
      \State $\left(pa_{\mathrm{pay}}, sa_{\mathrm{pay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to remote}
      \State $\left(pa_{\mathrm{dpay}}, sa_{\mathrm{dpay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to self}
      \State $\left(pa_{\mathrm{htlc}}, sa_{\mathrm{htlc}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For htlc output to self}
      \State $\left(pa_{\mathrm{com}1}, sa_{\mathrm{com}1}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For deriving all keys}
      \State $\left(pa_{\mathrm{rev}}, sa_{\mathrm{rev}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For revocation in com}
      \State \Return $\left(\left(pa_F, sa_F\right), \left(pa_{\mathrm{pay}},
      sa_{\mathrm{pay}}\right), \left(pa_{\mathrm{dpay}},
      sa_{\mathrm{dpay}}\right),\right.$
      \Indent
        \State $\left.\left(pa_{\mathrm{htlc}}, sa_{\mathrm{htlc}}\right),
        \left(pa_{\mathrm{com}1}, sa_{\mathrm{com}1}\right),
        \left(pa_{\mathrm{rev}}, sa_{\mathrm{rev}}\right)\right)$
      \EndIndent
    \EndFunction
    \State

    \Function{GetFunding}{$x, sa_F, pa_F, pb_F, Alice$} \Comment{w/o
    forFundTX, w/ Alice}
      \State $\mathtt{tx} \gets
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{getTX}\left(Alice, x\right)$
      \Comment{$Alice$ can add a $x$-valued output and broadcast result}
      \State $\mathtt{witnessScript} \gets \text{"2 "} \Vert pa_F \Vert \text{"
      "} \Vert pb_F \Vert \text{" 2 \texttt{OP\_CHECKMULTISIG}"}$
      \State \texttt{sPK} $\gets \text{"0 "} \Vert
      \textsc{SHA256}\left(\mathtt{witnessScript}\right)$
      \State $\left(F, \mathrm{idx}\right) \gets
      \mathtt{tx}$.\textsc{addOutput}(\{scriptPubKey: \texttt{sPK}, value:
      $x$\})
      \State $\mathtt{commitment} \gets \textsc{Commitment}\left(TODO\right)$
      \State $\mathrm{sig} \gets
      \mathcal{F}_{\mathrm{Wallet}}.\textsc{Sign}\left(\mathtt{commitment},
      sa_F\right)$ \Comment{TODO: continue (add inputs here)}
      \State \Return $\left(F, \mathrm{idx}, \mathrm{sig}\right)$
    \EndFunction
    \State

    \Function{GetFunding}{coins, tx, $sa_F, pa_F, pb_F$}
      \State $\left(F, \mathrm{idx}\right) \gets
      \mathcal{F}_{\mathrm{Wallet}}$.addOutputToTX(tx, 2-of-2-msig$\left(pa_F,
      pb_F, \mathrm{coins}\right)$)
      \State $\mathrm{sig} \gets
      \mathcal{F}_{\mathrm{Wallet}}.\textsc{Sign}\left(\mathcal{H}\left(F\right),
      \mathrm{idx}, sa_F\right)$
      \State \Return $\left(F, \mathrm{idx}, \mathrm{sig}\right)$
    \EndFunction
    \State
    \State Upon receiving (\texttt{openChannel}, coins, remoteDelay, bcast,
    \Indent
      \Indent
        \State $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
        pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$) from $Bob$:
      \EndIndent
    \EndIndent
    \Indent
      \State Send (\texttt{recvOpen}, $\mathrm{pid}_{Bob}$, coins, remoteDelay,
      bcast,
      \Indent
        \Indent
          \State $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}},
          pa_{\mathrm{htlc}}, pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$) to
          $\mathcal{E}$:
        \EndIndent
      \EndIndent
      \State Wait for response from $\mathcal{E}$
      \State assert(response = (\texttt{acceptChannel}, minDepth, selfDelay))
      \State $\left(\mathrm{txid}, \mathrm{chid}, \mathrm{success}\right) \gets
      \textsc{AcceptChannel}$(funder, coins, selfDelay,
      \Indent
        \Indent
          \State remoteDelay, bcast, minDepth,
          \State $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}},
          pa_{\mathrm{htlc}}, pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$)
        \EndIndent
      \EndIndent
      \If{success = True}
        \State add $\left(\mathrm{pid}_{Alice}, \mathrm{pid_{Bob}}, 0,
        \mathrm{coins}, \mathrm{chid}, \mathrm{txid}\right)$ to
        \texttt{channels}
        \Comment{TODO: add delay, bcast}
        \State Send $\left(\mathtt{accepted}, \mathrm{pid}_{Alice},
        \mathrm{pid}_{Bob}, \mathrm{coins}, \mathrm{delay}, \mathrm{bcast},
        \mathrm{txid}, \mathrm{chid}\right)$
        \Indent
          \Indent
            \State to $\mathcal{E}$
          \EndIndent
        \EndIndent
      \Else
        \State Send $\left(\mathtt{notAccepted}, \mathrm{pid}_{Alice},
        \mathrm{pid}_{Bob}, \mathrm{coins}, \mathrm{delay},
        \mathrm{bcast}\right)$ to $\mathcal{E}$
      \EndIf
    \EndIndent
    \State

    \Function{AcceptChannel}{funder, coins, selfDelay, remoteDelay, bcast,
    minDepth, $pa_F, pa_{\mathrm{pay}}, pa_{\mathrm{dpay}}, pa_{\mathrm{htlc}},
    pa_{\mathrm{com}1}, pa_{\mathrm{rev}}$}
      \State assert($\forall i \in \left\{\mathrm{pay}, \mathrm{dpay},
      \mathrm{htlc}, \mathrm{com}1, \mathrm{rev}\right\},
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{isValidPubKey}\left(pa_i\right)$)
      \State $\left(\left(pb_F, sb_F\right), \left(pb_\mathrm{pay},
      sb_\mathrm{pay}\right), \left(pb_\mathrm{dpay}, sb_\mathrm{dpay}\right),
      \left(pb_\mathrm{htlc}, sb_\mathrm{htlc}\right),\right.$
      \State $\left.\left(pb_\mathrm{com}1, sb_\mathrm{com}1\right),
      \left(pb_\mathrm{rev}, sb_\mathrm{rev}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$
      \State Send (\texttt{acceptChannel}, minDepth, selfDelay,
      \Indent
        \Indent
          \State $pb_F, pb_{\mathrm{pay}}, pb_{\mathrm{dpay}},
          pb_{\mathrm{htlc}}, pb_{\mathrm{com}1}, pb_{\mathrm{rev}}$) to funder
        \EndIndent
      \EndIndent

      \State assert(response = (\texttt{fundingCreated}, txid, idx, sig) $\And$
      \textsc{isValid2-of-2Sig}(sig, \textsc{GetCommitment}(txid, idx,
      $pa_{\mathrm{pay}}, pb_{\mathrm{pay}}$), 1)) TODO: may change
      \State $\mathrm{chid} \gets \mathrm{txid} \oplus \mathrm{idx}$
      \State $\mathrm{sig} \gets
      \mathcal{F}_{\mathrm{Wallet}}.\textsc{Sign}\left(\mathrm{txid},
      \mathrm{idx}, sb_F\right)$
      \State Send (\texttt{fundingSigned}, chid, sig) to funder
      \State Wait for minDepth confirmations on tx with id txid
      \State $\left(pb_{\mathrm{com}2}, sb_{\mathrm{com}2}\right) \gets
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$
      \State In parallel:
      \Indent
        \State Send (\texttt{fundingLocked}, chid, $pb_{\mathrm{com}2}$) to
        funder
        \State assert(response = (\texttt{fundingLocked}, chid,
        $pa_{\mathrm{com}2}$) $\And$
        \Indent
          \State $\mathcal{F}_{\mathrm{Wallet}}.\mathrm{isValidPubKey}
          \left(pa_{\mathrm{com}2}\right)$)
        \EndIndent
      \EndIndent
      \State \Return (txid, chid, True)
    \EndFunction
    \State

    \State TODO: 2-of-2-msig(), GetCommitment()
    \State TODO: use basepoints instead of pubkeys (x2)
    \State TODO: Change GetFunding
    \State

    \State Upon receiving (\texttt{pay}, $Bob$, $x$,
    $\overrightarrow{\mathtt{path}}$, \texttt{receipt}) from $\mathcal{E}$:
      \State Send (\texttt{SendInvoice}, $x$) to $Bob$
      \State Wait for response (\texttt{invoice}, $x$, hash) from $Bob$:
      \Indent
        \State CONDITIONS FROM PAYNET START
        \State condition 1: $\overrightarrow{\mathtt{path}}$ consists of players
        where for every adjacent $\left(Carol, Dave\right)$ pair there is a
        $\mathtt{receipt}'$ in \texttt{channels} with $Carol$ and $Dave$ and
        where $Carol$ has at least $x$. Also, $\mathtt{receipt}'$ corresponds to
        (has the same chid with) an unclosed \textsc{open-channel} transaction
        that exists both in $\mathtt{state}_{Carol}$ and $\mathtt{state}_{Dave}$
        (i.e. there is no \textsc{close-channel} transaction with a receipt with
        the same chid in either state)
        \State condition 2: \texttt{receipt} is in \texttt{channels} and
        contains $Alice$ with at least $x$ coins.
        \State CONDITIONS FROM PAYNET END
      \EndIndent
      \If{no hops}
      \Comment{TODO: code htlc hops, here is old: $\exists e :=
      \left(\mathrm{txid}, \left(\mathrm{pid}_{Alice}, y\right),
      \left(\mathrm{pid}_{Bob}, z\right)\right) \in \mathtt{channels}: y \geq
      x$}
        \State Update $e$ to $e' := \left(\mathrm{txid},
        \left(\mathrm{pid}_{Alice}, y - x\right),
        \left(\mathrm{pid}_{Bob}, z + x\right)\right)$ \Comment{Primitive
        for Update, make same with conditions}
      \ElsIf{hops}
        \State Send a Sphinx~\cite{sphinx} message with the correct HTLCs
        (containing hash) for $Bob$
        \State \Comment{Sane fees and timeouts as requested by each hop}
        \State Wait for (preimage) from $Charlie$
        \If{$\mathcal{H}\left(\mathrm{preimage}\right) = \mathrm{hash}$}
          \State Let $e := \left(\mathrm{txid}, \left(\mathrm{pid}_{Alice},
          y\right), \left(\mathrm{pid}_{Charlie}, z\right)\right)$ $Alice$'s
          channel with $Charlie$
          \State Update $e$ to pay $Charlie$ $x$ \Comment{use HTLC primitive}
          \State $\mathtt{channels} \gets \mathtt{channels} \setminus
          \left\{e\right\}$
          \State $\mathtt{channels} \gets \mathtt{channels} \cup
          \left\{\left(\mathrm{txid},
          \left(\mathrm{pid}_{Alice}, y - x\right),
          \left(\mathrm{pid}_{Charlie}, z + x\right)\right)\right\}$
          \State Send (\texttt{paymentSent}, $Bob$, $x$) to $\mathcal{E}$
        \Else
          \State Send (\texttt{paymentFailed}, $Bob$, $x$) to $\mathcal{E}$
        \EndIf
      \Else \Comment{Invalid payment}
        \State Send (\texttt{noPath}, $Bob$, $x$) to $\mathcal{E}$
      \EndIf
    \State
    \State Upon receiving (\texttt{SendInvoice}, $x$) from $Bob$:
      \State $\mathrm{preimage} \overset{r}{\gets}
      \left\{0,1\right\}^{\mathrm{gazillion}}$
      \State $\mathrm{hash} \gets \mathcal{H}\left(\mathrm{preimage}\right)$
      \State Send (\texttt{invoice}, $x$, hash) to $Bob$
      \State Wait for update of any channel $e := \left(\mathrm{txid},
      \left(\mathrm{pid}_{Alice}, y\right), \left(\mathrm{pid}_{Charlie},
      z\right)\right)$ to $e' := \left(\mathrm{txid},
      \left(\mathrm{pid}_{Alice}, y + x\right), \left(\mathrm{pid}_{Charlie}, z
      - x\right)\right)$ conditional on $Alice$'s knowledge of the preimage of
      the hash
      \State Send (\texttt{preimage}) to $Charlie$
      \State Wait for update of $e'$ to $e'' := \left(\mathrm{txid},
      \left(\mathrm{pid}_{Alice}, y + x\right), \left(\mathrm{pid}_{Charlie}, z
      - x\right)\right)$ unconditional
      \If{$Charlie$ does not update the channel to $e''$}
        \State Settle $e'$ on-chain with the preimage and take $x$ from the HTLC
        provided by $Charlie$
      \EndIf
      \State Send (\texttt{paymentReceived}, $Bob$, $x$) to $\mathcal{E}$
    \State
    \State Upon receiving (\texttt{close}, chid) from $Alice$:
      \If{$\mathcal{G}_{Ledger}$ has a valid funding tx with
      $\mathcal{H}\left(\mathrm{tx}\right) = \mathrm{chid}$}
        \State Try to close cooperatively \Comment{TODO}
        \If{cooperative closing fails} \Comment{TODO}
          \State Close unilaterally \Comment{TODO}
        \EndIf
      \EndIf
  \end{algorithmic}
\hrulefill
