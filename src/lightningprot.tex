\ \\ \noindent {$\Pi_{\mathrm{LN}}$} (self is \alice)
  \label{alg:lightningprot}
  \begin{algorithmic}[1]
    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{pendingOpen}, \mathtt{pendingPay},
      \mathtt{pendingClose}, \mathtt{newChannels},$ $\mathtt{closedChannels},
      \mathtt{unclaimedRemoteHTLCs} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving (\textsc{register}, delay) from \environment:
    \Indent
      \State $\mathtt{delay} \gets \mathrm{delay}$
      \State send (\textsc{read}) to $\clock$ and assign reply to
      \texttt{lastPoll}
      \State $\left(pk_{\alice}, sk_{\alice}\right) \gets
      \mathrm{genKey}\left(\right)$
      \State send (\textsc{register}, \alice, \texttt{delay},
      $pk_{\alice}$) to \adversary \orfeas{delay to \adversary{}
      needed?}
    \EndIndent
    \State

    \State Upon receiving (\textsc{registered}) from \adversary:
    \Indent
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State assign the sum of all output values that are exclusively spendable
      by \alice{} to \texttt{onChainBalance}
      \State send (\textsc{registered}) to \environment
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$:
    \Indent
      \If{if haven't received (\textsc{register}) from \environment{}}
        \State ignore message
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, \mathrm{pid}_{\alice},
    \mathrm{pid}_{\bob}, x\right)$ from \environment:
    \Indent
      \State $\left(\left(ph_F, sh_F\right),
      \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},
      sh\_\mathrm{base}_{\mathrm{dpay}}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right), \left(ph_{\mathrm{com}1},
      sh_{\mathrm{com}1}\right), \left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$ \orfeas{TODO: change font}
      \State choose unique temporary ID \textit{tid} \Comment{unique for the two
      parties}
      \State associate keys with \textit{tid}
      \State add $\left(\alice, \bob, x, \mathtt{delay}, \left(ph_F,
      sh_F\right), \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},\right.\right.$
      $\left.\left.sh\_\mathrm{base}_{\mathrm{dpay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{com}1},
      sh\_\mathrm{base}_{\mathrm{com}1}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right), \mathit{tid}\right)$ to
      \texttt{pendingOpen}
      \State send (\textsc{openChannel}, $x$, \texttt{delay}, $ph_F,
      ph\_\mathrm{base}_{\mathrm{pay}}, ph\_\mathrm{base}_{\mathrm{dpay}},
      ph\_\mathrm{base}_{\mathrm{htlc}},$ $ph_{\mathrm{com}1},
      ph\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{openChannel}, $x$, BobDelay, $pt_F,
    pt\_\mathrm{base}_{\mathrm{pay}}, pt\_\mathrm{base}_{\mathrm{dpay}},$
    $pt\_\mathrm{base}_{\mathrm{htlc}}, pt_{\mathrm{com}1},
    pt\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) from \bob:
    \Indent
      \State ensure \textit{tid} has not been used yet with \bob
      \State $\left(\left(ph_F, sh_F\right),
      \left(ph\_\mathrm{base}_{\mathrm{pay}},
      sh\_\mathrm{base}_{\mathrm{pay}}\right),
      \left(ph\_\mathrm{base}_{\mathrm{dpay}},
      sh\_\mathrm{base}_{\mathrm{dpay}}\right),\right.$
      $\left.\left(ph\_\mathrm{base}_{\mathrm{htlc}},
      sh\_\mathrm{base}_{\mathrm{htlc}}\right),
      \left(ph_{\mathrm{com}1}, sh_{\mathrm{com}1}\right),
      \left(ph\_\mathrm{base}_{\mathrm{rev}},
      sh\_\mathrm{base}_{\mathrm{rev}}\right)\right) \gets
      \textsc{GetKeys}\left(\right)$ \orfeas{TODO: change font}
      \State associate keys with \textit{tid} and store in \texttt{pendingOpen}
      \State send (\textsc{acceptChannel}, \texttt{delay}, $ph_F,
      ph\_\mathrm{base}_{\mathrm{pay}}, ph\_\mathrm{base}_{\mathrm{dpay}},
      ph\_\mathrm{base}_{\mathrm{htlc}},$ $ph_{\mathrm{com}1},
      ph\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{acceptChannel}, \texttt{delay}, $pt_F,
    pt\_\mathrm{base}_{\mathrm{pay}}, pt\_\mathrm{base}_{\mathrm{dpay}},$
    $pt\_\mathrm{base}_{\mathrm{htlc}},$ $pt_{\mathrm{com}1},
    pt\_\mathrm{base}_{\mathrm{rev}}$, \textit{tid}) from \bob:
    \Indent
      \State ensure there is a temporary ID \textit{tid} with \bob{} in
      \texttt{pendingOpen} on which \textsc{acceptChannel} hasn't been received
      \State associate received keys with \textit{tid}
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State assign to \texttt{prevout} a transaction output found in
      $\Sigma_{\alice}$ that is currently exclusively spendable by \alice{} and
      has value $y \geq x$
      \State $F \gets$ TX \{input spends prevout with a \texttt{signature}(TX,
      $sk_{\alice}$), output 0 pays $y - x$ to $pk_{\alice}$ now, output 1 pays
      $x$ to $\textit{tid}.ph_F \wedge pt_F$ now\}
      \State $\mathit{pchid} \gets \mathcal{H}\left(F\right)$
      \State replace \textit{tid} with \textit{pchid} in storage
      \State $pt_{\mathrm{rev}} \gets pt\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(pt\_\mathrm{base}_{\mathrm{rev}} ||
      pt_{\mathrm{com}1}\right) + pt_{\mathrm{com}1} \cdot \mathcal{H}\left(
      pt_{\mathrm{com}1} || pt\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $ph_{\mathrm{dpay}} \gets ph\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(ph_{\mathrm{com}1} ||
      ph\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $ph_{\mathrm{pay}} \gets ph\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(ph_{\mathrm{com}1} ||
      ph\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $\mathtt{remoteCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, ph_{\mathrm{pay}}\right)$\}
      \State $\mathtt{localCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, pt_{\mathrm{rev}} \vee \left(ph_{\mathrm{dpay}}, \mathtt{delay}
      \text{ relative}\right)\right)$ \orfeas{check delays}
      \State add $\mathtt{remoteCom}_1$ and $\mathtt{localCom}_1$ to channel
      entry in \texttt{pendingOpen}
      \State $\mathrm{AliceSig} \gets
      \mathtt{signature}\left(\mathtt{remoteCom}_1, sh_F\right)$
      \State send (\textsc{fundingCreated}, \textit{tid},
      \textit{pchid}, AliceSig) to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingCreated}, \textit{tid},
    \textit{pchid}, $\mathtt{BobSig}_1$) from \bob:
    \Indent
      \State ensure there is a temporary ID \textit{tid} with \bob{} in
      \texttt{pendingOpen} on which we have sent up to \textsc{acceptChannel}
      \State $ph_{\mathrm{rev}} \gets ph\_\mathrm{base}_{\mathrm{rev}} \cdot
      \mathcal{H}\left(ph\_\mathrm{base}_{\mathrm{rev}} ||
      ph_{\mathrm{com}1}\right) + ph_{\mathrm{com}1} \cdot \mathcal{H}\left(
      ph_{\mathrm{com}1} || ph\_\mathrm{base}_{\mathrm{rev}}\right)$
      \State $pt_{\mathrm{dpay}} \gets pt\_\mathrm{base}_{\mathrm{dpay}} +
      \mathcal{H}\left(pt_{\mathrm{com}1} ||
      pt\_\mathrm{base}_{\mathrm{dpay}}\right)$
      \State $pt_{\mathrm{pay}} \gets pt\_\mathrm{base}_{\mathrm{pay}} +
      \mathcal{H}\left(pt_{\mathrm{com}1} ||
      pt\_\mathrm{base}_{\mathrm{pay}}\right)$
      \State $\mathtt{localCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, pt_{\mathrm{pay}}\right)$\}
      \State ensure $\mathtt{Verify}\left(\mathtt{localCom}_1,
      \mathtt{BobSig}_1, pt_F\right) = \mathtt{True}$
      \State $\mathtt{remoteCom}_1 \gets$ TX \{input: output 1 of $F$, output:
      $\left(x, ph_{\mathrm{rev}} \vee \left(pt_{\mathrm{dpay}}, \mathtt{delay}
      \text{ relative}\right)\right)$ \orfeas{check delays}
      \State add $\mathtt{BobSig}_1, \mathtt{remoteCom}_1$ and
      $\mathtt{localCom}_1$ to channel entry in \texttt{pendingOpen}
      \State $\mathrm{AliceSig} \gets
      \mathtt{signature}\left(\mathrm{remoteCom}_1, sh_F\right)$
      \State mark channel as ``broadcast''
      \State send (\textsc{fundingSigned}, \textit{pchid}, AliceSig) to \bob
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingSigned}, \textit{pchid},
    $\mathtt{BobSig}_1$) from \bob:
    \Indent
      \State ensure there is a channel ID \textit{pchid} with \bob{} in
      \texttt{pendingOpen} on which we have sent up to \textsc{fundingCreated}
      \State ensure $\mathtt{Verify}\left(\mathtt{localCom}_1,
      \mathtt{BobSig}_1, pb_F\right) = \mathtt{True}$
      \State add $\mathtt{BobSig}_1$ to channel entry in \texttt{pendingOpen}
      \State $\mathrm{sig} \gets \mathtt{signature}\left(F,
      sk_{\mathit{Alice}}\right)$
      \State mark \textit{pchid} in \texttt{pendingOpen} as ``broadcast''
      \State send (\textsc{submit}, $\left(\mathrm{sig}, F\right)$) to \ledger
    \EndIndent
    \State

    \Function{GetKeys}{} \orfeas{TODO: change font}
      \State $\left(p_F, s_F\right) \gets \mathrm{genKey}\left(\right)$
      \Comment{For $F$ output}
      \State $\left(p_{\mathrm{pay}}, s_{\mathrm{pay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to remote}
      \State $\left(p_{\mathrm{dpay}}, s_{\mathrm{dpay}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For com output to self}
      \State $\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For htlc output to self}
      \State $\left(p_{\mathrm{com}1}, s_{\mathrm{com}1}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For deriving all keys}
      \State $\left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right) \gets
      \mathrm{genKey}\left(\right)$ \Comment{For revocation in com}
      \State \Return $\left(\left(p_F, s_F\right), \left(p_{\mathrm{pay}},
      s_{\mathrm{pay}}\right), \left(p_{\mathrm{dpay}},
      s_{\mathrm{dpay}}\right),\right.$
      \Indent
        \State $\left.\left(p_{\mathrm{htlc}}, s_{\mathrm{htlc}}\right),
        \left(p_{\mathrm{com}1}, s_{\mathrm{com}1}\right),
        \left(p_{\mathrm{rev}}, s_{\mathrm{rev}}\right)\right)$
      \EndIndent
    \EndFunction
    \State

    \State Upon receiving (\textsc{poll}) from \environment:
    \Indent
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \ForAll{$\tau \in \mathtt{unclaimedRemoteHTLCs}$}
        \If{input of $\tau$ has been spent} \Comment{by
        \texttt{remoteHTLC-success}}
          \State remove $\tau$ from \texttt{unclaimedRemoteHTLCs}
        \ElsIf{input of $\tau$ has not been spent and timelock is over}
          \State send (\textsc{submit}, $\tau$) to \ledger \orfeas{proper way?}
        \EndIf
      \EndFor
      \ForAll{$\mathrm{TX} \in \Sigma_{\alice}$ that spend the funding tx of a
      $\mathtt{channel} \in \mathtt{channels}$ with $\mathtt{remoteCom}_n$}
        \If{$n =$ latest \texttt{channel} seq number} \Comment{Honest closure}
          \ForAll{received HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
            \State send (\textsc{submit},
            $\left(\mathtt{localSig}_{\mathrm{htlc}, n, i},
            \mathtt{remoteSig}_{\mathrm{htlc}, n, i}, \mathtt{HTLC-success}_{n,
            i}\right)$) to \ledger \orfeas{proper way?}
          \EndFor
          \ForAll{unspent offered HTLC outputs $i$ of $\mathtt{remoteCom}_n$}
            \If{timelock has not expired}
              \State add $\left(\mathtt{localSig}_{\mathrm{htlc}, n, i},
              \mathtt{remoteSig}_{\mathrm{htlc}, n, i},
              \mathtt{HTLC-timeout}_{n, i}\right)$ to
              \texttt{unclaimedRemoteHTLCs}
            \ElsIf{timelock has expired}
              \State send (\textsc{submit},
              $\left(\mathtt{localSig}_{\mathrm{htlc}, n, i},
              \mathtt{remoteSig}_{\mathrm{htlc}, n, i},
              \mathtt{HTLC-timeout}_{n, i}\right)$) to \ledger \orfeas{proper
              way?}
            \EndIf
          \EndFor
          \State move \texttt{channel} from \texttt{channels} to
          \texttt{closedChannels}
        \Else \Comment{$n <$ latest \texttt{channel} seq number, malicious
        closure}
          \State $\mathrm{rev} \gets$ TX \{inputs: all $\mathtt{remoteCom}_n$
          outputs, choosing $ph_{\mathrm{rev}, n}$ method, output:
          $pk_{\mathit{Alice}}$\} \orfeas{TODO:
          generate all new keys in \textsc{pay}}
          \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathrm{rev},
          sh_{\mathrm{rev}, n}\right)$
          \State send (\textsc{submit}, $\left(\mathrm{sig},
          \mathrm{rev}\right)$) to \ledger \orfeas{proper way?}
        \EndIf
      \EndFor
      \ForAll{$\mathrm{TX} \in \mathtt{pendingOpen}$ marked as ``broadcast''
      that are in $\Sigma_{\alice}$, are unspent, have ID \textit{pchid} and a
      $\left(x, ph_F \wedge pt_F\right)$ output}
        \State $\left(ph\_\mathrm{base}_{\mathrm{com}2},
        sh\_\mathrm{base}_{\mathrm{com}2}\right) \gets
        \mathrm{genKey}\left(\right)$
        % may be needed after splitting
        %\State mark TX in \texttt{pendingOpen} as ``waiting for
        %\textsc{fundingAck}''
        \State send (\textsc{fundingLocked}, \textit{pchid},
        $ph\_\mathrm{base}_{\mathrm{com}2}$) to \bob{} \orfeas{proper way?} and
        ensure reply from \bob{} is (\textsc{fundingAck}, \textit{pchid},
        $pt\_\mathrm{base}_{\mathrm{com}2}$)
        \State ensure $pt\_\mathrm{base}_{\mathrm{com}2}$ is a valid public key
        \State move TX and channel data from \texttt{pendingOpen} to
        \texttt{channels}
        \State add receipt of channel to \texttt{newChannels}
      \EndFor
      \State clear and send \texttt{newChannels}, \texttt{closedChannels},
      \texttt{updated} to \environment
    \EndIndent
    \State

    \State Upon receiving (\textsc{fundingLocked}, \textit{pchid},
    $pt\_\mathrm{base}_{\mathrm{com}2}$) from \bob:
    \Indent
      \State ensure there is a channel ID \textit{pchid} with \bob{} in
      \texttt{pendingOpen}, marked as ``broadcast''
      \State ensure $pt\_\mathrm{base}_{\mathrm{com}2}$ is a valid public key
      \State send (\textsc{read}) to \ledger{} and assign reply to
      $\Sigma_{\alice}$
      \State ensure $\exists \text{ unspent } \mathrm{TX} \in \Sigma_{\alice}$
      with ID \textit{pchid} and a $\left(x, ph_F \wedge pt_F\right)$ output
      \State $\left(ph\_\mathrm{base}_{\mathrm{com}2},
      sh\_\mathrm{base}_{\mathrm{com}2}\right) \gets
      \mathrm{genKey}\left(\right)$
      \State move TX and channel data from \texttt{pendingOpen} to
      \texttt{channels}
      \State add receipt of channel to \texttt{newChannels}
      \State send (\textsc{fundingAck}, \textit{pchid},
      $ph\_\mathrm{base}_{\mathrm{com}2}$) to \bob
    \EndIndent
    \State

    \State Upon receiving (\texttt{pay}, \textit{Bob}, $x$,
    $\overrightarrow{\mathtt{path}}$, \texttt{receipt}) from \environment:
    \orfeas{TODO}
      \State Send (\texttt{SendInvoice}, $x$) to \textit{Bob}
      \State Wait for response (\texttt{invoice}, $x$, hash) from \textit{Bob}:
      \Indent
        \State CONDITIONS FROM PAYNET START
        \State condition 1: $\overrightarrow{\mathtt{path}}$ consists of players
        where for every adjacent $\left(Carol, Dave\right)$ pair there is a
        $\mathtt{receipt}'$ in \texttt{channels} with $Carol$ and $Dave$ and
        where $Carol$ has at least $x$. Also, $\mathtt{receipt}'$ corresponds to
        (has the same chid with) an unclosed \textsc{open-channel} transaction
        that exists both in $\mathtt{state}_{Carol}$ and $\mathtt{state}_{Dave}$
        (i.e. there is no \textsc{close-channel} transaction with a receipt with
        the same chid in either state)
        \State condition 2: \texttt{receipt} is in \texttt{channels} and
        contains \textit{Alice} with at least $x$ coins.
        \State CONDITIONS FROM PAYNET END
      \EndIndent
      \If{no hops}
      \Comment{TODO: code htlc hops, here is old: $\exists e :=
      \left(\mathrm{txid}, \left(\mathrm{pid}_{\alice}, y\right),
      \left(\mathrm{pid}_{\bob}, z\right)\right) \in \mathtt{channels}: y \geq
      x$}
        \State Update $e$ to $e' := \left(\mathrm{txid},
        \left(\mathrm{pid}_{\alice}, y - x\right),
        \left(\mathrm{pid}_{\bob}, z + x\right)\right)$ \Comment{Primitive
        for Update, make same with conditions}
      \ElsIf{hops}
        \State Send a Sphinx~\cite{sphinx} message with the correct HTLCs
        (containing hash) for \textit{Bob}
        \State \Comment{Sane fees and timeouts as requested by each hop}
        \State Wait for (preimage) from $Charlie$
        \If{$\mathcal{H}\left(\mathrm{preimage}\right) = \mathrm{hash}$}
          \State Let $e := \left(\mathrm{txid}, \left(\mathrm{pid}_{\alice},
          y\right), \left(\mathrm{pid}_{Charlie}, z\right)\right)$ \textit{Alice}'s
          channel with $Charlie$
          \State Update $e$ to pay $Charlie$ $x$ \Comment{use HTLC primitive}
          \State $\mathtt{channels} \gets \mathtt{channels} \setminus
          \left\{e\right\}$
          \State $\mathtt{channels} \gets \mathtt{channels} \cup
          \left\{\left(\mathrm{txid},
          \left(\mathrm{pid}_{\alice}, y - x\right),
          \left(\mathrm{pid}_{Charlie}, z + x\right)\right)\right\}$
          \State Send (\texttt{paymentSent}, \textit{Bob}, $x$) to $\mathcal{E}$
        \Else
          \State Send (\texttt{paymentFailed}, \textit{Bob}, $x$) to $\mathcal{E}$
        \EndIf
      \Else \Comment{Invalid payment}
        \State Send (\texttt{noPath}, \textit{Bob}, $x$) to $\mathcal{E}$
      \EndIf
    \State
    \State Upon receiving (\texttt{SendInvoice}, $x$) from \textit{Bob}:
      \State $\mathrm{preimage} \overset{r}{\gets}
      \left\{0,1\right\}^{\mathrm{gazillion}}$
      \State $\mathrm{hash} \gets \mathcal{H}\left(\mathrm{preimage}\right)$
      \State Send (\texttt{invoice}, $x$, hash) to \textit{Bob}
      \State Wait for update of any channel $e := \left(\mathrm{txid},
      \left(\mathrm{pid}_{\alice}, y\right), \left(\mathrm{pid}_{Charlie},
      z\right)\right)$ to $e' := \left(\mathrm{txid},
      \left(\mathrm{pid}_{\alice}, y + x\right), \left(\mathrm{pid}_{Charlie}, z
      - x\right)\right)$ conditional on \textit{Alice}'s knowledge of the preimage of
      the hash
      \State Send (\texttt{preimage}) to $Charlie$
      \State Wait for update of $e'$ to $e'' := \left(\mathrm{txid},
      \left(\mathrm{pid}_{\alice}, y + x\right), \left(\mathrm{pid}_{Charlie}, z
      - x\right)\right)$ unconditional
      \If{$Charlie$ does not update the channel to $e''$}
        \State Settle $e'$ on-chain with the preimage and take $x$ from the HTLC
        provided by $Charlie$
      \EndIf
      \State Send (\texttt{paymentReceived}, \textit{Bob}, $x$) to $\mathcal{E}$
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from
    \environment:
    \Indent
      \State ensure \texttt{receipt} corresponds to an open $\mathtt{channel}
      \in \mathtt{channels}$
      \State assign latest \texttt{channel} sequence number to $n$
      \State $\mathrm{sig} \gets \mathtt{signature}\left(\mathtt{localCom}_n,
      sh_F\right)$
      \State remove \texttt{channel} from \texttt{channels}
      \State send (\textsc{submit}, $\left(\mathrm{sig}, \mathtt{remoteSig}_n,
      \mathtt{localCom}_n\right)$) to \ledger
    \EndIndent
  \end{algorithmic}
\hrulefill
