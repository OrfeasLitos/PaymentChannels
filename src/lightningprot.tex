\ \\ \noindent {$\Pi_{\mathrm{LN}}^t$} The protocol is executed by player $Alice$.
  \label{alg:lightningprot}
  \begin{algorithmic}[1]
    \State Initialisation:
      \State $\mathrm{blocked} \leftarrow 0$
      \State $G \leftarrow \left(\left\{\mathrm{sid}_{Alice}\right\}, \emptyset\right)$
    \State
    \State Upon receiving (open, $\mathrm{sid}_{Alice}$, $\mathrm{sid}_{Bob}$, $x$) from
    $\mathcal{E}$:
      \If{$\mathcal{G}_{\mathrm{Ledger}}.\mathrm{balance}(Alice) - \mathrm{blocked} \geq
      x$}
        \State $\mathrm{blocked} \leftarrow \mathrm{blocked} + x$
        \State tx $\gets$ \textsc{OpenChannel}($\mathrm{sid}_{Alice}$,
        $\mathrm{sid}_{Bob}$, $x$)
        \If{tx is a valid funding transaction}
          \State $G \leftarrow G \cup \left(\left\{\mathrm{sid}_{Bob}\right\},
          \left\{\left(\mathcal{H}\left(\mathrm{tx}\right), \left(\mathrm{sid}_{Alice},
          x\right), \left(\mathrm{sid}_{Bob}, 0\right)\right)\right\}\right)$
          \State Send (opened, $Alice$, $Bob$, $x$, 0,
          $\mathcal{H}\left(\mathrm{tx}\right))$ to $\mathcal{E}$
        \Else
          \State Send (notOpened, $Alice$, $Bob$, $x$, 0) to $\mathcal{E}$
        \EndIf
        \State $\mathrm{blocked} \leftarrow \mathrm{blocked} - x$
      \Else
        \State Send (noFunds, $Alice$, $x$) to $\mathcal{E}$
      \EndIf
    \State
    \Procedure{OpenChannel}{source, dest, funds}
      \State Send (proposeChannel, funds) to dest
      \State Wait for response
      \If{response == yes}
        \State $\left(\mathrm{initTX}, \left(pa_0, sa_0\right), \left(pa_1, sa_1\right),
        \left(pa_2, sa_2\right), \left(pa_3, sa_3\right)\right) \gets
        \textsc{GetOpenKeysAndTX}\left(\mathrm{funds}\right)$
        \State Send (openSendKeys, $\left(pa_1, pa_2, pa_3\right)$) to dest
        \State Wait for response
        \If{response == (openResponseKeys, $\left(pb_1, pb_2, pb_3\right)$) $\And \forall
        i \in \left[3\right],
        \mathcal{F}_{\mathrm{Wallet}}.\mathrm{isValidPubKey}\left(pb_i\right)$ == true}
          \State $\left(F, C1b, RD1b\right) \gets
          \textsc{GetOpenTXsSend}\left(\mathrm{initTX}, pa_1, sa_1, pb_1, pa_2, sa_2,
          pb_2, pb_3, \mathrm{funds}\right)$
          \State Send (openSendTXs, $\left(F, C1b, RD1b\right)$) to dest
          \State Wait for response
          %TODO start
          \textsc{isValidOpenTXsResponse}\left(\left(C1a, RD1a\right)\right), TODO$}
          \If{response == (openResponseTXs, $\left(C1a, RD1a\right)$) $\And
            \State Send (fundingSig, $\mathcal{F}_{\mathrm{Wallet}}.\text{sigForP2PKH}
            \left(\mathrm{outpoint}\left(\mathrm{initTX}, 0\right), sa_0\right)$
            \State Wait for $F$ to be confirmed on-chain \Comment{Is broadcast by $Bob$.
            TODO: correct way to Wait?}
            \If{confirmed}
          %TODO end
              \State Return $F$
            \Else
              \State Return $\bot$
            \EndIf
          \Else
            \State Return $\bot$
          \EndIf
        \Else
          \State Return $\bot$
        \EndIf
      \Else
        \State Return $\bot$ \Comment{TODO: Either use goto error, or return different
        message for different errors}
      \EndIf
    \EndProcedure
    \State
    \Procedure{GetOpenKeysAndTX}{$x$}
      \State $\left(\mathrm{initTX}, \left(pa_0, sa_0\right)\right) \gets
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{getTXandKeyWithValue}
      \left(\mathrm{funds}\right)$ \Comment{Returns tx with 1 p2pkh output of value funds
      and the keypair that spends it for funding tx input}
      \State $\left(pa_1, sa_1\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For funding tx
      output}
      \State $\left(pa_2, sa_2\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For C1a
      outputs}
      \State $\left(pa_3, sa_3\right) \leftarrow
      \mathcal{F}_{\mathrm{Wallet}}.\mathrm{genKey}\left(\right)$ \Comment{For RD1a
      output}
      \State Return $\left(\mathrm{initTX}, \left(pa_0, sa_0\right), \left(pa_1,
      sa_1\right), \left(pa_2, sa_2\right), \left(pa_3, sa_3\right)\right)$
    \EndProcedure
    \State
    \Procedure{GetOpenTXsSend}{$\mathrm{initTX}, pa_1, sa_1, pb_1, pa_2, sa_2, pb_2, pb_3,
    \mathrm{funds}$}
      \State $F \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(\mathrm{initTX}, 0\right),
      \bot\right)\right]$
      \State outputs: $\left[\text{2-of-2-msig}\left(pa_1, pb_1,
      \mathrm{funds}\right)\right]$
      \State )\}
      \State $C1b \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(F, 0\right),
      \text{sigFor2-of-2-msig}\left(\mathrm{outpoint}\left(F, 0\right), 0,
      sa_1\right)\right)\right]$
      \State outputs: $\left[\mathrm{P2PKH}\left(pa_2, \mathrm{funds}\right),
      \mathrm{RSMC}\left(pa_2, pb_2, 0\right)\right]$
      \State )\}
      \State $RD1b \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(C1b, 0\right),
      \text{sigForP2PKH}\left(\mathrm{outpoint}\left(C1b, 0\right),
      sa_2\right)\right)\right]$
      \State outputs: $\left[\mathrm{Delay}\left(pb_3, \mathrm{funds}\right)\right]$
      \State )\}
      \State Return $\left(F, C1b, RD1b\right)$
    \EndProcedure
    \State
    \Procedure{GetOpenTXsRespond}{$F, sb_1, pa_2, pb_2, sb_2, pa_3, \mathrm{funds}$}
      \State $C1a \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(F, 0\right),
      \text{sigFor2-of-2-msig}\left(\mathrm{outpoint}\left(F, 0\right), 1,
      sb_1\right)\right)\right]$
      \State outputs: $\left[\mathrm{P2PKH}\left(pb_2, 0\right), \mathrm{RSMC}\left(pb_2,
      pa_2, \mathrm{funds}\right)\right]$
      \State )\}
      \State $RD1a \gets \mathcal{F}_{\mathrm{Wallet}}$.getTX(\{
      \State inputs: $\left[\left(\mathrm{outpoint}\left(C1a, 0\right),
      \text{sigForP2PKH}\left(\mathrm{outpoint}\left(C1b, 0\right),
      sb_2\right)\right)\right]$
      \State outputs: $\left[\mathrm{Delay}\left(pa_3, 0\right)\right]$
      \State )\}
      \State Return $\left(C1b, RD1b\right)$
    \EndProcedure
    \State
    \State TODO: isValidPubKey(), isValidOpenTXsSend(), isValidOpenTXsResponse(), Bob's
    side
    \State Upon receiving (opening, $x$, tx) from $Bob$:
      \State Wait for tx to be confirmed
      \State $G \leftarrow G \cup \left(\left\{\mathrm{sid}_{Bob}\right\},
      \left\{\left(\mathcal{H}\left(\mathrm{tx}\right), \left(\mathrm{sid}_{Alice},
      0\right), \left(\mathrm{sid}_{Bob}, x\right)\right)\right\}\right)$ \Comment{Add
      $\mathrm{sid}_{Bob}$ to nodes, new channel to edges}
      \State Send (opened, $Alice$, $Bob$, 0, x, $\mathcal{H}\left(\mathrm{tx}\right))$ to
      $\mathcal{E}$
    \State
    \State Upon receiving (newChannel, txid, $\mathrm{sid}_{Charlie},
    \mathrm{sid}_{Dave}$) from $Bob$:
      \If{there exists a tx with $\mathcal{H}\left(\mathrm{tx}\right) == \mathrm{txid}$ on
      $\mathcal{G}_{\mathrm{Ledger}}$ and is a valid funding transaction}
        \State $G \leftarrow G \cup \left(\left\{\mathrm{sid}_{Charlie},
        \mathrm{sid}_{Dave}\right\}, \left\{\left(\mathrm{txid},
        \left(\mathrm{sid}_{Charlie}, \bot\right), \left(\mathrm{sid}_{Dave},
        \bot\right)\right)\right\}\right)$ \Comment{State of channel unknown, thus
        balances are $\bot$}
      \EndIf
    \State
    \State Upon receiving (closedChannel, txid) from $Bob$:
      \If{there exists a tx with $\mathcal{H}\left(\mathrm{tx}\right) == \mathrm{txid}$ on
      $\mathcal{G}_{\mathrm{Ledger}}$ that closes a funding tx' that corresponds to edge
      $e$ in $G$}
        \State $G \leftarrow G \setminus \left\{e\right\}$
      \EndIf
    \State
    \State Upon receiving (pay, $Bob$, $x$) from $\mathcal{E}$:
      \State Send (SendInvoice, $x$) to $Bob$
      \State Wait for response (invoice, $x$, hash) from $Bob$:
      \If{$\exists e = \left(\mathrm{txid}, \left(\mathrm{sid}_{Alice},
      y\right), \left(\mathrm{sid}_{Bob}, z\right)\right) \in G: y \geq x$}
        \State Update $e$ to $e' = \left(\mathrm{txid},
        \left(\mathrm{sid}_{Alice}, y - x\right),
        \left(\mathrm{sid}_{Bob}, z + x\right)\right)$ \Comment{Primitive
        for Update}
      \ElsIf{there is an $\left(Alice, Charlie, \dots, Bob\right)$ path in $G$ where the
      first hop is of weight at least $x$}
        \State Send a Sphinx~\cite{sphinx} message with the correct HTLCs (containing
        hash) for $Bob$
        \State \Comment{Sane fees and timeouts as requested by each hop}
        \State Wait for (preimage) from $Charlie$
        \If{$\mathcal{H}\left(\mathrm{preimage}\right) == \mathrm{hash}$}
          \State Let $e = \left(\mathrm{txid}, \left(\mathrm{sid}_{Alice}, y\right),
          \left(\mathrm{sid}_{Charlie}, z\right)\right)$ $Alice$'s channel with $Charlie$
          \State Update $e$ to pay $Charlie$ $x$ \Comment{use HTLC primitive}
          \State $G \leftarrow G \setminus \left\{e\right\}$
          \State $G \leftarrow G \cup \left\{\left(\mathrm{txid},
          \left(\mathrm{sid}_{Alice}, y - x\right), \left(\mathrm{sid}_{Charlie}, z +
          x\right)\right)\right\}$
          \State Send (paymentSent, $Bob$, $x$) to $\mathcal{E}$
        \Else
          \State Send (paymentFailed, $Bob$, $x$) to $\mathcal{E}$
        \EndIf
      \Else
        \State Send (noPath, $Bob$, $x$) to $\mathcal{E}$
      \EndIf
    \State
    \State Upon receiving (SendInvoice, $x$) from $Bob$:
      \State $\mathrm{preimage} \overset{r}{\leftarrow}
      \left\{0,1\right\}^{\mathrm{gazillion}}$
      \State $\mathrm{hash} \leftarrow \mathcal{H}\left(\mathrm{preimage}\right)$
      \State Send (invoice, $x$, hash) to $Bob$
      \State Wait for update of any channel $e = \left(\mathrm{txid},
      \left(\mathrm{sid}_{Alice}, y\right), \left(\mathrm{sid}_{Charlie}, z\right)\right)$
      to $e' = \left(\mathrm{txid}, \left(\mathrm{sid}_{Alice}, y + x\right),
      \left(\mathrm{sid}_{Charlie}, z - x\right)\right)$ conditional on $Alice$'s
      knowledge of the preimage of the hash
      \State Send (preimage) to $Charlie$
      \State Wait for update of $e'$ to $e'' = \left(\mathrm{txid},
      \left(\mathrm{sid}_{Alice}, y + x\right), \left(\mathrm{sid}_{Charlie}, z -
      x\right)\right)$ unconditional
      \If{$Charlie$ does not update the channel to $e''$}
        \State Settle $e'$ on-chain with the preimage and take $x$ from the HTLC provided
        by $Charlie$
      \EndIf
      \State Send (paymentReceived, $Bob$, $x$) to $\mathcal{E}$
    \State
    \State Upon receiving (close, id) from $Alice$:
      \If{$\mathcal{G}_{Ledger}$ has a valid funding tx with
      $\mathcal{H}\left(\mathrm{tx}\right) == \mathrm{id}$}
        \State Try to close cooperatively \Comment{TODO}
        \If{cooperative closing fails} \Comment{TODO}
          \State Close unilaterally \Comment{TODO}
        \EndIf
      \EndIf
  \end{algorithmic}
\hrulefill
\ \\ \noindent {Connection with $\mathcal{F}_{\mathrm{Ledger}}$}
  \label{alg:temp:formalfledger}
  \begin{algorithmic}[1]
    \State $\mathcal{F}_{\mathrm{Ledger}}\mathrm{.balance}\left(Alice\right)$:
    \State
    \State Send (READ, sid) to $\mathcal{F}_{\mathrm{Ledger}}$ \Comment{Whose sid? List is
    not created by Alice}
    \State Wait for response $\mathrm{state}_{sid}$
    \State Find \texttt{list} of txs in UTXO spendable by $Alice$ (using
    $\mathrm{Dec}\left(\mathrm{state}_{sid}\right)$) \Comment{blockify() is system
    parameter, how to better specify above?}
    \State Return sum of outputs in \texttt{list} spendable by $Alice$ \Comment{Only
    P2PKH? Or any kind (e.g. multisigs, funding txs)?}
    \State
    \State
    \State Send (pay, $Alice$, $Bob$, $x$) to $\mathcal{F}_{\mathrm{Ledger}}$:
    \State
    \State Create and sign transaction \texttt{tx} that pays $x$ from $Alice$ to $Bob$
    \Comment{Clear enough? How to sign? Is signature needed?}
    \State Send (SUBMIT, $sid_{Alice}$ \texttt{tx}) to $\mathcal{F}_{\mathrm{Ledger}}$
  \end{algorithmic}
\hrulefill
