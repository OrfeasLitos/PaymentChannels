\section{Overview of \fpaynet{}}
\label{sec:ov-paynet}
  One of our contributions is the specification of \fpaynet{}
  (Appendix~\ref{appendix:payfunc}) a functionality that describes the
  functional and security guarantees given by an ideal payment network. The
  central aim of \fpaynet{} is opening payment channels, keeping
  track of their state, updating them according to requested payments and
  closing them, as requested by honest players, all in a secure manner. In
  particular, the three main messages it can receive from \alice{} are
  (\textsc{openChannel}), (\textsc{pay}) and (\textsc{closeChannel}).

  When \fpaynet{} receives (\textsc{openChannel}, \alice, \bob, $x$,
  \textit{tid}) from \alice, it asks \simulator{} to attempt to create a channel
  between \alice{} and \bob{} where \alice{} owns $x$ coins. When it receives
  (\textsc{pay}, \bob, $x, \overrightarrow{\mathtt{path}}$, \texttt{receipt})
  from \alice, it asks \simulator{} to attempt to perform a multi-hop payment of
  $x$ coins from \alice{} to \bob{} along the $\overrightarrow{\mathtt{path}}$.
  As expected, when \fpaynet{} receives (\textsc{closeChannel}, \texttt{receipt},
  \textit{tid}) from \alice, it asks \simulator{} to close the relevant channel.

  In order to provide security guarantees, there are various moments when
  \fpaynet{} verifies whether certain expected events have actually taken place.
  A number of messages prompt \fpaynet{} to read from \ledger{} and perform
  these checks. In the actual implementations of LN these checks are done
  periodically by a polling daemon. Such checks are done by \fpaynet{} in the
  following cases:
  \begin{itemize}
    \item On receiving (\textsc{poll}) by \alice, \fpaynet{} asks \ledger{} for
    \alice's latest $\Sigma_{\alice}$ and verifies that no bad events have
    happened. In particular, \fpaynet{} halts if any of \alice's channels has
    been closed maliciously and, even though \alice{} has been \textsc{poll}ing
    regularly, she did not manage to punish the counterparty. Refer to
    lines~\ref{alg:fpaynet:poll:ifdsforgery}
    and~\ref{alg:fpaynet:poll:haspolled} of Fig.~\ref{alg:fpaynet:poll} for the
    exact halting conditions. If \fpaynet{} does not halt, it leaks 
    \simulator{} the polling details (including the identity of the poller and the state of the ledger in their view). 
    \item \fpaynet{} expects \simulator{} to send a (\textsc{resolvePays},
    \texttt{charged}) message that gives details on the outcome of one or more
    multi-hop payments. \fpaynet{} checks that for each payment the charged
    party was (a) the one that initiated the payment, (b) a malicious party or
    (c) a honest party that is negligent. The latter case happens when the honest party  either did not \textsc{poll} in time to catch a malicious
    closure (Fig.~\ref{alg:fpaynet:resolvepay},
    line~\ref{alg:fpaynet:resolvepay:haltcond:rel}) or to learn the preimage
    from an honest closure, or did not enforce the retrieval of her funds by
    using the preimage to fulfill on chain (Fig.~\ref{alg:fpaynet:resolvepay},
    line~\ref{alg:fpaynet:resolvepay:haltcond:abs}). It also halts if a
    particular payment resulted in a channel update for which \simulator{} did
    not inform \fpaynet{} (Fig.~\ref{alg:fpaynet:resolvepay:loops},
    line~\ref{alg:fpaynet:resolvepay:loops:halt:do}).
    \item \fpaynet{} executes the function
    \texttt{checkClosed}($\Sigma_{\alice}$) every time it receives
    $\Sigma_{\alice}$ from \ledger{} (Fig.~\ref{alg:fpaynet:close:func},
    lines~\ref{alg:fpaynet:close:func:start}-\ref{alg:fpaynet:close:func:end}).
    In this case, it checks that every channel that \environment{} has asked to be closed
    or \simulator{} designated as closed indeed has a closing transaction that
    corresponds to its latest state in $\Sigma_{\alice}$. Enough time is given
    for that transaction to settle in $\Sigma_{\alice}$, but if that time passes
    and the channel is still open or it is closed to a wrong version and no
    opportunity for punishment was given, \fpaynet{} halts.
  \end{itemize}

  A number of  messages that support the protocol progress are also handled:
  \begin{itemize}
    \item Every player has to send (\textsc{register}, delay, relayDelay) before
    participating in the network. This informs \fpaynet{} how often the player
    has to \textsc{poll}. ``delay'' corresponds to the maximum time between
    \textsc{poll}s so that malicious closures will be caught. ``relayDelay'' is
    useful when the player is an intermediary of a multi-hop payment. It roughly
    represents the size of the time window the player has to learn a preimage
    from the next and reveal it to the previous node. Subsequently \fpaynet{}
    asks \simulator{} to create and send a public key that will hold the
    player's funds. This public key is subsequently sent back to the player.
    \item To complete her registration, \alice{} has to send the
    (\textsc{toppedUp}) message. It lets \fpaynet{} know that the desired amount
    of initial funds have been transferred to \alice's public key. \fpaynet{}
    reads \alice's state on \ledger{} to retrieve this number and subsequently
    allows \alice{} to participate in the payment network after it updates her  \texttt{onChainBalance}.
    \item When \fpaynet{} receives (\textsc{checkForNew}, \alice, \bob,
    \textit{tid}) from \alice, it asks \ledger{} for \alice's latest state
    $\Sigma_{\alice}$ and looks for a funding transaction $F$ in it. If one is
    found, \simulator{} is asked to complete the opening procedure.
    \item (\textsc{pushFulfill}, \textit{pchid}),
    (\textsc{pushAdd}, \textit{pchid}) and (\textsc{commit}, \textit{pchid})
    all nudge \simulator{} to carry on with the protocol that updates the state
    of a specific channel. \fpaynet{} simply forwards these messages to
    \simulator.
    \item (\textsc{fulfillOnChain}) prompts \simulator{} to close channels in which
    the counterparty is not willing to pay, even though they have promised to do
    so upon disclosure of a particular preimage. This message is simply forwarded to
    \simulator{}, but \fpaynet{} takes a note that such a message was
    received and the current blockheight in the view of the calling party.
  \end{itemize}

  Last but not least, \environment{} sends (\textsc{getNews}) to obtain the
  latest changes regarding newly opened or closed channels, along with updates
  to the state of existing ones. Here we make an interesting observation: The
  most complex part of LN is arguably the negotiations that happen when a
  multi-hop payment takes place, due to the many channel updates needed; indeed,
  two complete channel updates for each hop are needed for a successful payment
  to go through. The fact that a proposal for an update can happen
  asynchronously with the commitment to this update, along with the fact that a
  single commitment may commit to many indiviual update proposals only adds to
  the complexity. It is therefore only natural to want \fpaynet{} to be unaware
  of these details. In order to disentangle the abstraction of \fpaynet{} from
  such minutiae, we allow the adversary full control of the
  updates that are reported back
  to \environment{} via  \fpaynet{}. 
  Nevertheless, \fpaynet{} enforces that 
  any   reporting deviations induced by the adversary will 
   be caught  when a channel
  closes.  This is quite intuitive: Consider
  a user of the payment network that does not understand its inner workings but
  can read \ledger{} and count her funds there. \fpaynet{} provides no guarantees 
  regarding any interim reporting except the fact that  
  if the user chooses to close  the relevant channel,  her state in
  \ledger will be consistent with all the payments that went through.
