\begin{functionality}{\fpaynet}
  \label{alg:payfunc}
  \funcsection{Parameters}
    \begin{itemize}
      \item one-way, collision-free hash function $\mathcal{H}$ (for generating
      transaction IDs)
    \end{itemize}

  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item (\textsc{register})
      \item (\textsc{setDelay}, delay)
      \item (\textsc{openChannel}, self, peer, selfCoins)
      \item (\textsc{closeChannel}, receipt)
      \item (\textsc{pay}, peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \Function{receiptFromChannel}{\texttt{channel}}
      \State $\left(\alice, \bob, x, y, \mathtt{delay}\left(\alice\right),
      \mathtt{delay}\left(\bob\right), seq, \mathit{fchid},
      \mathit{pchid}\right) \gets \mathtt{channel}$
      \State \Return $\left(\mathtt{receipt}, \alice, \bob, x, y,
      \mathit{pchid}\right)$
    \EndFunction
    \State

    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{pendingPay}, \mathtt{corrupted} \gets
      \emptyset$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}, \mathrm{delay}\right)$ from
    \alice:
    \Indent
      \State $\mathtt{delay}\left(\alice\right) \gets \mathrm{delay}$
      \State $\mathtt{pendingUpdates}\left(\alice\right) \gets \emptyset$
      \State $\mathtt{blindTime}\left(\alice\right) \gets \emptyset$
      \State send (\textsc{read}) to \clock{} as \alice{} and assign reply to
      \texttt{lastPoll}(\alice)
      \State send $\left(\textsc{register}, \alice, \mathrm{delay}\right)$ to
      \simulator
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{registerDone}, \alice, x,
    \mathrm{pubKey}\right)$ from \simulator: \Comment{TODO: may not require
    on/offChBal}
    \Indent
      \State $\mathtt{onChainBalance}\left(\alice\right) \gets x$
      \State $\mathtt{offChainBalance}\left(\alice\right) \gets 0$
      \State $\mathtt{pubKey}\left(\alice\right) \gets \mathrm{pubKey}$
      \State send (\textsc{registered}) to \alice
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$ from \alice:
    \Indent
      \State ignore message if \alice has not registered
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x\right)$
    from \alice:
    \Indent
      \State choose unique channel ID \textit{fchid}
      \State $\mathtt{pendingOpen}\left(\mathit{fchid}\right) \gets
      \left(\alice, \bob, x\right)$
      \State send $\left(\textsc{openChannel}, \alice, \bob, x,
      \mathit{fchid}\right)$ to \simulator
    \EndIndent
    \State

    \State Upon receiving is $\left(\textsc{channelOpened}, \alice, \bob, x,
    \mathit{fchid}, \mathit{pchid}\right)$ from \simulator
    \Indent
      \State ensure that there is no $\mathtt{channel} \in \mathtt{channels}$
      with id \textit{pchid} or \textit{fchid}
      \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply to
      $\Sigma_{\alice}$
      \State for some $\mathrm{payer} \in \left\{\alice, \bob\right\}$, ensure
      that there exists a transaction $\mathtt{tx} \in \Sigma_{\alice}$ with a
      $\left(x, \mathtt{pubKey}\left(\mathrm{payer}\right)\right)$ input, a
      $\left(x, \mathtt{pubKey}\left(\alice\right) \wedge
      \mathtt{pubkey}\left(\bob\right)\right)$ output and a transaction ID
      \textit{pchid}.
      \If{payer is honest} \Comment{otherwise $\mathcal{A}$ decided to open
      channel}
        \State ensure that $\mathtt{pendingOpen}\left(\mathit{fchid}\right)
        = \left(\alice, \bob, x\right)$
        \State $\mathtt{pendingOpen}\left(\mathit{fchid}\right) \gets \bot$
      \EndIf
      \State $\mathrm{offChainBalance}\left(\mathrm{payer}\right) \gets
      \mathrm{offChainBalance}\left(\mathrm{payer}\right) + x$ \orfeas{remove}
      \State $\mathrm{onChainBalance}\left(\mathrm{payer}\right) \gets
      \mathrm{offChainBalance}\left(\mathrm{payer}\right) - x$ \orfeas{remove}
      \State $\mathtt{channel} \gets \left(\alice, \bob, x, 0,
      \mathtt{delay}\left(\alice\right), \mathtt{delay}\left(\bob\right), 0,
      \mathit{fchid}, \mathit{pchid}\right)$
      \State add \texttt{channel} to \texttt{channels} and receipt to
      \texttt{newChannels}(\{\alice, \bob\})
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}\right)$ from \alice:
    \Indent
      \State send (\textsc{read}) to \clock{} as \alice and assign reply to
      $\tau$
      \If{$\mathtt{lastPoll}\left(\alice\right) +
      \mathtt{delay}\left(\alice\right) < \tau$}
        \State add $\left[\mathtt{lastpoll}\left(\alice\right), \tau -
        \texttt{delay}\left(\alice\right) - 1\right]$ to
        \texttt{blindTime}(\alice)
      \EndIf
      \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply to
      $\Sigma_{\alice}$
      \State scan $\Sigma_{\alice}$ for honestly closed channels that contain
      \alice{} and exist in \texttt{channels} (txs that spend funding txs that
      have the same channel version as stored), remove them from
      \texttt{channels} and add their receipts to
      \texttt{closedChannels}(\alice)
      \State scan $\Sigma_{\alice}$ for malicioulsy closed channels that contain
      \alice{} and exist in \texttt{channels} (txs that spend funding txs that
      have an older channel version than stored)
      \ForAll{every maliciously closed channel of which the spending txs can
      still be spent by \alice}
        \State send (\textsc{closeChannel}, \texttt{channel}) to \simulator,
        ensure reply is (\textsc{channelClosed}, \texttt{channel}), ensure that
        corresponding txs exist on-chain, remove it from \texttt{channels} and
        add its receipt to \texttt{closedChannels}(\alice) \orfeas{TODO:
        split in two messages}
      \EndFor
      \State clear \texttt{newChannels}(\alice),
      \texttt{closedChannels}(\alice), \texttt{pendingUpdates}(\alice) and send
      them to \alice
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{pay}, \bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from \alice:
    \Indent
      \State ensure that \texttt{receipt} corresponds to a \texttt{channel}
      where \alice{} has at least $x$
      \State ensure that $\overrightarrow{\mathtt{path}}$ consists of channels
      \State ensure that each consecutive pair of channels in
      $\overrightarrow{\mathtt{path}}$ has a common member
      \State choose unique payment ID \textit{payid}
      \State add $\left(\alice, \bob, x, \overrightarrow{\mathtt{path}},
      \mathit{payid}\right)$ to \texttt{pendingPay}
      \State send $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, \mathit{payid}\right)$
      to \simulator
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{resolvePay}, \mathit{payid},
    \charlie\right)$ from \simulator
    \Indent
      \State retrieve $\left(\alice, \bob, x,
      \overrightarrow{\mathtt{path}}\right)$ pending payment with ID
      \textit{payid} and remove it from \texttt{pendingPay}
      \If{($\charlie \neq \alice$ and $\charlie \notin \mathtt{corrupted}$) or
      $\charlie \notin \overrightarrow{\mathtt{path}}$}
        \State halt \aggelos{or ignore?}
        \State \orfeas{In the protocol, even negligent players cannot lose money
        here because the next hop is done by the protocol (without permission
        from the environment). So I removed \texttt{negligent} from the check
        above.}
      \Else
        \ForAll{$\mathtt{channel}\text{s} \in \overrightarrow{\mathtt{path}}$
        starting from the one where \charlie{} pays}
          \State in the first iteration, \charlie is \texttt{payer}. In
          subsequent iterations, \texttt{payer} is the unique player that has
          been paid but has not paid. The other \texttt{channel} party is
          \texttt{payee}
          \If{\texttt{payer} has $x$ or more in \texttt{channel}}
            \State update \texttt{channel} to the next version and transfer $x$
            from \texttt{payer} to \texttt{payee}
            \State add \texttt{channel} receipt to both parties'
            \texttt{pendingUpdate}
          \Else
            \State revert all updates and remove them from
            \texttt{pendingUpdate}
            \State \orfeas{entire if may be avoided by simply not sending a
            message to \alice}
            \If{all players on path from \alice{} up to and including failed
            \texttt{payer} are honest}
              \State send $\left(\textsc{notPaid}, \bob, x,
              \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to \alice
            \Else
              \State send (\textsc{reportNotPaid}, \textit{payid}) to
              \simulator \orfeas{TODO: break to new message}
              \If{reply from \simulator is (\textsc{doReport}, \textit{payid})}
                \State send $\left(\textsc{notPaid}, \bob, x,
                \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to
                \alice
              \EndIf
            \EndIf
            \State \orfeas{end of possibly avoidable if}
          \EndIf
        \EndFor
        \State $\mathtt{offChainBalance}\left(\charlie\right) \gets
        \mathtt{offChainBalance}\left(\charlie\right) - x$
        \State $\mathtt{offChainBalance}\left(\bob\right) \gets
        \mathtt{offChainBalance}\left(\bob\right) + x$
        \If{\charlie{} = \alice}
          \State send $\left(\textsc{paid}, \bob, x,
          \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to \alice
        \EndIf
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{corrupted}, \alice\right)$ from
    \simulator:
    \Indent
      \State add \alice{} to \texttt{corrupted}
    \EndIndent
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from \alice
    \aggelos{(or \simulator) ?? } \orfeas{@Aggelos: why \simulator?}
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      \texttt{channel} that contains \alice
      \State retrieve \textit{fchid} from \texttt{channel}
      \State $\mathtt{pendingClose}\left(\mathit{fchid}\right) \gets \alice$
      \State send (\textsc{closeChannel}, \textit{fchid}, \alice) to \simulator
    \EndIndent
    \State

    \State Upon receiving (\textsc{channelClosed}, \textit{fchid}) from
    \simulator:
    \Indent
      \State $\alice \gets \mathtt{pendingClose}\left(\mathit{fchid}\right)$
      \State retrieve $\bob, x, y, \mathit{pchid}$ from \texttt{channel}
      with ID \textit{fchid}
      \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply to
      $\Sigma_{\alice}$
      \State ensure that transaction with ID \textit{pchid} is in
      $\Sigma_{\alice}$, is spent, $x$ of its coins are spendable or
      will be spendable exclusively by \alice{} and $y$ of its coins are
      spendable exclusively by \bob
      \State add receipt of \texttt{channel} to \texttt{closedChannels}(\bob)
      \State remove \texttt{channel} from \texttt{channels}
      \State $\mathtt{onChainBalance}\left(\alice\right) \gets
      \mathtt{onChainBalance}\left(\alice\right) + x$
      \State $\mathtt{onChainBalance}\left(\bob\right) \gets
      \mathtt{onChainBalance}\left(\bob\right) + y$
      \State $\mathtt{offChainBalance}\left(\alice\right) \gets
      \mathtt{offChainBalance}\left(\alice\right) - x$
      \State $\mathtt{offChainBalance}\left(\bob\right) \gets
      \mathtt{offChainBalance}\left(\bob\right) - y$
      \State send (\textsc{channelClosed}, receipt from \texttt{channel}) to
      \alice
    \EndIndent
    \State

    \State At the end of each activation: \Comment{TODO: Discuss}
    \Indent
    \State verify  onChainbalance() for all parties is consistent with ledger (if not roll back the state and ignore command of activation).
    \EndIndent
  \end{algorithmic}
\end{functionality}
