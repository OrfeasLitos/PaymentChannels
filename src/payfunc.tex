\section{Payment Network Functionality}
  \begin{figure}[H]
    \begin{systembox}{\fpaynet - support}
      \funcsection{Parameters}
        \begin{itemize}
          \item one-way, collision-free hash function $\mathcal{H}$ (for
          generating transaction IDs)
        \end{itemize}

      \funcsection{Interface (messages from $\mathcal{E}$)}
      \TODO{check}
        \begin{itemize}
          \item (\textsc{register})
          \item (\textsc{setDelay}, delay)
          \item (\textsc{openChannel}, self, peer, selfCoins)
          \item (\textsc{closeChannel}, receipt)
          \item (\textsc{pay}, peer, coins, path, receipt)
        \end{itemize}

      \funcsection{Initialisation}
      \begin{algorithmic}[1]
        \State Initialisation:
        \Indent
          \State $\mathtt{channels}, \mathtt{pendingPay}, \mathtt{pendingOpen},
          \mathtt{corrupted} \gets \emptyset$
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{register}, \mathrm{delay},
        \mathrm{relayDelay}\right)$ from \alice:
        \Indent
          \State $\mathtt{delay}\left(\alice\right) \gets \mathrm{delay}$
          \State $\mathtt{relayDelay}\left(\alice\right) \gets
          \mathrm{relayDelay}$
          \State $\mathtt{pendingUpdates}\left(\alice\right),
          \mathtt{newChannels}\left(\alice\right) \gets \emptyset$
          \State $\mathtt{negligent}\left(\alice\right),
          \mathtt{relayNegligent}\left(\alice\right) \gets \emptyset$
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign
          largest block number to \texttt{lastPoll}(\alice)
          \label{alg:fpaynet:support:lastpoll}
          \State send $\left(\textsc{register}, \alice, \mathrm{delay},
          \mathrm{relayDelay}, \mathrm{lastPoll}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{registerDone}, \alice,
        \mathrm{pubKey}\right)$ from \simulator:
        \Indent
          \State $\mathtt{pubKey}\left(\alice\right) \gets \mathrm{pubKey}$
          \State send (\textsc{register}, \alice, \texttt{delay}(\alice),
          \texttt{relayDelay}(\alice), pubKey) to \alice
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{registered}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply
          to $\Sigma_{\alice}$
          \State assign the sum of all output values that are exclusively
          spendable by \alice{} to \texttt{onChainBalance}
          \State send (\textsc{registered}) to \alice
        \EndIndent
        \Statex

        \State Upon receiving any message except for
        $\left(\textsc{register}\right)$ from \alice:
        \Indent
          \State ignore message if \alice{} has not registered
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{corrupted}, \alice\right)$ from
        \simulator:
        \Indent
          \State add \alice{} to \texttt{corrupted}
        \EndIndent
        \Statex

        \State At the end of each activation: \orfeas{can this part completely
        go?}
        \Indent
          \State verify onChainbalance() for honest parties is consistent with
          ledger (if not roll back the state and ignore command of activation).
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:support}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - open}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x,
        \mathit{tid}\right)$ from \alice:
        \Indent
          \State ensure \textit{tid} hasn't been used by \alice{} for opening
          another channel before
          \label{alg:fpaynet:open:valid}
          \State choose unique channel ID \textit{fchid}
          \State $\mathtt{pendingOpen}\left(\mathit{fchid}\right) \gets
          \left(\alice, \bob, x, \mathit{tid}\right)$
          \State send $\left(\textsc{openChannel}, \alice, \bob, x,
          \mathit{fchid}, \mathit{tid}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{channelAnnounced}, \alice,
        p_{\alice, F}, p_{\bob, F}, \mathit{fchid}, \mathit{pchid},
        \mathit{tid}\right)$ from \simulator:
        \Indent
          \State ensure that there is a \texttt{pendingOpen}(\textit{fchid})
          entry with temporary id \textit{tid}
          \label{alg:fpaynet:announced:valid}
          \State add ``\alice{} announced'', $p_{\alice, F}, p_{\bob, F}$,
          \textit{pchid} to \texttt{pendingOpen}(\textit{fchid})
          \label{alg:fpaynet:announced:add}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{checkNew}, \alice, \bob, \textit{tid})
        from \alice:
        \Indent
          \State ensure there is a matching \texttt{channel} in
          \texttt{pendingOpen}(\textit{fchid}), marked with ``\alice{}
          announced''
          \label{alg:fpaynet:checkNew:valid}
          \State $\left(\mathrm{funder}, \mathrm{fundee}, x, p_{\alice, F},
          p_{\bob, F}\right) \gets
          \mathtt{pendingOpen}\left(\mathit{fchid}\right)$
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply
          to $\Sigma_{\alice}$
          \label{alg:fpaynet:checkNew:read}
          \State ensure that there is a TX $F \in \Sigma_{\alice}$ with a
          $\left(x, \left(p_{\mathrm{funder}, F} \wedge p_{\mathrm{fundee},
          F}\right)\right)$ output such that $\mathcal{H}\left(F\right) =
          \mathit{pchid}$
          \label{alg:fpaynet:checkNew:included}
          \State mark \texttt{pendingOpen}(\textit{fchid}) with ``\alice{}
          checked''
          \label{alg:fpaynet:checkNew:mark}
          \If{\texttt{pendingOpen}(\textit{fchid}) is not marked with ``noted''}
            \State mark \texttt{pendingOpen}(\textit{fchid}) with ``noted''
            \If{$\mathrm{funder} = \alice$}
              \State $\mathrm{offChainBalance}\left(\alice\right) \gets
              \mathrm{offChainBalance}\left(\alice\right) + x$ \orfeas{remove
              on/offChainBalance?}
              \State $\mathrm{onChainBalance}\left(\alice\right) \gets
              \mathrm{offChainBalance}\left(\alice\right) - x$
              \State $\mathtt{channel} \gets \left(\alice, \bob, x, 0, 0,
              \mathit{fchid}, \mathit{pchid}\right)$
            \Else \Comment{\bob{} is the funder}
              \State $\mathrm{offChainBalance}\left(\bob\right) \gets
              \mathrm{offChainBalance}\left(\bob\right) + x$ \orfeas{remove
              on/offChainBalance?}
              \State $\mathrm{onChainBalance}\left(\bob\right) \gets
              \mathrm{offChainBalance}\left(\bob\right) - x$
              \State $\mathtt{channel} \gets \left(\bob, \alice, x, 0, 0,
              \mathit{fchid}, \mathit{pchid}\right)$
            \EndIf
            \State add \texttt{channel} to \texttt{channels}
          \EndIf
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{newChannels}(\alice)
          \If{\texttt{pendingOpen}(\textit{fchid}) is marked with ``\alice{}
          checked'' and ``\bob{} checked''}
            \State clear \texttt{pendingOpen}(\textit{fchid}) entry
          \EndIf
          \State send (\textsc{channelOpened}, \alice, \textit{fchid}) to
          \simulator
          \label{alg:fpaynet:checkNew:sim}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:open}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - pay}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{pay}, \bob, x,
        \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from \alice:
        \Indent
          \State ensure that $\left(\alice, c\right) \in \mathtt{receipt}$ and
          $c \geq x$
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}
          : \mathtt{receipt}\left(\mathtt{channel}\right) = \mathtt{receipt}$
          \State ensure that $\overrightarrow{\mathtt{path}}$ consists of
          (channel, CltvExpiryDelta) pairs where $\mathrm{channel} \in
          \mathtt{channels}$
          \State ensure that each consecutive pair of channels in
          $\overrightarrow{\mathtt{path}}$ has a common member
          \State choose unique payment ID \textit{payid}
          \State add $\left(\alice, \bob, x, \overrightarrow{\mathtt{path}},
          \mathit{payid}\right)$ to \texttt{pendingPay}
          \State send $\left(\textsc{pay}, \alice, \bob, x,
          \overrightarrow{\mathtt{path}}, \mathtt{receipt},
          \mathit{payid}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{resolvePay}, \mathit{payid},
        \mathtt{charged}\right)$ from \simulator:
        \Indent
          \State retrieve $\left(\alice, \bob, x,
          \overrightarrow{\mathtt{path}}\right)$ with ID \textit{payid} and
          remove it from \texttt{pendingPay}
          \If{$\mathtt{charged} = \bot$}
            \State \Return
          \ElsIf{$\mathtt{charged} \neq \alice \wedge \mathtt{charged} \notin
          \texttt{corrupted} \wedge \mathtt{charged} \text{ has not been
          (relay-)negligent \TODO{when?} } \wedge$ the scenario
          ``\texttt{charged} passed on an \textsc{updateFulfillHtlc}, the
          counterparty did not revoke but either (went on-chain with the
          committment tx that contained the HTLC and \texttt{charged} did not
          broadcast HTLC-success) or (did not go on-chain and \texttt{charged}
          did not close the channel'' did not happen \TODO{fixup}}
            \State halt
          \EndIf
          \ForAll{$\mathtt{channel}\text{s} \in \overrightarrow{\mathtt{path}}$
          starting from the one where \texttt{charged} pays}
            \State in the first iteration, \texttt{payer} is \texttt{charged}. In
            subsequent iterations, \texttt{payer} is the unique player that has
            received but has not given. The other \texttt{channel} party is
            \texttt{payee}
            \If{\texttt{payer} has $x$ or more in \texttt{channel}}
              \State update \texttt{channel} to the next version and transfer
              $x$ from \texttt{payer} to \texttt{payee}
              \State add \texttt{receipt}(\texttt{channel}) to both parties'
              \texttt{pendingUpdates}
            \Else
              \State revert all updates and remove them from
              \texttt{pendingUpdates}
            \EndIf
          \EndFor
          \If{$\mathtt{charged} \notin \mathtt{corrupted}$}
            \State $\mathtt{offChainBalance}\left(\mathtt{charged}\right) \gets
            \mathtt{offChainBalance}\left(\mathtt{charged}\right) - x$
          \EndIf
          \State $\mathtt{offChainBalance}\left(\bob\right) \gets
          \mathtt{offChainBalance}\left(\bob\right) + x$
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:pay}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - close}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from
        \alice \aggelos{(or \simulator) ?? } \orfeas{@Aggelos: why \simulator?}
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}
          : \mathtt{receipt}\left(\mathtt{channel}\right) = \mathtt{receipt}$
          \State retrieve \textit{fchid} from \texttt{channel}
          \State $\mathtt{pendingClose}\left(\mathit{fchid}\right) \gets \alice$
          \State send (\textsc{closeChannel}, \textit{fchid}, \alice) to
          \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{channelClosed}, \textit{fchid}) from
        \simulator:
        \Indent
          \State $\alice \gets \mathtt{pendingClose}\left(\mathit{fchid}\right)$
          \State retrieve $\charlie, \bob, x, y, \mathit{pchid}$ from
          \texttt{channel} with ID \textit{fchid}
          \State ensure that $\charlie{} = \alice$
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply
          to $\Sigma_{\alice}$
          \State ensure that transaction with ID \textit{pchid} is in
          $\Sigma_{\alice}$, is spent, $x$ of its coins are spendable or
          will be spendable exclusively by \alice{} and $y$ of its coins are
          spendable exclusively by \bob
          \State $\mathtt{pendingClose}\left(\mathit{fchid}\right) \gets \bot$
          \State add receipt of \texttt{channel} to
          \texttt{closedChannels}(\bob)
          \State remove \texttt{channel} from \texttt{channels}
          \State $\mathtt{onChainBalance}\left(\alice\right) \gets
          \mathtt{onChainBalance}\left(\alice\right) + x$
          \State $\mathtt{onChainBalance}\left(\bob\right) \gets
          \mathtt{onChainBalance}\left(\bob\right) + y$
          \State $\mathtt{offChainBalance}\left(\alice\right) \gets
          \mathtt{offChainBalance}\left(\alice\right) - x$
          \State $\mathtt{offChainBalance}\left(\bob\right) \gets
          \mathtt{offChainBalance}\left(\bob\right) - y$
          \State send (\textsc{channelClosed}, receipt from \texttt{channel}) to
          \alice
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:close}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - poll}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{poll}\right)$ from \alice:
        \Indent
          \State $\mathtt{toReport}\left(\alice\right) \gets \emptyset$
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply
          to $\Sigma_{\alice}$
          \State assign largest block number in $\Sigma_{\alice}$ to $t$
          \If{$\mathtt{lastPoll}\left(\alice\right) +
          \mathtt{delay}\left(\alice\right) < t$}
            \State add $\left[\mathtt{lastpoll}\left(\alice\right), t -
            \texttt{delay}\left(\alice\right) - 1\right]$ to
            \texttt{negligent}(\alice)
          \EndIf
          \If{$\mathtt{lastPoll}\left(\alice\right) +
          \mathtt{relayDelay}\left(\alice\right) < t$}
            \State add $\left[\mathtt{lastpoll}\left(\alice\right), t -
            \texttt{relayDelay}\left(\alice\right) - 1\right]$ to
            \texttt{relayNegligent}(\alice)
          \EndIf
          \State $\mathtt{lastPoll}\left(\alice\right) \gets t$
          \State scan $\Sigma_{\alice}$ for honestly closed channels that
          contain \alice{} and exist in \texttt{channels} (txs that spend
          funding txs that have the same channel version as stored), remove them
          from \texttt{channels} and add them to \texttt{toReport}(\alice)
          (marked as ``honest'')
          \State scan $\Sigma_{\alice}$ for malicioulsy closed channels that
          contain \alice{} and exist in \texttt{channels} (txs that spend
          funding txs that have an older channel version than stored)
          \ForAll{maliciously closed \texttt{channel}s of which the spending txs
          can still be spent by \alice} \Comment{If \alice{} is negligent, she
          may be unable to punish}
            \If{\alice{} cannot spend those spending txs and \alice{} has not
            been negligent in the last interval}
              \State halt
            \EndIf
            \State add \texttt{channel} to \texttt{toReport}(\alice) (marked as
            ``malicious'')
          \EndFor
          \State send (\textsc{getClosedFunds}, \texttt{toReport}(\alice),
          \alice) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{channelsClosed}, \texttt{details},
        \alice) from \simulator:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and assign reply
          to $\Sigma_{\alice}$
          \ForAll{$\mathtt{channel} \in \mathtt{details}$}
            \State ensure $\mathtt{channel} \in
            \mathtt{toReport}\left(\alice\right)$
            \If{\texttt{channel} is marked as ``malicious''}
              \State ensure that transactions that spend the funding tx of
              \texttt{channel} and pay \alice{} the entire \texttt{channel}
              value exist in $\Sigma_{\alice}$
            \Else \ \Comment{\texttt{channel} is marked as ``honest''}
              \State ensure that transactions that spend the funding tx of
              \texttt{channel} and pay \alice{} the her part in \texttt{channel}
              exist in $\Sigma_{\alice}$
              \State ensure that \alice{} has not suffered losses for multi-hop
              payments where she was not the payer
            \EndIf
            \State add the receipt of \texttt{channel} to
            \texttt{closedChannels}(\alice)
            \State remove \texttt{channel} from \texttt{channels} and
            \texttt{toReport}(\alice)
          \EndFor
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:poll}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - miscalleanous}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}) from
        \alice:
        \Indent
          \State send (\textsc{pushFulfill}, \textit{pchid}, \alice) to
          \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{pushAdd}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{pushAdd}, \textit{pchid}, \alice) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{commit}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{commit}, \textit{pchid}, \alice) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{getNew}) from \alice:
        \Indent
          \State clear \texttt{newChannels}(\alice),
          \texttt{closedChannels}(\alice), \texttt{pendingUpdates}(\alice) and
          send them to \alice
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:misc}
  \end{figure}
