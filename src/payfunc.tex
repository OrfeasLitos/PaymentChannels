\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item (\textsc{register})
      \item (\textsc{setDelay}, delay)
      \item (\textsc{openChannel}, self, peer, selfCoins)
      \item (\textsc{closeChannel}, receipt)
      \item (\textsc{pay}, peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \Function{receiptFromChannel}{\texttt{channel}}
      \State $\left(Alice, Bob, x, y, \mathtt{delay}\left(Alice\right),
      \mathtt{delay}\left(Bob\right), seq, \mathrm{chid}\right) \gets
      \mathtt{channel}$
      \State \Return $\left(\mathtt{receipt}, Alice, Bob, x, y,
      \mathrm{chid}\right)$
    \EndFunction
    \State

    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{corrupted} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State $\mathtt{delay}\left(Alice\right) \gets$ 1 day \Comment{default
      delay}
      \State $\mathtt{pendingUpdates}\left(Alice\right) \gets \emptyset$
      \State send $\left(\textsc{register}, Alice\right)$ to $\mathcal{S}$
\EndIndent
    \State Upon receiving $\left(\textsc{registerDone},Alice, x\right)$ from $\mathcal{S}$:
\Indent 
      \State  $\mathtt{onChainBalance}\left(Alice\right) \gets x$
      \State $\mathtt{offChainBalance} \gets 0$
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State ignore message if $Alice$ has not registered
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{setDelay}, \mathrm{delay}\right)$ from
    $Alice$:
    \Indent
      \State $\mathtt{delay}\left(Alice\right) \gets \mathrm{delay}$
      \State send $\left(\textsc{delay}, Alice\right)$ to $\mathcal{S}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, Alice, Bob, x\right)$
    from $Alice$:
    \Indent
      \State choose unique channel ID fchid
      \State send $\left(\textsc{openChannel}, Alice, Bob, x, fchid \right)$ to
      $\mathcal{S}$
    \EndIndent

      \State Upon receiving is $\left(\textsc{channelOpened},   
      fchid, pchid \right)$  from $\mathcal{S}$
      \Indent
      \State \aggelos{ensure $pchid$ transaction exists for $x$ outgoing from Alice's account to channel (otherwise ignore).}
      \State $\mathrm{offChainBalance}\left(Alice\right) \gets
      \mathrm{offChainBalance}\left(Alice\right) + x$
      \State add $\left(Alice, Bob, x, 0, \mathtt{delay}\left(Alice\right),
      \mathtt{delay}\left(Bob\right), 0, \mathrm{fchid}, \mathrm{pchid}\right)$ to
      \texttt{channels}
      \State mark newly added channel as unreported to $Bob$
      \State send (\textsc{channelOpened},
      \textsc{receiptFromChannel}(\texttt{channel})) to $Alice$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}\right)$ from $Alice$:
    \Indent
      \State \aggelos{ read from clock and if more than delay (Alice) from previous poll, mark negligent in time interval T.}
      \State \aggelos{ read from ledger and scan for ...  (\texttt{newChannels}, \texttt{closedChannels}) for Alice (just say the below with words) + revoked channels. (the func can detect this using the channel version ).} \aggelos{for revoked channel - call the closed channel code.}
      \State $\mathtt{res.updates} \gets
      \mathtt{pendingUpdates}\left(Alice\right)$
      \State $\mathtt{pendingUpdates}\left(Alice\right) \gets \emptyset$
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{newChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.new}
      \EndFor
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{closedChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.closed}
      \EndFor
      \State \Return (\textsc{poll}, \texttt{res}) $Alice$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      \texttt{channel} and $Alice$ has at least $x$ coins in it.
      \State ensure that $\overrightarrow{\mathtt{path}}$ contains a series of
      channels that all contain at least $x$ to the correct direction \aggelos{maybe weaken this to not checking balances. }
      \State send $\left(\textsc{pay}, Alice, Bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, payid\right)$ to $\mathcal{S}$
    \EndIndent
      \State Upon receiving reply is $\left(\textsc{SettlePay}, payid, Charlie\right)$ from $\mathcal{S}$
      \Indent
      \If{($Charlie \neq Alice$ and $Charlie \notin \{  \mathtt{corrupted}, \mathtt{negligent}\} $) or
      $Charlie \notin \overrightarrow{\mathtt{path}}$}
        \State halt \aggelos{ignore?}
      \Else
                \State update both \texttt{offChainBalance}s \aggelos{for the end points}
        \ForAll{$\mathtt{channel}\text{s} \in \overrightarrow{\mathtt{path}}$
        starting with the one where $Charlie$ pays \aggelos{improve}}
          \State transfer $x$ from the first to the second member \aggelos{if not possible revert all and ignore - increment channel version. }
          \State add \textsc{receiptFromChannel}(\texttt{channel}) \aggelos{Use sc only for labels} to both
          \texttt{pendingUpdate}s
        \EndFor
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{corrupted}, Alice\right)$ from
    $\mathcal{S}$:
    \Indent
      \State add $Alice$ to \texttt{corrupted}
    \EndIndent
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from $Alice$ \aggelos{(or $\mathcal{S}$) ?? }
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      $\mathtt{channel} \in \mathtt{channels}$ that contains $Alice$
      \State send (\textsc{closeChannel}, \texttt{channel}, $Alice$) to
      $\mathcal{S}$
      \State ensure reply is (\textsc{channelClosed}, \texttt{channel})
      \State extract $Alice, Bob, x, y$ from \texttt{channel}
      \State $\mathtt{onChainBalance}\left(Alice\right) \gets
      \mathtt{onChainBalance}\left(Alice\right) + x$
      \State \aggelos{check incoming transaction for Alice, Bob for respective amounts}
      \State $\mathtt{onChainBalance}\left(Bob\right) \gets
      \mathtt{onChainBalance}\left(Bob\right) + y$
      \State $\mathtt{offChainBalance}\left(Alice\right) \gets
      \mathtt{offChainBalance}\left(Alice\right) - x$
      \State $\mathtt{offChainBalance}\left(Bob\right) \gets
      \mathtt{offChainBalance}\left(Bob\right) - y$
      \State send (\textsc{channelClosed}, \texttt{channel}) to $Alice$
    \EndIndent
    \State

    \State At the end of each activation: \Comment{TODO: Discuss}
    \Indent
    \State verify  onChainbalance() for all parties is consistent with ledger (if not roll back the state and ignore command of activation).
  %    \ForAll{$Alice \notin \mathtt{corrupted}$}
  %      \If{the minimum delay($Alice$) for all her channels is about to pass}
  %        \State check $\mathcal{G}_{\mathrm{Ledger}}$ for revoked closes
  %        \State if found, inform $\mathcal{S}$
  %      \EndIf
  %    \EndFor
    \EndIndent
  \end{algorithmic}
\end{functionality}
