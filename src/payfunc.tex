\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \begin{algorithmic}[1]
    \State Initialisation:
      \Indent
      \ForAll{$v \in \mathcal{P}$}
        \State $\mathrm{blocked}\left(v\right) \gets 0$
      \EndFor
      \State $\mathtt{pending}, \mathtt{receipts} \gets \emptyset$
      \EndIndent
    \State
    \State Upon receiving $\left(\textsc{openChannel}, Alice, Bob, x, y,
    \mathrm{AliceDelay}, \mathrm{forFundTX}\right)$ from $Alice$:
    \Indent
      \If{there is no $\left(Alice, Bob, x, y, \_, \_\right)$ in
      \texttt{pending}}
        \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
        \mathrm{forFundTX}\right)$ to \texttt{pending}
        \State $\mathrm{blocked}\left(Alice\right) \leftarrow
        \mathrm{blocked}\left(Alice\right) + x$
        \State send $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
        \mathrm{forFundTX}\right)$ to $Bob$
      \EndIf
    \EndIndent
    \State
    \State Upon receiving $\left(\textsc{acceptChannel}, Alice, Bob, x, y,
    \mathrm{BobDelay}\right)$ from $Bob$:
    \Indent
      \If{$\left(Alice, Bob, x, y, \_, \_\right) \in \mathtt{pending}$}
        \State assert($\mathcal{G}_{\mathrm{Ledger}}$.balance($Alice$) $\geq
        \mathrm{blocked}\left(Alice\right) + x$)
        \State assert($\mathcal{G}_{\mathrm{Ledger}}$.balance($Bob$) $\geq
        \mathrm{blocked}\left(Bob\right)$)
        \State AliceDelay, forFundTX $\gets$ last 2 elements in $\left(Alice,
        Bob, x, y, \_, \_\right)$
        \State remove $\left(Alice, Bob, x, y, \_, \_\right)$ from
        \texttt{pending}
        \State $\mathrm{blocked}\left(Alice\right) \gets
        \mathrm{blocked}\left(Alice\right) - x$
        \State chid $\overset{r}{\gets} \left\{0,
        1\right\}^{\mathrm{gazillion}}$
        \State $\mathtt{tx} \gets \left(\textsc{Funding}\left(Alice, Bob, x, y,
        \mathrm{forFundTX}\right), \mathrm{chid}, \tau_L, Bob\right)$
        \State add \texttt{tx} to \texttt{buffer}
        \State $\mathtt{receipt} \gets \left(x, y, Alice, Bob,
        \mathrm{AliceDelay}, \mathrm{BobDelay}, 0, \mathrm{chid}\right)$
        \State add \texttt{receipt} to \texttt{receipts}
        \State send \texttt{receipt} to $Alice$ and $Bob$
        %\State send message $\left(\mathrm{opened}, Alice, Bob, x, y, \mathrm{id}\right)$
        %to $Alice$
        %\State send message $\left(\mathrm{opened}, Bob, Alice, y, x, \mathrm{id}\right)$
        %to $Bob$
      \EndIf
    \EndIndent
    \State
    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State condition 1: $\overrightarrow{\mathtt{path}}$ consists of players
      where for every adjacent $\left(Carol, Dave\right)$ pair there is a
      $\mathtt{receipt}'$ in \texttt{receipts} with $Carol$ and $Dave$ and where
      $Carol$ has at least $x$. Also, $\mathtt{receipt}'$ corresponds to (has
      the same chid with) an unclosed \textsc{open-channel} transaction that
      exists both in $\mathtt{state}_{Carol}$ and $\mathtt{state}_{Dave}$ (i.e.
      there is no \textsc{close-channel} transaction with a receipt with the
      same chid in either state)
      \State condition 2: \texttt{receipt} is in \texttt{receipts} and contains
      $Alice$ with at least $x$ coins.
      \If{both condition 1 and condition 2 hold}
        \ForAll{$\left(Carol, Dave\right)$ pairs in
        $\overrightarrow{\mathtt{path}}$}
          \State $\mathtt{oldRec} \gets \left(Carol, Dave, y, z,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq},
          \mathrm{chid}\right) \in \mathtt{receipts}$
          \State $\mathtt{newRec} \gets \left(Carol, Dave, y - x, z + x,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq} + 1,
          \mathrm{chid}\right)$
          \State replace \texttt{oldReceipt} with \texttt{newReceipt} in
          \texttt{receipts}
          \State send \texttt{newReceipt} to $Carol$ and $Dave$
        \EndFor
        \State send message $\left(\textsc{payed}, Bob, x\right)$ to $Alice$
        \State send message $\left(\textsc{payedFrom}, Alice, x\right)$ to $Bob$
      \Else
        \State send message $\left(\textsc{invalidPath}, Bob, x\right)$ to
        $Alice$
      \EndIf
    \EndIndent
    \State
    \State Upon receiving (\textsc{close}, \texttt{receipt}) from $Alice$:
    \Indent
      \If{\texttt{receipt} contains $Alice$ and is contained in \texttt{receipts}}
        \State $\mathtt{txid} \overset{r}{\gets} \left\{0,
        1\right\}^{\mathrm{gazillion}}$
        \State $\mathtt{tx} \gets
        \left(\textsc{Closing}\left(\mathtt{receipt}\right), \mathtt{txid},
        \tau_L, Alice\right)$
        \State add \texttt{tx} to \texttt{buffer}
        \State remove \texttt{receipt} from \texttt{receipts}
      \EndIf
    \EndIndent
  \end{algorithmic}
\end{functionality}
