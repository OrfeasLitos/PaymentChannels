\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item (\textsc{register})
      \item (\textsc{setDelay}, delay)
      \item (\textsc{openChannel}, self, peer, selfCoins)
      \item (\textsc{closeChannel}, receipt)
      \item (\textsc{pay}, peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \Function{receiptFromChannel}{\texttt{channel}}
      \State $\left(Alice, Bob, x, y, \mathtt{delay}\left(Alice\right),
      \mathtt{delay}\left(Bob\right), seq, \mathrm{chid}\right) \gets
      \mathtt{channel}$
      \State \Return $\left(\mathtt{receipt}, Alice, Bob, x, y,
      \mathrm{chid}\right)$
    \EndFunction
    \State

    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{corrupted} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State $\mathtt{delay}\left(Alice\right) \gets$ 1 day \Comment{default
      delay}
      \State $\mathtt{pendingUpdates}\left(Alice\right) \gets \emptyset$
      \State send $\left(\textsc{register}, Alice\right)$ to $\mathcal{S}$
      \State assign reply to $\mathtt{onChainBalance}\left(Alice\right)$
      \State $\mathtt{offChainBalance} \gets 0$
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$ from $Alice$:
    \Indent
      \State ignore message if $Alice$ has not registered
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{setDelay}, \mathrm{delay}\right)$ from
    $Alice$:
    \Indent
      \State $\mathtt{delay}\left(Alice\right) \gets \mathrm{delay}$
      \State send $\left(\textsc{delay}, Alice\right)$ to $\mathcal{S}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, Alice, Bob, x\right)$
    from $Alice$:
    \Indent
      \State ensure $\mathrm{onChainBalance}\left(Alice\right) \geq x$
      \State choose unique channel ID chid
      \State send $\left(\textsc{openChannel}, Alice, Bob, x\right)$ to
      $\mathcal{S}$
      \State ensure reply is $\left(\textsc{channelOpened}, Alice, Bob, x,
      0\right)$
      \State $\mathrm{onChainBalance}\left(Alice\right) \gets
      \mathrm{onChainBalance}\left(Alice\right) - x$
      \State $\mathrm{offChainBalance}\left(Alice\right) \gets
      \mathrm{offChainBalance}\left(Alice\right) + x$
      \State add $\left(Alice, Bob, x, 0, \mathtt{delay}\left(Alice\right),
      \mathtt{delay}\left(Bob\right), 0, \mathrm{chid}\right)$ to
      \texttt{channels}
      \State mark newly added channel as unreported to $Bob$
      \State send (\textsc{channelOpened},
      \textsc{receiptFromChannel}(\texttt{channel})) to $Alice$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}\right)$ from $Alice$:
    \Indent
      \State send $\left(\textsc{poll}, Alice\right)$ to $\mathcal{S}$
      and assign reply to (\texttt{newChannels}, \texttt{closedChannels})
      \State $\mathtt{res.updates} \gets
      \mathtt{pendingUpdates}\left(Alice\right)$
      \State $\mathtt{pendingUpdates}\left(Alice\right) \gets \emptyset$
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{newChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.new}
      \EndFor
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{closedChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.closed}
      \EndFor
      \State \Return (\textsc{poll}, \texttt{res}) $Alice$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      \texttt{channel} and $Alice$ has at least $x$ coins in it.
      \State ensure that $\overrightarrow{\mathtt{path}}$ contains a series of
      channels that all contain at least $x$ to the correct direction
      \State send $\left(\textsc{pay}, Alice, Bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ to $\mathcal{S}$
      \State ensure reply is $\left(\textsc{payedBy}, Charlie\right)$
      \Comment{$\mathcal{S}$ can also reply (\textsc{notPayed})}
      \If{($Charlie \neq Alice$ and $Charlie \notin \mathtt{corrupted}$) or
      $Charlie \notin \overrightarrow{\mathtt{path}}$}
        \State halt
      \Else
        \ForAll{$\mathtt{channel}\text{s} \in \overrightarrow{\mathtt{path}}$
        starting with the one where $Charlie$ pays}
          \State transfer $x$ from the first to the second member
          \State update both \texttt{offChainBalance}s
          \State add \textsc{receiptFromChannel}(\texttt{channel}) to both
          \texttt{pendingUpdate}s
        \EndFor
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{corrupted}, Alice\right)$ from
    $\mathcal{S}$:
    \Indent
      \State add $Alice$ to \texttt{corrupted}
    \EndIndent
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from $Alice$:
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      $\mathtt{channel} \in \mathtt{channels}$ that contains $Alice$
      \State send (\textsc{closeChannel}, \texttt{channel}, $Alice$) to
      $\mathcal{S}$
      \State ensure reply is (\textsc{channelClosed}, \texttt{channel})
      \State extract $Alice, Bob, x, y$ from \texttt{channel}
      \State $\mathtt{onChainBalance}\left(Alice\right) \gets
      \mathtt{onChainBalance}\left(Alice\right) + x$
      \State $\mathtt{onChainBalance}\left(Bob\right) \gets
      \mathtt{onChainBalance}\left(Bob\right) + y$
      \State $\mathtt{offChainBalance}\left(Alice\right) \gets
      \mathtt{offChainBalance}\left(Alice\right) - x$
      \State $\mathtt{offChainBalance}\left(Bob\right) \gets
      \mathtt{offChainBalance}\left(Bob\right) - y$
      \State send (\textsc{channelClosed}, \texttt{channel}) to $Alice$
    \EndIndent
    \State

    \State When idle: \Comment{TODO: Discuss}
    \Indent
      \ForAll{$Alice \notin \mathtt{corrupted}$}
        \If{the minimum delay($Alice$) for all her channels is about to pass}
          \State check $\mathcal{G}_{\mathrm{Ledger}}$ for revoked closes
          \State if found, inform $\mathcal{S}$
        \EndIf
      \EndFor
    \EndIndent
  \end{algorithmic}
\end{functionality}
