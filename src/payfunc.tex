\section{Payment Network Functionality}
  \begin{figure}[H]
    \begin{systembox}{\fpaynet - preamble}
      Parameters:
        \begin{itemize}
          \item one-way, collision-free hash function $\mathcal{H}$ (for
          generating transaction IDs)
        \end{itemize}

      Interface: \TODO{check}
      \begin{itemize}
        \item from $\environment$:
        \begin{itemize}
          \item (\textsc{register}, delay, relayDelay)
          \item (\textsc{registered})
          \item (\textsc{openChannel}, \alice, \bob, $x$, \textit{tid})
          \item (\textsc{checkNew}, \alice, \bob, \textit{tid})
          \item (\textsc{pay}, \bob, $x, \overrightarrow{\mathtt{path}}$,
          \texttt{receipt})
          \item (\textsc{closeChannel}, receipt)
          \item (\textsc{poll})
          \item (\textsc{pushFulfill}, \textit{pchid})
          \item (\textsc{pushAdd}, \textit{pchid})
          \item (\textsc{commit}, \textit{pchid})
          \item (\textsc{fulfillOnChain})
          \item (\textsc{getNews})
        \end{itemize}
        \item to $\environment$:
        \begin{itemize}
          \item (\textsc{register}, \alice, \texttt{delay}(\alice),
          \texttt{relayDelay}(\alice), pubKey)
          \item (\textsc{registered})
          \item (\textsc{channelClosed}, \texttt{receipt})
          \item (\textsc{news}, newChannels, closedChannels, updatesToReport)
        \end{itemize}
        \item from $\simulator$:
        \begin{itemize}
          \item (\textsc{registerDone}, \alice, pubKey)
          \item (\textsc{corrupted}, \alice)
          \item (\textsc{channelAnnounced}, \alice, $p_{\alice, F}, p_{\bob,
          F}$, \textit{fchid}, \textit{pchid}, \textit{tid})
          \item (\textsc{resolvePays}, \textit{payid}, \texttt{charged})
          \item (\textsc{channelClosed}, \textit{fchid})
          \item (\textsc{channelsClosed}, \texttt{details}, \alice,
          \textit{reportid})
        \end{itemize}
        \item to $\simulator$:
        \begin{itemize}
          \item (\textsc{register}, \alice, delay, relayDelay, lastPoll)
          \item (\textsc{openChannel}, \alice, \bob, $x$, \textit{fchid},
          \textit{tid})
          \item (\textsc{channelOpened}, \alice, \textit{fchid})
          \item (\textsc{pay}, \alice, \bob, $x,
          \overrightarrow{\mathtt{path}}$, \texttt{receipt}, \textit{payid})
          \item (\textsc{closeChannel}, \textit{fchid}, \alice)
          \item (\textsc{getClosedFunds}, \texttt{toReport}, $\Sigma_{\alice}$,
          \alice, \textit{reportid})
          \item (\textsc{pushFulfill}, \textit{pchid}, \alice)
          \item (\textsc{pushAdd}, \textit{pchid}, \alice)
          \item (\textsc{commit}, \textit{pchid}, \alice)
          \item (\textsc{fulfillOnChain}, $t$, \alice)
        \end{itemize}
      \end{itemize}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:interface}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - support}
      \begin{algorithmic}[1]
        \State Initialisation:
        \Indent
          \State $\mathtt{channels}, \mathtt{pendingPay}, \mathtt{pendingOpen},
          \mathtt{corrupted}, \Sigma \gets \emptyset$
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{register}, \mathrm{delay},
        \mathrm{relayDelay}\right)$ from \alice:
        \Indent
          \State $\mathtt{delay}\left(\alice\right) \gets \mathrm{delay}$
          \Comment{Must check chain at least once every \texttt{delay}(\alice)
          blocks}
          \State $\mathtt{relayDelay}\left(\alice\right) \gets
          \mathrm{relayDelay}$
          \State $\mathtt{updatesToReport}\left(\alice\right),
          \mathtt{newChannels}\left(\alice\right) \gets \emptyset$
          \State $\mathtt{polls}\left(\alice\right) \gets \emptyset$
          \State $\mathtt{focs}\left(\alice\right) \gets \emptyset$
          \State send (\textsc{read}) to \ledger{} as \alice{}, store reply to
          $\Sigma_{\alice}$, add $\Sigma_{\alice}$ to $\Sigma$ and add largest
          block number to \texttt{polls}(\alice)
          \label{alg:fpaynet:support:lastpoll}
          \State send $\left(\textsc{register}, \alice, \mathrm{delay},
          \mathrm{relayDelay}, \mathrm{lastPoll}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{registerDone}, \alice,
        \mathrm{pubKey}\right)$ from \simulator:
        \Indent
          \State $\mathtt{pubKey}\left(\alice\right) \gets \mathrm{pubKey}$
          \State send (\textsc{register}, \alice, \texttt{delay}(\alice),
          \texttt{relayDelay}(\alice), pubKey) to \alice
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{registered}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \State assign the sum of all output values that are exclusively
          spendable by \alice{} to \texttt{onChainBalance}
          \State send (\textsc{registered}) to \alice
        \EndIndent
        \Statex

        \State Upon receiving any message except for
        $\left(\textsc{register}\right)$ from \alice:
        \Indent
          \State ignore message if \alice{} has not registered
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{corrupted}, \alice\right)$ from
        \simulator:
        \Indent
          \State add \alice{} to \texttt{corrupted}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:support}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - open}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x,
        \mathit{tid}\right)$ from \alice:
        \Indent
          \State ensure \textit{tid} hasn't been used by \alice{} for opening
          another channel before
          \label{alg:fpaynet:open:valid}
          \State choose unique channel ID \textit{fchid}
          \State $\mathtt{pendingOpen}\left(\mathit{fchid}\right) \gets
          \left(\alice, \bob, x, \mathit{tid}\right)$
          \State send $\left(\textsc{openChannel}, \alice, \bob, x,
          \mathit{fchid}, \mathit{tid}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{channelAnnounced}, \alice,
        p_{\alice, F}, p_{\bob, F}, \mathit{fchid}, \mathit{pchid},
        \mathit{tid}\right)$ from \simulator:
        \Indent
          \State ensure that there is a \texttt{pendingOpen}(\textit{fchid})
          entry with temporary id \textit{tid}
          \label{alg:fpaynet:announced:valid}
          \State add ``\alice{} announced'', $p_{\alice, F}, p_{\bob, F}$,
          \textit{pchid} to \texttt{pendingOpen}(\textit{fchid})
          \label{alg:fpaynet:announced:add}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{checkNew}, \alice, \bob, \textit{tid})
        from \alice:
        \Indent
          \State ensure there is a matching \texttt{channel} in
          \texttt{pendingOpen}(\textit{fchid}), marked with ``\alice{}
          announced''
          \label{alg:fpaynet:checkNew:valid}
          \State $\left(\mathrm{funder}, \mathrm{fundee}, x, p_{\alice, F},
          p_{\bob, F}\right) \gets
          \mathtt{pendingOpen}\left(\mathit{fchid}\right)$
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \label{alg:fpaynet:checkNew:read}
          \State ensure that there is a TX $F \in \Sigma_{\alice}$ with a
          $\left(x, \left(p_{\mathrm{funder}, F} \wedge p_{\mathrm{fundee},
          F}\right)\right)$ output such that $\mathcal{H}\left(F\right) =
          \mathit{pchid}$
          \label{alg:fpaynet:checkNew:included}
          \State mark \texttt{pendingOpen}(\textit{fchid}) with ``\alice{}
          checked''
          \label{alg:fpaynet:checkNew:mark}
          \If{\texttt{pendingOpen}(\textit{fchid}) is not marked with ``noted''}
            \State mark \texttt{pendingOpen}(\textit{fchid}) with ``noted''
            \If{$\mathrm{funder} = \alice$}
              \State $\mathrm{offChainBalance}\left(\alice\right) \gets
              \mathrm{offChainBalance}\left(\alice\right) + x$ \orfeas{remove
              on/offChainBalance?}
              \State $\mathrm{onChainBalance}\left(\alice\right) \gets
              \mathrm{offChainBalance}\left(\alice\right) - x$
              \State $\mathtt{channel} \gets \left(\alice, \bob, x, 0, 0,
              \mathit{fchid}, \mathit{pchid}\right)$
            \Else \Comment{\bob{} is the funder}
              \State $\mathrm{offChainBalance}\left(\bob\right) \gets
              \mathrm{offChainBalance}\left(\bob\right) + x$ \orfeas{remove
              on/offChainBalance?}
              \State $\mathrm{onChainBalance}\left(\bob\right) \gets
              \mathrm{offChainBalance}\left(\bob\right) - x$
              \State $\mathtt{channel} \gets \left(\bob, \alice, x, 0, 0,
              \mathit{fchid}, \mathit{pchid}\right)$
            \EndIf
            \State add \texttt{channel} to \texttt{channels}
          \EndIf
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{newChannels}(\alice)
          \If{\texttt{pendingOpen}(\textit{fchid}) is marked with ``\alice{}
          checked'' and ``\bob{} checked''}
            \State clear \texttt{pendingOpen}(\textit{fchid}) entry
          \EndIf
          \State send (\textsc{channelOpened}, \alice, \textit{fchid}) to
          \simulator
          \label{alg:fpaynet:checkNew:sim}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:open}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - pay}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{pay}, \bob, x,
        \overrightarrow{\mathtt{path}}\right)$ from \alice:
        \Indent
          \State choose unique payment ID \textit{payid}
          \State add $\left(\alice, \bob, x, \overrightarrow{\mathtt{path}},
          \mathit{payid}\right)$ to \texttt{pendingPay}
          \State send $\left(\textsc{pay}, \alice, \bob, x,
          \overrightarrow{\mathtt{path}}, \mathit{payid}, \textsc{state},
          \Sigma\right)$ to \simulator
          \label{alg:fpaynet:pay:send}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:pay}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - resolve payments}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{resolvePays},
        \mathtt{charged}\right)$ from \simulator:
        \Comment{after first sending \textsc{pay}, \textsc{pushFulfill},
        \textsc{pushAdd}, \textsc{commit}}
        \Indent
          \ForAll{$\charlie \text{ keys} \in \texttt{charged}$}
            \ForAll{$\left(\dave, \mathit{payid}\right) \in
            \mathtt{charged}\left(\charlie\right)$}
              \State retrieve $\left(\alice, \bob, x,
              \overrightarrow{\mathtt{path}}\right)$ with ID \textit{payid} and
              remove it from \texttt{pendingPay}
              \State calculate \texttt{IncomingCltvExpiry},
              \texttt{OutgoingCltvExpiry} of \dave{} (as in
              Fig.~\ref{alg:protocol:pay:invoice},
              l.~\ref{alg:protocol:pay:invoice:cltv})
              \If{$\dave{} = \bot$}
                \State \Return
              \ElsIf{$\dave{} \neq \alice{} \vee \dave{} \notin
              \mathtt{corrupted} \ \vee$ (\texttt{polls}(\dave) contains an
              element in $\left[\mathtt{OutgoingCltvExpiry} + 2k + \tochain{} -
              1,\right.$ $\left.\mathtt{IncomingCltvExpiry} - \TODO{2?}k -
              \tochain{} - 1\right] \wedge$ \texttt{focs}(\dave) contains
              $\mathtt{OutgoingCltvExpiry} - 2k - \tochain{} - 1$)}
                \State halt
              \EndIf
              \ForAll{$\mathtt{channel}\text{s} \in
              \overrightarrow{\mathtt{path}}$ starting from the one where
              \dave{} pays}
                \State in the first iteration, \texttt{payer} is \dave. In
                subsequent iterations, \texttt{payer} is the unique player that
                has received but has not given. The other \texttt{channel} party
                is \texttt{payee}
                \If{\texttt{payer} has $x$ or more in \texttt{channel}}
                  \State update \texttt{channel} to the next version and
                  transfer $x$ from \texttt{payer} to \texttt{payee}
                  \State add \texttt{receipt}(\texttt{channel}) to both parties'
                  \texttt{updatesToReport}
                \Else
                  \State revert all updates and remove them from
                  \texttt{updatesToReport}
                \EndIf
              \EndFor
              \If{$\dave{} \notin \mathtt{corrupted}$}
                \State $\mathtt{offChainBalance}\left(\dave\right) \gets
                \mathtt{offChainBalance}\left(\dave\right) - x$
              \EndIf
              \State $\mathtt{offChainBalance}\left(\bob\right) \gets
              \mathtt{offChainBalance}\left(\bob\right) + x$
            \EndFor
          \EndFor
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:resolvepay}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - close}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from
        \alice
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}
          : \mathtt{receipt}\left(\mathtt{channel}\right) = \mathtt{receipt}$
          \State retrieve \textit{fchid} from \texttt{channel}
          \State $\mathtt{pendingClose}\left(\mathit{fchid}\right) \gets \alice$
          \State send (\textsc{closeChannel}, \textit{fchid}, \alice) to
          \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{channelClosed}, \textit{fchid}) from
        \simulator:
        \Indent
          \State $\alice \gets \mathtt{pendingClose}\left(\mathit{fchid}\right)$
          \State retrieve $\charlie, \bob, x, y, \mathit{pchid}$ from
          \texttt{channel} with ID \textit{fchid}
          \State ensure that $\charlie{} = \alice$
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \State ensure that transaction with ID \textit{pchid} is in
          $\Sigma_{\alice}$, is spent, $x$ of its coins are spendable or
          will be spendable exclusively by \alice{} and $y$ of its coins are
          spendable exclusively by \bob
          \State $\mathtt{pendingClose}\left(\mathit{fchid}\right) \gets \bot$
          \State add receipt of \texttt{channel} to
          \texttt{closedChannels}(\bob)
          \State remove \texttt{channel} from \texttt{channels}
          \State $\mathtt{onChainBalance}\left(\alice\right) \gets
          \mathtt{onChainBalance}\left(\alice\right) + x$
          \State $\mathtt{onChainBalance}\left(\bob\right) \gets
          \mathtt{onChainBalance}\left(\bob\right) + y$
          \State $\mathtt{offChainBalance}\left(\alice\right) \gets
          \mathtt{offChainBalance}\left(\alice\right) - x$
          \State $\mathtt{offChainBalance}\left(\bob\right) \gets
          \mathtt{offChainBalance}\left(\bob\right) - y$
          \State send (\textsc{channelClosed}, receipt from \texttt{channel}) to
          \alice
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:close}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - poll}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{poll}\right)$ from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \label{alg:fpaynet:poll:read}
          \State add largest block number in $\Sigma_{\alice}$ to
          \texttt{polls}(\alice)
          \label{alg:fpaynet:poll:height}
          \State generate unique \textit{reportid}
          \label{alg:fpaynet:poll:id}
          \State $\mathtt{toReport}\left(\mathit{reportid}\right) \gets
          \emptyset$
          \State scan $\Sigma_{\alice}$ for honestly closed channels that
          contain \alice{} and exist in \texttt{channels} (txs that spend
          funding txs that have the same channel version as stored), remove them
          from \texttt{channels} and add them to
          \texttt{toReport}(\textit{reportid}) (marked as ``honest'')
          \State scan $\Sigma_{\alice}$ for maliciously closed channels that
          contain \alice{} and exist in \texttt{channels} (txs that spend
          funding txs that have an older channel version than stored)
          \label{alg:fpaynet:poll:malicious}
          \ForAll{maliciously closed \texttt{channel}s by a remote committment
          \texttt{tx} in block with height $h_{\mathtt{tx}}$}
            \If{the delayed output (of the counterparty) has been spent AND
            \texttt{polls}(\alice) has an element in $\left[h_{\mathtt{tx}} + k,
            h_{\mathtt{tx}} + k + \mathtt{delay}\left(\alice\right) - 1\right]$}
            \label{alg:fpaynet:poll:badevent}
              \State halt \Comment{\alice{} wasn't negligent but couldn't punish
              \label{alg:fpaynet:poll:halt}
              - bad event}
            \EndIf
            \State add \texttt{channel} to \texttt{toReport}(\textit{reportid})
            (marked as ``malicious'')
          \EndFor
          \State send (\textsc{getClosedFunds},
          \texttt{toReport}(\textit{reportid}), $\Sigma_{\alice}$, \alice,
          \textit{reportid}) to \simulator
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:poll}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - verify closed channels}
      \begin{algorithmic}[1]
        \State \Comment{Expected after resolutions are visible on-chain}
        \State Upon receiving a message that contains (\textsc{channelsClosed},
        \texttt{details}, \alice, \textit{reportid}) from \simulator:
        \Indent
          \If{\texttt{toReport}(\textit{reportid}) not in storage}
            \State ignore message
          \EndIf
          \State the next time (\textsc{read}) is sent to \ledger{} as \alice{}
          and just after a reply $\Sigma_{\alice}$ is received, do the
          following:
          \Indent
            \ForAll{$\mathtt{channel} \in \mathtt{details}$} \State ensure
            $\mathtt{channel} \in
            \mathtt{toReport}\left(\mathit{reportid}\right)$
              \If{\texttt{channel} is marked as ``malicious''}
                \State ensure that transactions that spend the funding tx of
                \texttt{channel} and pay \alice{} the entire \texttt{channel}
                value exist in $\Sigma_{\alice}$, otherwise halt
              \Else \ \Comment{\texttt{channel} is marked as ``honest''} \State
              ensure that transactions that spend the funding tx of
              \texttt{channel} and pay \alice{} her part in the latest state of
              \texttt{channel} exist in $\Sigma_{\alice}$ AND she received funds
              from all ``received HTLCs'' for which she knew the preimage when
              she received the associated \textsc{poll} AND received funds from
              all ''offered HTLCs'' that had timed out when she received the
              associated \textsc{poll}, otherwise halt
              \EndIf
              \State add the receipt of \texttt{channel} to
              \texttt{closedChannels}(\alice)
              \State remove \texttt{channel} from \texttt{channels}
            \EndFor
            \State remove \texttt{toReport}(\textit{reportid}) from storage
          \EndIndent
          \State handle the first part of the received message
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:verifyclosed}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet - daemon messages}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}) from
        \alice:
        \Indent
          \State send (\textsc{pushFulfill}, \textit{pchid}, \alice,
          \textsc{state}, $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:fulfill}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{pushAdd}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{pushAdd}, \textit{pchid}, \alice, \textsc{state},
          $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:add}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{commit}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{commit}, \textit{pchid}, \alice, \textsc{state},
          $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:commit}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{fulfillOnChain}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{}, store reply to
          $\Sigma_{\alice}$ and assign largest block number to $t$
          \label{alg:fpaynet:daemon:foc:read}
          \State add $t$ to \texttt{focs}(\alice)
          \State send (\textsc{fulfillOnChain}, $t$, \alice) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{getNews}) from \alice:
        \Indent
          \State clear \texttt{newChannels}(\alice),
          \texttt{closedChannels}(\alice), \texttt{updatesToReport}(\alice) and
          send them to \alice{} with header \textsc{news}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:daemon}
  \end{figure}
