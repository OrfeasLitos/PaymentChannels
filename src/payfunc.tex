\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Parameters}
    \begin{itemize}
      \item one-way, collision-free hash function $\mathcal{H}$
    \end{itemize}

  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item (\textsc{register})
      \item (\textsc{setDelay}, delay)
      \item (\textsc{openChannel}, self, peer, selfCoins)
      \item (\textsc{closeChannel}, receipt)
      \item (\textsc{pay}, peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \Function{receiptFromChannel}{\texttt{channel}}
      \State $\left(\alice, \bob, x, y, \mathtt{delay}\left(\alice\right),
      \mathtt{delay}\left(\bob\right), seq, \mathit{fchid},
      \mathit{pchid}\right) \gets \mathtt{channel}$
      \State \Return $\left(\mathtt{receipt}, \alice, \bob, x, y,
      \mathit{pchid}\right)$
    \EndFunction
    \State

    \State Initialisation:
    \Indent
      \State $\mathtt{channels}, \mathtt{corrupted} \gets \emptyset$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}\right)$ from \textit{Alice}:
    \Indent
      \State $\mathtt{delay}\left(\alice\right) \gets$ 1 day \Comment{default
      delay}
      \State $\mathtt{pendingUpdates}\left(\alice\right) \gets \emptyset$
      \State send $\left(\textsc{register}, \alice\right)$ to $\mathcal{S}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{registerDone}, \alice, x,
    \mathrm{pubKey}\right)$ from $\mathcal{S}$: \Comment{TODO: may not require
    on/offChBal}
    \Indent
      \State $\mathtt{onChainBalance}\left(\alice\right) \gets x$
      \State $\mathtt{offChainBalance}\left(\alice\right) \gets 0$
      \State $\mathtt{pubKey}\left(\alice\right) \gets \mathrm{pubKey}$
    \EndIndent
    \State

    \State Upon receiving any message except for
    $\left(\textsc{register}\right)$ from \textit{Alice}:
    \Indent
      \State ignore message if \textit{Alice} has not registered
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{setDelay}, \mathrm{delay}\right)$ from
    \textit{Alice}:
    \Indent
      \State $\mathtt{delay}\left(\alice\right) \gets \mathrm{delay}$
      \State send $\left(\textsc{delay}, \alice\right)$ to $\mathcal{S}$
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x\right)$
    from \textit{Alice}:
    \Indent
      \State choose unique channel ID fchid
      \State send $\left(\textsc{openChannel}, \alice, \bob, x,
      \mathit{fchid}\right)$ to $\mathcal{S}$
      \State $\mathtt{pending}\left(\mathit{fchid}\right) \gets \left(\alice,
      \bob, x\right)$
    \EndIndent
    \State

    \State Upon receiving is $\left(\textsc{channelOpened}, \mathit{fchid},
    \mathit{pchid}\right)$ from $\mathcal{S}$
    \Indent
      \State send (\textsc{read}) to $\mathcal{G}_{\mathrm{Ledger}}$ as
      \textit{Alice} and assign reply to $\Sigma_{\alice}$
      \State $\left(\alice, \bob, x\right) \gets
      \mathtt{pending}\left(\mathit{fchid}\right)$
      \State ensure that there exists a transaction $\mathtt{tx} \in
      \Sigma_{\alice}$ with a $\left(x,
      \mathtt{pubKey}\left(\alice\right)\right)$ input and a $\left(x,
      \mathtt{pubKey}\left(\alice\right) \wedge
      \mathtt{pubkey}\left(Bob\right)\right)$ output such that
      $\mathcal{H}\left(\mathtt{tx}\right) = \mathit{pchid}$. \orfeas{hash
      function?}
      \State $\mathtt{pending}\left(\mathit{fchid}\right) \gets \bot$
      \State $\mathrm{offChainBalance}\left(\alice\right) \gets
      \mathrm{offChainBalance}\left(\alice\right) + x$ \orfeas{remove}
      \State $\mathtt{channel} \gets \left(\alice, \bob, x, 0,
      \mathtt{delay}\left(\alice\right), \mathtt{delay}\left(\bob\right), 0,
      \mathit{fchid}, \mathit{pchid}\right)$
      \State add \texttt{channel} to \texttt{channels} and
      \texttt{newChannels}(\textit{Bob})
      \State send (\textsc{channelOpened},
      \texttt{receiptFromChannel}(\texttt{channel})) to \textit{Alice}
      \orfeas{or could let Alice to poll}
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{poll}\right)$ from \textit{Alice}:
    \Indent
      \State \aggelos{ read from clock and if more than delay (\textit{Alice}) from previous poll, mark negligent in time interval T.}
      \State \aggelos{ read from ledger and scan for ...  (\texttt{newChannels}, \texttt{closedChannels}) for Alice (just say the below with words) + revoked channels. (the func can detect this using the channel version ).} \aggelos{for revoked channel - call the closed channel code.}
      \State $\mathtt{res.updates} \gets
      \mathtt{pendingUpdates}\left(\alice\right)$
      \State $\mathtt{pendingUpdates}\left(\alice\right) \gets \emptyset$
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{newChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.new}
      \EndFor
      \ForAll{$\mathtt{channel}\text{s} \in \mathtt{closedChannels}$}
        \State add \textsc{receiptFromChannel}(\texttt{channel}) to
        \texttt{res.closed}
      \EndFor
      \State \Return (\textsc{poll}, \texttt{res}) \textit{Alice}
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{pay}, \bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from \textit{Alice}:
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      \texttt{channel} and \textit{Alice} has at least $x$ coins in it.
      \State ensure that $\overrightarrow{\mathtt{path}}$ contains a series of
      channels that all contain at least $x$ to the correct direction \aggelos{maybe weaken this to not checking balances. }
      \State send $\left(\textsc{pay}, \alice, \bob, x,
      \overrightarrow{\mathtt{path}}, \mathtt{receipt}, payid\right)$ to $\mathcal{S}$
    \EndIndent
      \State Upon receiving reply is $\left(\textsc{SettlePay}, payid, Charlie\right)$ from $\mathcal{S}$
      \Indent
      \If{($Charlie \neq \alice$ and $Charlie \notin \{  \mathtt{corrupted}, \mathtt{negligent}\} $) or
      $Charlie \notin \overrightarrow{\mathtt{path}}$}
        \State halt \aggelos{ignore?}
      \Else
                \State update both \texttt{offChainBalance}s \aggelos{for the end points}
        \ForAll{$\mathtt{channel}\text{s} \in \overrightarrow{\mathtt{path}}$
        starting with the one where $Charlie$ pays \aggelos{improve}}
          \State transfer $x$ from the first to the second member \aggelos{if not possible revert all and ignore - increment channel version. }
          \State add \textsc{receiptFromChannel}(\texttt{channel}) \aggelos{Use sc only for labels} to both
          \texttt{pendingUpdate}s
        \EndFor
      \EndIf
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{corrupted}, \alice\right)$ from
    $\mathcal{S}$:
    \Indent
      \State add \textit{Alice} to \texttt{corrupted}
    \EndIndent
    \State

    \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}) from \textit{Alice} \aggelos{(or $\mathcal{S}$) ?? }
    \Indent
      \State ensure that \texttt{receipt} corresponds to an open
      $\mathtt{channel} \in \mathtt{channels}$ that contains \textit{Alice}
      \State send (\textsc{closeChannel}, \texttt{channel}, \textit{Alice}) to
      $\mathcal{S}$
      \State ensure reply is (\textsc{channelClosed}, \texttt{channel})
      \State extract $\alice, \bob, x, y$ from \texttt{channel}
      \State $\mathtt{onChainBalance}\left(\alice\right) \gets
      \mathtt{onChainBalance}\left(\alice\right) + x$
      \State \aggelos{check incoming transaction for Alice, Bob for respective amounts}
      \State $\mathtt{onChainBalance}\left(\bob\right) \gets
      \mathtt{onChainBalance}\left(\bob\right) + y$
      \State $\mathtt{offChainBalance}\left(\alice\right) \gets
      \mathtt{offChainBalance}\left(\alice\right) - x$
      \State $\mathtt{offChainBalance}\left(\bob\right) \gets
      \mathtt{offChainBalance}\left(\bob\right) - y$
      \State send (\textsc{channelClosed}, \texttt{channel}) to \textit{Alice}
    \EndIndent
    \State

    \State At the end of each activation: \Comment{TODO: Discuss}
    \Indent
    \State verify  onChainbalance() for all parties is consistent with ledger (if not roll back the state and ignore command of activation).
  %    \ForAll{$\alice \notin \mathtt{corrupted}$}
  %      \If{the minimum delay(\textit{Alice}) for all her channels is about to pass}
  %        \State check $\mathcal{G}_{\mathrm{Ledger}}$ for revoked closes
  %        \State if found, inform $\mathcal{S}$
  %      \EndIf
  %    \EndFor
    \EndIndent
  \end{algorithmic}
\end{functionality}
