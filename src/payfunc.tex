\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item openChannel(peer, amount, etc)
      \item acceptChannel(peer, amount, etc)
      \item closeChannel(outpoint, etc)
      \item pay(invoice)
      \item checkBalance(invoice?)
    \end{itemize}
    Discussion: I avoided connect(), I added acceptChannel(), what about
    invoices?
  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \State Initialisation:
      \Indent
      \ForAll{$v \in \mathcal{P}$}
        \State $\mathrm{blocked}\left(v\right) \gets 0$
        \State $\mathtt{receipts}\left(v\right) \gets \emptyset$
      \EndFor
      \State $\mathtt{pending}, \mathtt{channels} \gets \emptyset$
      \EndIndent
    \State
    \State Upon receiving $\left(\textsc{openChannel}, Alice, Bob, x, y,
    \mathrm{AliceDelay}, \mathrm{forFundTX}\right)$ from $Alice$:
    \Indent
      \If{there is no $\left(Alice, Bob, x, y, \_, \_, \_\right)$ in
      \texttt{pending}}
        \State $\left(pa_F, sa_F\right) \gets \mathrm{genKey}\left(\right)$
        \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay}, \left(pa_F,
        sa_F\right), \mathrm{forFundTX}\right)$ to \texttt{pending}
        \State $\mathrm{blocked}\left(Alice\right) \leftarrow
        \mathrm{blocked}\left(Alice\right) + x$
        \State \Return $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
        pa_F\right)$ to $Bob$ \Comment{1. TODO: add more keys, as in protocol.
        2. TOASK: return to Bob but Alice called?}
      \EndIf
    \EndIndent
    \State
    \State Upon receiving $\left(\textsc{acceptChannel}, Alice, Bob, x, y,
    \mathrm{BobDelay}\right)$ from $Bob$: \Comment{This message does not exist
    in LND, because only one side funds the channel there.}
    \Indent
      \If{$\left(Alice, Bob, x, y, \_, \_, \_\right) \in \mathtt{pending}$}
        \State assert($\mathcal{G}_{\mathrm{Ledger}}$.balance($Alice$) $\geq
        \mathrm{blocked}\left(Alice\right) + x$)
        \State assert($\mathcal{G}_{\mathrm{Ledger}}$.balance($Bob$) $\geq
        \mathrm{blocked}\left(Bob\right)$)
        \State AliceDelay, $\left(pa_F, sa_F\right)$, forFundTX $\gets$ last 3
        elements in $\left(Alice, Bob, x, y, \_, \_, \_\right)$
        \State remove $\left(Alice, Bob, x, y, \_, \_, \_\right)$ from
        \texttt{pending}
        \State $\mathrm{blocked}\left(Alice\right) \gets
        \mathrm{blocked}\left(Alice\right) - x$
        \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
        reply to $\tau_L$
        \State $\left(pb_F, sb_F\right) \gets \mathrm{genKey}\left(\right)$
        \State send $\left(\mathtt{openChannel}, Alice, Bob, x, y, pa_F, pb_F,
        \mathrm{forFundTX}, \tau_L\right)$ to $\mathcal{A}$ \Comment{TODO: may
        need delays, more keys}
        %\State $\mathtt{tx} \gets \left(\textsc{Funding}\left(x, y, pa_F, pb_F,
        %\mathrm{forFundTX}\right), \tau_L\right)$
        %\State add \texttt{tx} to \texttt{buffer}
        \State Choose a unique channel ID chid
        \State $\mathtt{channel} \gets \left(x, y, Alice, Bob,
        \mathrm{AliceDelay}, \mathrm{BobDelay}, \left(pa_F, sa_F\right),
        \left(pb_F, sb_F\right), 0, \mathrm{chid}\right)$
        \State add \texttt{channel} to \texttt{channels}
        \State $\mathtt{receipt}_{Alice} \gets \left(x, y, Alice, Bob,
        \left(pa_F, sa_F\right), 0, \mathrm{chid}\right)$
        \State add $\mathtt{receipt}_{Alice} \text{ to }
        \mathtt{receipts}\left(Alice\right)$
        \State $\mathtt{receipt}_{Bob} \gets \left(x, y, Alice, Bob,
        \left(pb_F, sb_F\right), 0, \mathrm{chid}\right)$
        \State add $\mathtt{receipt}_{Bob} \text{ to }
        \mathtt{receipts}\left(Bob\right)$
        \State \Return $\mathtt{receipt}_{Alice} \text{ and }
        \mathtt{receipt}_{Bob} \text{ to } Alice \text{ and } Bob \text{
        respectively}$
        %\State send message $\left(\mathrm{opened}, Alice, Bob, x, y, \mathrm{id}\right)$
        %to $Alice$
        %\State send message $\left(\mathrm{opened}, Bob, Alice, y, x, \mathrm{id}\right)$
        %to $Bob$
      \EndIf
    \EndIndent
    \State \Comment{DISCUSS: do we care for things that can happen in the
    all-malicious case?}
    \State \Comment{eg update based on older state}
    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State condition 1: $\overrightarrow{\mathtt{path}}$ consists of players
      where for every adjacent $\left(Carol, Dave\right)$ pair there is a
      $\mathtt{receipt}'$ in \texttt{receipts} with $Carol$ and $Dave$ and where
      $Carol$ has at least $x$. Also, $\mathtt{receipt}'$ corresponds to (has
      the same chid with) an unclosed \textsc{open-channel} transaction that
      exists both in $\mathtt{state}_{Carol}$ and $\mathtt{state}_{Dave}$ (i.e.
      there is no \textsc{close-channel} transaction with a receipt with the
      same chid in either state)
      \State condition 2: \texttt{receipt} is in \texttt{receipts} and contains
      $Alice$ with at least $x$ coins.
      \If{both condition 1 and condition 2 hold}
        \ForAll{$\left(Carol, Dave\right)$ pairs in
        $\overrightarrow{\mathtt{path}}$}
          \State $\mathtt{oldRec} \gets \left(Carol, Dave, y, z,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq},
          \mathrm{chid}\right) \in \mathtt{receipts}$
          \State $\mathtt{newRec} \gets \left(Carol, Dave, y - x, z + x,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq} + 1,
          \mathrm{chid}\right)$
          \State add \texttt{newRec} to \texttt{receipts}
          \State send \texttt{newRec} to $Carol$ and $Dave$
        \EndFor
        \State send message $\left(\textsc{payed}, Bob, x\right)$ to $Alice$
        \State send message $\left(\textsc{payedFrom}, Alice, x\right)$ to $Bob$
      \Else
        \State send message $\left(\textsc{invalidPath}, Bob, x\right)$ to
        $Alice$
      \EndIf
    \EndIndent
    \State
    \State Upon receiving (\textsc{close}, \texttt{receipt}) from $Alice$:
    \Indent
      \If{\texttt{receipt} contains $Alice$ and is contained in \texttt{receipts}}
        \State AliceDelay $\gets$ AliceDelay of \texttt{receipt}
        \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
        reply to $\tau_L$
        \State $\mathtt{tx} \gets
        \left(\textsc{Closing}\left(\mathtt{receipt}\right), \tau_L\right)$
        \State add \texttt{tx} to \texttt{buffer}
        \State Upon receiving (\textsc{close}, \texttt{receipt'}) from $Bob$
        within AliceDelay blocks:
        \If{\texttt{receipt} and \texttt{receipt'} have the same id and
        \texttt{receipt'} has a greater sequence number than \texttt{receipt}}
          \State $\mathtt{tx'} \gets
          \left(\textsc{Revoke}\left(\mathtt{receipt}, \mathtt{receipt'}\right),
          \tau_L\right)$
          \State add \texttt{tx'} to \texttt{buffer} \Comment{TODO: specify
          validate(\texttt{buffer}, \texttt{tx})}
        \EndIf
        \State remove all receipts with the same id as \texttt{receipt} from
        \texttt{receipts}
      \EndIf
    \EndIndent
  \end{algorithmic}
\end{functionality}
