\section{Payment Network Functionality}
  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - preamble}
      Interface: \TODO{check}
      \begin{itemize}
        \item from $\environment$:
        \begin{itemize}
          \item (\textsc{register}, delay, relayDelay)
          \item (\textsc{registered})
          \item (\textsc{openChannel}, \alice, \bob, $x$, \textit{tid})
          \item (\textsc{checkForNew}, \alice, \bob, \textit{tid})
          \item (\textsc{pay}, \bob, $x, \overrightarrow{\mathtt{path}}$,
          \texttt{receipt})
          \item (\textsc{closeChannel}, \texttt{receipt}, \textit{tid})
          \item (\textsc{poll})
          \item (\textsc{pushFulfill}, \textit{pchid})
          \item (\textsc{pushAdd}, \textit{pchid})
          \item (\textsc{commit}, \textit{pchid})
          \item (\textsc{fulfillOnChain})
          \item (\textsc{getNews})
        \end{itemize}
        \item to $\environment$:
        \begin{itemize}
          \item (\textsc{register}, \alice, \texttt{delay}(\alice),
          \texttt{relayDelay}(\alice), pubKey)
          \item (\textsc{registered})
          \item (\textsc{channelClosed}, \texttt{receipt})
          \item (\textsc{news}, newChannels, closedChannels, updatesToReport)
        \end{itemize}
        \item from $\simulator$:
        \begin{itemize}
          \item (\textsc{registerDone}, \alice, pubKey)
          \item (\textsc{corrupted}, \alice)
          \item (\textsc{channelAnnounced}, \alice, $p_{\alice, F}, p_{\bob,
          F}$, \textit{fchid}, \textit{pchid}, \textit{tid})
          \item (\textsc{update}, \texttt{receipt}, \alice)
          \item (\textsc{resolvePays}, \textit{payid}, \texttt{charged})
        \end{itemize}
        \item to $\simulator$:
        \begin{itemize}
          \item (\textsc{register}, \alice, delay, relayDelay, lastPoll)
          \item (\textsc{openChannel}, \alice, \bob, $x$, \textit{fchid},
          \textit{tid})
          \item (\textsc{channelOpened}, \alice, \textit{fchid})
          \item (\textsc{pay}, \alice, \bob, $x,
          \overrightarrow{\mathtt{path}}$, \texttt{receipt}, \textit{payid})
          \item (\textsc{continue})
          \item (\textsc{closeChannel}, \textit{fchid}, \alice)
          \item (\textsc{poll}, $\Sigma_{\alice}$, \alice)
          \item (\textsc{pushFulfill}, \textit{pchid}, \alice)
          \item (\textsc{pushAdd}, \textit{pchid}, \alice)
          \item (\textsc{commit}, \textit{pchid}, \alice)
          \item (\textsc{fulfillOnChain}, $t$, \alice)
        \end{itemize}
      \end{itemize}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:interface}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - support}
      \begin{algorithmic}[1]
        \State Initialisation:
        \Indent
          \State $\mathtt{channels}, \mathtt{pendingPay}, \mathtt{pendingOpen},
          \mathtt{corrupted}, \Sigma \gets \emptyset$
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{register}, \mathrm{delay},
        \mathrm{relayDelay}\right)$ from \alice:
        \Indent
          \State $\mathtt{delay}\left(\alice\right) \gets \mathrm{delay}$
          \Comment{Must check chain at least once every \texttt{delay}(\alice)
          blocks}
          \State $\mathtt{relayDelay}\left(\alice\right) \gets
          \mathrm{relayDelay}$
          \State $\mathtt{updatesToReport}\left(\alice\right),
          \mathtt{newChannels}\left(\alice\right) \gets \emptyset$
          \State $\mathtt{polls}\left(\alice\right) \gets \emptyset$
          \State $\mathtt{focs}\left(\alice\right) \gets \emptyset$
          \State send (\textsc{read}) to \ledger{} as \alice{}, store reply to
          $\Sigma_{\alice}$, add $\Sigma_{\alice}$ to $\Sigma$ and add largest
          block number to \texttt{polls}(\alice)
          \label{alg:fpaynet:support:lastpoll}
          \State \texttt{checkClosed}($\Sigma_{\alice}$)
          \State send $\left(\textsc{register}, \alice, \mathrm{delay},
          \mathrm{relayDelay}, \mathrm{lastPoll}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{registerDone}, \alice,
        \mathrm{pubKey}\right)$ from \simulator:
        \Indent
          \State $\mathtt{pubKey}\left(\alice\right) \gets \mathrm{pubKey}$
          \State send (\textsc{register}, \alice, \texttt{delay}(\alice),
          \texttt{relayDelay}(\alice), pubKey) to \alice
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{registered}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \State \texttt{checkClosed}($\Sigma_{\alice}$)
          \State assign the sum of all output values that are exclusively
          spendable by \alice{} to \texttt{onChainBalance}
          \State send (\textsc{registered}) to \alice
        \EndIndent
        \Statex

        \State Upon receiving any message except for
        $\left(\textsc{register}\right)$ from \alice:
        \Indent
          \State ignore message if \alice{} has not registered
          \label{alg:fpaynet:support:unreg}
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{corrupted}, \alice\right)$ from
        \simulator:
        \Indent
          \State add \alice{} to \texttt{corrupted}
          \State for the rest of the execution, upon receiving any message for
          \alice{}, bypass normal execution and simply forward it to
          \simulator
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:support}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - open}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{openChannel}, \alice, \bob, x,
        \mathit{tid}\right)$ from \alice:
        \Indent
          \State ensure \textit{tid} hasn't been used by \alice{} for opening
          another channel before
          \label{alg:fpaynet:open:valid}
          \State choose unique channel ID \textit{fchid}
          \State $\mathtt{pendingOpen}\left(\mathit{fchid}\right) \gets
          \left(\alice, \bob, x, \mathit{tid}\right)$
          \State send $\left(\textsc{openChannel}, \alice, \bob, x,
          \mathit{fchid}, \mathit{tid}\right)$ to \simulator
        \EndIndent
        \Statex

        \State Upon receiving $\left(\textsc{channelAnnounced}, \alice,
        p_{\alice, F}, p_{\bob, F}, \mathit{fchid}, \mathit{pchid},
        \mathit{tid}\right)$ from \simulator:
        \Indent
          \State ensure that there is a \texttt{pendingOpen}(\textit{fchid})
          entry with temporary id \textit{tid}
          \label{alg:fpaynet:announced:valid}
          \State add ``\alice{} announced'', $p_{\alice, F}, p_{\bob, F}$,
          \textit{pchid} to \texttt{pendingOpen}(\textit{fchid})
          \label{alg:fpaynet:announced:add}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{checkForNew}, \alice, \bob, \textit{tid})
        from \alice:
        \Indent
          \State ensure there is a matching \texttt{channel} in
          \texttt{pendingOpen}(\textit{fchid}), marked with ``\alice{}
          announced''
          \label{alg:fpaynet:checkForNew:valid}
          \State $\left(\mathrm{funder}, \mathrm{fundee}, x, p_{\alice, F},
          p_{\bob, F}\right) \gets
          \mathtt{pendingOpen}\left(\mathit{fchid}\right)$
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \State \texttt{checkClosed}($\Sigma_{\alice}$)
          \label{alg:fpaynet:checkForNew:read:alice}
          \State ensure that there is a TX $F \in \Sigma_{\alice}$ with a
          $\left(x, \left(p_{\mathrm{funder}, F} \wedge p_{\mathrm{fundee},
          F}\right)\right)$ output
          \label{alg:fpaynet:checkForNew:included}
          \State mark \texttt{channel} with ``waiting for
          \textsc{fundingLocked}''
          \State send (\textsc{fundingLocked}, \alice, $\Sigma_{\alice}$,
          \textit{fchid}) to \simulator
          \label{alg:fpaynet:checkForNew:sim}
        \EndIndent
        \Statex


        \State Upon receiving (\textsc{fundingLocked}, \textit{fchid}) from
        \simulator:
        \Indent
          \State ensure a \texttt{channel} is in
          \texttt{pendingOpen}(\textit{fchid}), marked with ``waiting for
          \textsc{fundingLocked}'' and replace mark with ``waiting for
          \textsc{channelOpened}''
          \State send (\textsc{read}) to \ledger{} as \bob{} and store reply
          to $\Sigma_{\bob}$
          \State \texttt{checkClosed}($\Sigma_{\bob}$)
          \label{alg:fpaynet:checkForNew:read:bob}
          \State ensure that there is a TX $F \in \Sigma_{\bob}$ with a
          $\left(x, \left(p_{\mathrm{funder}, F} \wedge p_{\mathrm{fundee},
          F}\right)\right)$ output
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{newChannels}(\bob)
          \label{alg:fpaynet:fundingLocked:report}
          \State send (\textsc{fundingLocked}, \bob, $\Sigma_{\bob}$,
          \textit{fchid}) to \simulator
          \label{alg:fpaynet:fundingLocked:sim}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{channelOpened}, \textit{fchid}) from
        \simulator:
        \Indent
          \State ensure a \texttt{channel} is in
          \texttt{pendingOpen}(\textit{fchid}), marked with ``waiting for
          \textsc{channelOpened}'' and remove mark
          \State $\mathrm{offChainBalance}\left(\mathrm{funder}\right) \gets
          \mathrm{offChainBalance}\left(\mathrm{funder}\right) + x$
          \orfeas{remove on/offChainBalance?}
          \State $\mathrm{onChainBalance}\left(\mathrm{funder}\right) \gets
          \mathrm{offChainBalance}\left(\mathrm{funder}\right) - x$
          \State $\mathtt{channel} \gets \left(\mathrm{funder}, \mathrm{fundee},
          x, 0, 0, \mathit{fchid}, \mathit{pchid}\right)$
          \State add \texttt{channel} to \texttt{channels}
          \State add \texttt{receipt}(\texttt{channel}) to
          \texttt{newChannels}(\alice)
          \label{alg:fpaynet:channelOpened:report}
          \State clear \texttt{pendingOpen}(\textit{fchid}) entry
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:open}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - pay}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{pay}, \bob, x,
        \overrightarrow{\mathtt{path}}\right)$ from \alice:
        \Indent
          \State choose unique payment ID \textit{payid}
          \State add $\left(\alice, \bob, x, \overrightarrow{\mathtt{path}},
          \mathit{payid}\right)$ to \texttt{pendingPay}
          \State send $\left(\textsc{pay}, \alice, \bob, x,
          \overrightarrow{\mathtt{path}}, \mathit{payid}, \textsc{state},
          \Sigma\right)$ to \simulator
          \label{alg:fpaynet:pay:send}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{update}, \texttt{receipt}, \alice) from
        \simulator:
        \Indent
          \State add \texttt{receipt} to \texttt{updatesToReport}(\alice)
          \Comment{trust \simulator{} here, check on \textsc{resolvePays}}
          \label{alg:fpaynet:update}
          \State send (\textsc{continue}) to \simulator
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:pay}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - resolve payments}
      \begin{algorithmic}[1]
        \State Upon receiving $\left(\textsc{resolvePays},
        \mathtt{charged}\right)$ from \simulator:
        \Comment{after first sending \textsc{pay}, \textsc{pushFulfill},
        \textsc{pushAdd}, \textsc{commit}}
        \Indent
          \ForAll{$\alice \text{ keys} \in \texttt{charged}$}
            \ForAll{$\left(\dave, \mathit{payid}\right) \in
            \mathtt{charged}\left(\alice\right)$}
              \State retrieve $\left(\alice, \bob, x,
              \overrightarrow{\mathtt{path}}\right)$ with ID \textit{payid} and
              remove it from \texttt{pendingPay}
              \If{$\dave{} = \bot$}
                \State continue with next loop iteration
              \EndIf
              \State calculate \texttt{IncomingCltvExpiry},
              \texttt{OutgoingCltvExpiry} of \dave{} (as in
              Fig.~\ref{alg:protocol:pay:invoice},
              l.~\ref{alg:protocol:pay:invoice:cltv})
              \If{$\dave{} \neq \alice{} \wedge \dave{} \notin
              \mathtt{corrupted} \ \wedge$ \\ $((\Sigma_{\dave}$ contains in
              block $h_{\mathtt{tx}}$ an old $\mathtt{remoteCom}_m$ that does
              not contain the HTLC and a tx that spends the delayed output of
              $\mathtt{remoteCom}_m \ \wedge$ \\ \texttt{polls}(\dave) contains
              an element in $[h_{\mathtt{tx}} + k, h_{\mathtt{tx}} + k +
              \mathtt{delay}\left(\dave\right) - 1]) \ \vee$ \\
              ($\Sigma_{\dave}$ does not contain an old $\mathtt{remoteCom}_m \
              \wedge$ \texttt{polls}(\dave) contains two elements in
              $[\mathtt{OutgoingCltvExpiry} + k + \tochain{} + 1,
              \mathtt{IncomingCltvExpiry} - k - \tochain{}]$ that have a
              difference of at least $k + \tochain{} \ \wedge$ \\
              \texttt{focs}(\dave) contains $\mathtt{IncomingCltvExpiry} - k -
              \tochain{} \ \wedge$ \\ the element in \texttt{polls}(\dave) was
              added before the element in \texttt{focs}(\dave)))}
              \label{alg:fpaynet:resolvepay:haltcond}
                \State halt
                \label{alg:fpaynet:resolvepay:dave:halt}
              \EndIf
              \State run code of Fig.~\ref{alg:fpaynet:resolvepay:loops}
              \If{$\dave{} \notin \mathtt{corrupted}$}
                \State $\mathtt{offChainBalance}\left(\dave\right) \gets
                \mathtt{offChainBalance}\left(\dave\right) - x$
              \EndIf
              \State $\mathtt{offChainBalance}\left(\bob\right) \gets
              \mathtt{offChainBalance}\left(\bob\right) + x$
            \EndFor
          \EndFor
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:resolvepay}
  \end{figure}

  \begin{figure}[H]
    \begin{titlebox}{\normalfont Loop over payment hops for update and
    check}{roundbox}{normal}
      \begin{algorithmic}[1]
        \ForAll{open $\mathtt{channel}\text{s} \in
        \overrightarrow{\mathtt{path}}$ that are not in any
        \texttt{closedChannels}, starting from the one where \dave{} pays}
        \label{alg:fpaynet:resolvepay:loops:update:loop}
          \State in the first iteration, \texttt{payer} is \dave. In
          subsequent iterations, \texttt{payer} is the unique player that
          has received but has not given. The other \texttt{channel} party
          is \texttt{payee}
          \If{\texttt{payer} has $x$ or more in \texttt{channel}}
            \State update \texttt{channel} to the next version and
            transfer $x$ from \texttt{payer} to \texttt{payee}
            \label{alg:fpaynet:resolvepay:loops:update:do}
          \Else
            \State revert all updates done in this loop
          \EndIf
        \EndFor
        \ForAll{updated \texttt{channel}s in the previous loop}
        \label{alg:fpaynet:resolvepay:loops:halt:loop}
          \State ensure that a corresponding element has been added to
          the \texttt{updatesToReport} of each honest counterparty,
          otherwise halt
          \label{alg:fpaynet:resolvepay:loops:halt:do}
        \EndFor
      \end{algorithmic}
    \end{titlebox}
    \caption{}
    \label{alg:fpaynet:resolvepay:loops}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - close}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{closeChannel}, \texttt{receipt},
        \textit{tid}) from \alice
        \Indent
          \State ensure that there is a $\mathtt{channel} \in \mathtt{channels}
          : \mathtt{receipt}\left(\mathtt{channel}\right) = \mathtt{receipt}$
          with ID \textit{tid}
          \State retrieve \textit{fchid} from \texttt{channel}
          \label{alg:fpaynet:close:retrieve}
          \State add (\textit{fchid}, \texttt{receipt}(\texttt{channel}),
          $\bot$) to \texttt{pendingClose}(\alice)
          \label{alg:fpaynet:close:mark}
          \State do not serve any other (\textsc{pay} or \textsc{closeChannel})
          message from \alice{} for this channel
          \label{alg:fpaynet:close:noserve}
          \State send (\textsc{closeChannel}, \texttt{receipt}, \textit{tid},
          \alice) to \simulator
          \label{alg:fpaynet:close:send}
        \EndIndent
        \Statex

        \Function{checkClosed}{$\Sigma_{\alice}$} \Comment{Called after every
        (\textsc{read}), ensures requested closes eventually happen}
        \label{alg:fpaynet:close:func:start}
          \ForAll{entries $(\mathit{fchid}, \mathtt{receipt}, h) \in
          \mathtt{pendingClose}(\alice) \cup \mathtt{closedChannels}(\alice)$}
            \If{there is a closing transaction in $\Sigma_{\alice}$ for open
            \texttt{channel} with ID \textit{fchid} with a balance that
            corresponds to \texttt{receipt}}
              \State let $x, y$ the balances of \alice{} and the
              \texttt{channel} counterparty \bob{} respectively
              \State $\mathrm{offChainBalance}\left(\alice\right) \gets
              \mathrm{offChainBalance}\left(\alice\right) + x$
              \State $\mathrm{onfChainBalance}\left(\alice\right) \gets
              \mathrm{onChainBalance}\left(\alice\right) - x$
              \State $\mathrm{offChainBalance}\left(\bob\right) \gets
              \mathrm{offChainBalance}\left(\bob\right) + y$
              \State $\mathrm{onChainBalance}\left(\bob\right) \gets
              \mathrm{onChainBalance}\left(\bob\right) - y$
              \State remove \texttt{channel} from \texttt{channels}
              \State remove entry from \texttt{pendingClose}(\alice)
              \If{there is an (\textit{fchid}, \_, \_) entry in
              \texttt{pendingClose}(\bob)}
                \State remove it from \texttt{pendingClose}(\bob)
              \EndIf
            \ElsIf{there is a closing transaction in block of height $h$ in
            $\Sigma_{\alice}$ for open \texttt{channel} with ID \textit{fchid}
            with a balance that does not correspond to the \texttt{receipt} and
            the delayed output has been spent by the counterparty}
              \If{\texttt{polls}(\alice) contains an entry in $[h + k, h + k +
              \mathtt{delay}(\alice) - 1]$}
              \label{alg:fpaynet:close:func:ifmalicious}
                \State halt
                \label{alg:fpaynet:close:func:malicious}
              \EndIf
            \ElsIf{there is no such closing transaction $\wedge \ h = \bot$}
              \State assign largest block number of $\Sigma_{\alice}$ to $h$ of
              entry
            \ElsIf{there is no such closing transaction $\wedge \ h \neq \bot \
            \wedge$ (largest block number of $\Sigma_{\alice}) \geq h +
            \tochain{}$}
            \label{alg:fpaynet:close:func:ifidle}
              \State halt
              \label{alg:fpaynet:close:func:idle}
            \EndIf
          \EndFor
        \EndFunction
        \label{alg:fpaynet:close:func:end}
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:close}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - poll}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{poll}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{} and store reply
          to $\Sigma_{\alice}$
          \State add largest block number in $\Sigma_{\alice}$ to
          \texttt{polls}(\alice)
          \label{alg:fpaynet:poll:height}
          \State \texttt{checkClosed}($\Sigma_{\alice}$)
          \label{alg:fpaynet:poll:read}
          \ForAll{$\mathtt{channel}s \in \Sigma_{\alice}$ that contain \alice{}
          and are maliciously closed by a remote commitment \texttt{tx} (one
          with an older channel version than the irrevocably committed one) in
          block with height $h_{\mathtt{tx}}$}
          \label{alg:fpaynet:poll:malicious}
            \If{the delayed output (of the counterparty) has been spent AND
            \texttt{polls}(\alice) has an element in $\left[h_{\mathtt{tx}} + k,
            h_{\mathtt{tx}} + k + \mathtt{delay}\left(\alice\right) - 1\right]$}
            \label{alg:fpaynet:poll:badevent}
              \State halt \Comment{\alice{} wasn't negligent but couldn't punish
              \label{alg:fpaynet:poll:halt}
              - bad event}
            \EndIf
          \EndFor
          \State send (\textsc{poll}, $\Sigma_{\alice}$, \alice) to \simulator
          \label{alg:fpaynet:poll:send}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:poll}
  \end{figure}

  \begin{figure}[H]
    \begin{systembox}{\fpaynet{} - daemon messages}
      \begin{algorithmic}[1]
        \State Upon receiving (\textsc{pushFulfill}, \textit{pchid}) from
        \alice:
        \Indent
          \State send (\textsc{pushFulfill}, \textit{pchid}, \alice,
          \textsc{state}, $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:fulfill}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{pushAdd}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{pushAdd}, \textit{pchid}, \alice, \textsc{state},
          $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:add}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{commit}, \textit{pchid}) from \alice:
        \Indent
          \State send (\textsc{commit}, \textit{pchid}, \alice, \textsc{state},
          $\Sigma$) to \simulator
          \label{alg:fpaynet:daemon:commit}
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{fulfillOnChain}) from \alice:
        \Indent
          \State send (\textsc{read}) to \ledger{} as \alice{}, store reply to
          $\Sigma_{\alice}$ and assign largest block number to $t$
          \State \texttt{checkClosed}($\Sigma_{\alice}$)
          \label{alg:fpaynet:daemon:foc:read}
          \State add $t$ to \texttt{focs}(\alice)
          \State send (\textsc{fulfillOnChain}, $t$, \alice) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{closedChannel}, \texttt{channel}, \alice)
        from \simulator:
        \Indent
          \State add (\textit{fchid} of channel,
          \texttt{receipt}(\texttt{channel}), $\bot$) to
          \texttt{closedChannels}(\alice)
          \Comment{trust \simulator{} here, check on \texttt{checkClosed}()}
          \label{alg:fpaynet:closedChannel:report}
          \State send (\textsc{continue}) to \simulator
        \EndIndent
        \Statex

        \State Upon receiving (\textsc{getNews}) from \alice:
        \label{alg:fpaynet:getnews}
        \Indent
          \State clear \texttt{newChannels}(\alice),
          \texttt{closedChannels}(\alice), \texttt{updatesToReport}(\alice) and
          send them to \alice{} with message name \textsc{news}, stripping
          \textit{fchid} and h from \texttt{closedChannels}(\alice)
          \label{alg:fpaynet:getnews:send}
        \EndIndent
      \end{algorithmic}
    \end{systembox}
    \caption{}
    \label{alg:fpaynet:daemon}
  \end{figure}
