\begin{functionality}{$\mathcal{F}_{\mathrm{PayNet}}$}
  \label{alg:payfunc}
  \funcsection{Interface (messages from $\mathcal{E}$)}
    \begin{itemize}
      \item register(pubKey, hashList)
      \item setDelay(delay)
      \item createChannel(self, peer, selfCoins, peerCoins, selfDelay, forFundTX)
      \item endorseChannel(peer, self, peerCoins, selfCoins, selfDelay)
      \item breakChannel(receipt)
      \item pay(peer, coins, path, receipt)
    \end{itemize}

  \funcsection{Pseudocode}
  \begin{algorithmic}[1]
    \State Initialisation:
      \Indent
      \ForAll{$v \in \mathcal{P}$}
        \State $\mathtt{blocked}\left(v\right),
        \mathtt{onChainBalance}\left(v\right), \mathtt{delay}\left(v\right)
        \gets 0$
        \State $\mathtt{pubKey}\left(v\right), \mathtt{hashList}\left(v\right)
        \gets \bot$
      \EndFor
      \State $\mathtt{pending}, \mathtt{channels} \gets \emptyset$
      \EndIndent
    \State

    \State Upon receiving $\left(\textsc{register}, \mathrm{pubKey},
    \mathrm{hashList}\right)$ from $Alice$:
    \Indent
      \State ensure that $\mathtt{pubKey}\left(v\right) =
      \mathtt{hashList}\left(v\right) = \bot$
      \State ensure that pubKey is not assigned to another player
      \State $\mathtt{pubKey}\left(v\right) \gets \mathrm{pubKey}$
      \State $\mathtt{hashList}\left(v\right) \gets \mathrm{hashList}$
      \State send (\textsc{Read}) to $\mathcal{G}_{\mathrm{Ledger}}$ as $Alice$
      and assign reply to $\Sigma_{Alice}$
      \State count all coins currently exclusively spendable by $Alice$ in
      $\Sigma_{Alice}$ and assign result to
      $\mathtt{onChainBalance}\left(Alice\right)$
    \EndIndent
    \State

    \State Upon receiving any message from $Alice$:
    \Indent
      \State recalculate all on-chain balances for players that have registered
      (for the case of expired timelocks)
      \State ignore message if $Alice$ has not registered
    \EndIndent
    \State

    \State BEGIN LIGHTNING FUNCTIONALITY-SPECIFIC
    \State Upon receiving $\left(\textsc{setDelay}, \mathrm{AliceDelay}\right)$
    from $Alice$:
    \Indent
      \State $\mathtt{delay}\left(v\right) \gets \mathrm{AliceDelay}$
    \EndIndent
    \State

    \State END LIGHTNING FUNCTIONALITY-SPECIFIC

    \State BEGIN ROBUST FUNCTIONALITY-SPECIFIC
    \State Upon receiving $\left(\textsc{createChannel}, Alice, Bob, x, y,
    \mathrm{AliceDelay}, \mathrm{forFundTX}\right)$ from $Alice$:
    \Indent
      \State ensure that forFundTX has inputs spendable by $Alice$ of total
      value at least $x$ and by $Bob$ of total value at least $y$
      \State ensure that it is possible to add a $x + y$-valued output to
      forFundTX
      \State ensure that there is no $\left(Alice, Bob, \_, \_, \_, \_\right)$
      in \texttt{pending}
      \State choose unique temporary ID tempid
      \State add $\left(Alice, Bob, x, y, \mathrm{AliceDelay},
      \mathrm{forFundTX}, \mathrm{tempid}\right)$ to \texttt{pending}
      \State $\mathtt{blocked}\left(Alice\right) \leftarrow
      \mathtt{blocked}\left(Alice\right) + x$
      \State \Return $\left(\textsc{endorseChannel}, Alice, Bob, x, y,
      \mathrm{AliceDelay}, \mathrm{tempid}\right)$ to $Bob$ \Comment{DISCUSS:
      return to Bob but Alice called?}
    \EndIndent
    \State

    \State Upon receiving $\left(\textsc{endorseChannel}, Alice, Bob, x, y,
    \mathrm{BobDelay}, \mathrm{tempid}\right)$ from $Bob$: \Comment{This message
    does not exist in LND, because only one side funds the channel there.}
    \Indent
      \State ensure that $\left(Alice, Bob, x, y, \_, \_, \mathrm{tempid}\right)
      \in \mathtt{pending}$
      \State ensure that $\mathtt{onChainBalance}\left(Alice\right) \geq
      \mathtt{blocked}\left(Alice\right) + x$
      \State ensure that $\mathtt{onChainBalance}\left(Bob\right) \geq
      \mathtt{blocked}\left(Bob\right)$
      \State AliceDelay, forFundTX $\gets$ last 2 elements in $\left(Alice,
      Bob, x, y, \_, \_\right)$
      \State remove $\left(Alice, Bob, x, y, \_, \_, \mathrm{tempid}\right)$
      from \texttt{pending}
      \State $\mathrm{onChainBalance}\left(Alice\right) \gets
      \mathrm{onChainBalance}\left(Alice\right) - x$
      \State $\mathrm{onChainBalance}\left(Bob\right) \gets
      \mathrm{onChainBalance}\left(Alice\right) - y$
      \State $\mathtt{blocked}\left(Alice\right) \gets
      \mathtt{blocked}\left(Alice\right) - x$
      \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
      reply to $\tau$
      \State send $\left(\textsc{openChannel}, Alice, Bob, x, y,
      \mathrm{forFundTX}, \tau\right)$ to $\mathcal{A}$ \Comment{Keys
      generated by simulator TODO: may need delays}
      % for Simulator
      %\State $\mathtt{tx} \gets \left(\textsc{Funding}\left(x, y, pa_F, pb_F,
      %\mathrm{forFundTX}\right), \tau_L\right)$
      %\State add \texttt{tx} to \texttt{buffer}
      \State forget tempid
      \State choose a unique channel ID chid
      \State $\mathtt{channel} \gets \left(Alice, Bob, x, y,
      \mathrm{AliceDelay}, \mathrm{BobDelay}, 0, \mathrm{chid}\right)$
      \State add \texttt{channel} to \texttt{channels}
      \State $\mathtt{receipt} \gets \left(Alice, Bob, x, y, 0,
      \mathrm{chid}\right)$
      \State \Return $\left(\textsc{Receipt}, \mathtt{receipt}\right) \text{
      to } Alice \text{ and } Bob$
      \Comment{Multiple returns?}
    \EndIndent
    \State END ROBUST FUNCTIONALITY-SPECIFIC

    \State Upon receiving $\left(\textsc{pay}, Bob, x,
    \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from $Alice$:
    \Indent
      \State send $\left(\textsc{pay}, Bob, x, \overrightarrow{\mathtt{path}},
      \mathtt{receipt}\right)$ to $\mathcal{A}$
      \State receive reply $\left(\left\{\textsc{okPay}, \textsc{noPay}\right\},
      Bob, x, \overrightarrow{\mathtt{path}}, \mathtt{receipt}\right)$ from
      $\mathcal{A}$
      \State condition 1: reply is \textsc{okPay}
      \State condition 2: $\overrightarrow{\mathtt{path}}$ consists of players
      where for every adjacent $\left(Carol, Dave\right)$ pair there is a
      \texttt{channel} in \texttt{channels} with $Carol$ and $Dave$ and where
      $Carol$ has at least $x$.
      \State condition 3: \texttt{receipt} has the same ID and sequence number
      as a channel in \texttt{channels} where $Alice$ has at least $x$ coins.
      \If{both condition 1, 2 and 3 hold}
        \ForAll{$\left(Carol, Dave\right)$ pairs in
        $\overrightarrow{\mathtt{path}}$}
          \State $\mathtt{oldCh} \gets \left(Carol, Dave, y, z,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq},
          \mathrm{chid}\right) \in \mathtt{channels}$
          \State $\mathtt{newCh} \gets \left(Carol, Dave, y - x, z + x,
          \mathrm{CarolDelay}, \mathrm{DaveDelay}, \mathrm{seq} + 1,
          \mathrm{chid}\right)$
          \State add \texttt{newCh} to \texttt{channels}
          \State send $\left(Carol, Dave, y - x, z + x, \mathrm{seq} + 1,
          \mathrm{chid}\right)$ to $Carol$ and $Dave$ \Comment{DISCUSS: sending,
          not returning. TODO: add message label}
        \EndFor
        \State send message $\left(\textsc{payed}, Bob, x\right)$ to $Alice$
        \State send message $\left(\textsc{payedFrom}, Alice, x\right)$ to $Bob$
      \Else \Comment{DISCUSS: which messages to send and how?}
        \State send message $\left(\textsc{invalidPath}, Bob, x\right)$ to
        $Alice$
      \EndIf
    \EndIndent
    \State

    \State Upon receiving (\textsc{breakChannel}, \texttt{receipt}) from $Alice$:
    \Indent
      \State ensure that \texttt{receipt} contains $Alice$ and corresponds to a
      \texttt{channel} in \texttt{channels} (i.e. there is a \texttt{channel}
      that contains the \texttt{receipt} elements)
      \State AliceDelay $\gets$ AliceDelay of \texttt{channel}
      \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
      reply to $\tau$
      \State send $\left(\textsc{closeChannel}, \mathtt{channel},
      \tau\right)$ to $\mathcal{A}$
      \State Upon receiving (\textsc{breakChannel}, \texttt{receipt'}) from
      $Bob$ within AliceDelay blocks: \Comment{DISCUSS: what is a block?}
      \If{\texttt{receipt'} corresponds to a \texttt{channel'} in
      \texttt{channels} and (\texttt{receipt}, \texttt{receipt'}) have the
      same chid and \texttt{receipt'} has a greater sequence number than
      \texttt{receipt}}
        \State $\mathrm{onChainBalance}\left(Bob\right) \gets
        \mathrm{onChainBalance}\left(Bob\right) + x$, where $x$ is the total
        coins in $\texttt{channel'}$
        \State send \textsc{Read} to $\mathcal{G}_{\mathrm{Clock}}$ and assign
        reply to $\tau'$
        \State send $\left(\textsc{revokeChannel}, \mathtt{channel'},
        \tau'\right)$ to $\mathcal{A}$
      \Else
        \State $x, y \gets Alice$'s and $Bob$'s coins in \texttt{channel}
        respectively
        \State $\mathrm{onChainBalance}\left(Alice\right) \gets
        \mathrm{onChainBalance}\left(Alice\right) + x$
        \State $\mathrm{onChainBalance}\left(Bob\right) \gets
        \mathrm{onChainBalance}\left(Bob\right) + y$
      \EndIf
      \State remove all items in \texttt{channels} with the same chid as
      \texttt{receipt}
    \EndIndent
  \end{algorithmic}
\end{functionality}
