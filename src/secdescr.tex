\section{Security analysis}
\label{sec:ov-security-analysis}
  \begin{theorem}[Lightning Payment Network Security]
    The protocol $\Pi_{\mathrm{LN}}$ realises $\fpaynet$ given a global
    functionality $\ledger$ and assuming the security of the underlying digital
    signature, identity-based signature, combined digital signature and PRF.
    Specifically,
    \label{theorem:simulation}
    \ifelseieee{
      \begin{gather*}
        \forall k \in \mathbb{N}, \text{ PPT } \environment, \\
        |\Pr[\textsc{Exec}^{\ledger}_{\Pi_{\mathrm{LN}}, \adversary_{\mathrm{d}},
        \environment} = 1] - \Pr[\textsc{Exec}^{\fpaynet, \ledger}_{\simulator,
        \environment} = 1]| \leq \\
        2nm \mathrm{E \mhyphen ds}(k) + 6np \mathrm{E \mhyphen ids}(k) + 2nmp
        \mathrm{E \mhyphen share}(k) + \\
        + 2nm \mathrm{E \mhyphen master}(k)+ 2 \mathrm{E \mhyphen prf}(k)
        \enspace,
      \end{gather*}
    }{
      \begin{gather*}
        \forall k \in \mathbb{N}, \text{ PPT } \environment,
        |\Pr[\textsc{Exec}^{\ledger}_{\Pi_{\mathrm{LN}}, \adversary_{\mathrm{d}},
        \environment} = 1] - \Pr[\textsc{Exec}^{\fpaynet, \ledger}_{\simulator,
        \environment} = 1]| \leq \\
        2nm  \mathrm{E \mhyphen ds}(k)  + 6np  \mathrm{E \mhyphen ids}(k) + 2nmp
        \mathrm{E \mhyphen share}(k) + 2nm \mathrm{E \mhyphen master}(k)+  2
        \mathrm{E \mhyphen prf}(k)  \enspace,
      \end{gather*}
    }
    where $n$ is the maximum number of registered users, $m$ is the maximum
    number of channels that a user is involved in, $p$ is the maximum number of
    times that a channel is updated and the ``E-'' terms correspond to the
    insecurity bounds of the primitives.
  \end{theorem}

  \begin{proofsketch}
    The proof is done in 5 steps. In Lemma~\ref{lemma:dummy} we define a
    simulator $\simulator_{\mathrm{LN}}$ that internally simulates a full
    execution of $\Pi_{\mathrm{LN}}$ for each player, and a ``dummy''
    functionality that acts as a simple relay between \environment{} and
    $\simulator_{\mathrm{LN}}$. We argue that this version of the ideal world
    trivially produces the exact same messages for \environment{} as the real
    world.

    In each subsequent step, we incrementally move responsibilities from the
    simulator to the functionality. Each step defines a different functionality
    that handles some additional messages from \environment{} exactly like
    \fpaynet, until the last step (Lemma~\ref{lemma:close}) where we use
    \fpaynet{} itself. Correspondingly, the simulator of each step is adapted so
    that the new ideal execution is computationally indistinguishable from the
    previous one.

    Lemma~\ref{lemma:reg} lets $\mathcal{F}$ handle registration messages,
    along with the corruption messages from \simulator. In Lemma~\ref{lemma:open}
    the functionality additionally handles messages related to channel opening. It
    behaves like \fpaynet, but does not execute \texttt{checkClosed}().
    Lemma~\ref{lemma:pay} has the functionality handle all messages sent during
    channel updates. Lastly, Lemma~\ref{lemma:close} has the entire \fpaynet{} as
    its functionality, by incorporating the message for closing a channel,
    executing \texttt{checkClosed}() normally and handing the message that returns
    to \environment{} the receipts for newly opened, updated and closed
    channels. The last two steps introduce a probability of failure in case
    the various types of signatures used in  $\Pi_{\mathrm{LN}}$ are forged. We analyze these cases separately and argue that, if
    such forgeries do not happen, the emulation is perfect. Therefore we can
    calculate the concrete security bounds shown in the theorem.
  \end{proofsketch}
  For the formal proof, we refer the reader to Appendix~\ref{appendix:secproof}.

  An appealing security guarantee provided by \fpaynet{} is the following:
  \TODO{Remove $k$ if unneeded}
  \begin{corollary}[\fpaynet{} provides Balance Security]
    \begin{equation*}
      \forall k \in \mathbb{N}, \forall \adversary{} \in \mathtt{PPT},
      \Pr\left[\mathsf{BAL \mhyphen SEC}^{\adversary}\left(1^k\right) = 1\right]
      \leq \mathit{negl}\left(k\right) \enspace,
    \end{equation*}
  \end{corollary}
  where $\mathsf{BAL \mhyphen SEC}$ is defined in Figure~\ref{game:bal-sec}.

  \begin{figure}[!htbp]
    \begin{gamebox}{$\mathsf{BAL \mhyphen SEC}^{\adversary}\left(1^k\right)$}
      Let $G = (\mathrm{P}, E)$ the current payment network, where $E$ consists
      of all channels that have been reported as open and not as closed (as a
      reply from \fpaynet{} to a (\textsc{getNews}) query). Let
      $\mathit{tup}(E)$ the set of non-repeating tuples of channels in $E$. Let
      $a = (2 + r)\mathtt{windowSize}$ be the maximum number of blocks needed
      before a transaction submitted to \ledger{} is finalised (c.f.
      Proposition~\ref{prop:tochain}).
      \begin{algorithmic}[1]
        \Procedure{channelLifecycle}{}
          \State \Comment{open}
          \State $\bob \overset{\$}{\gets} \mathcal{P}, c_{\mathrm{init}}
          \overset{\$}{\gets} [0, c_{\mathrm{onchain}}], \mathit{tid}
          \overset{\$}{\gets} \{0, 1\}^k$
          \State send (\textsc{openChannel}, \alice, \bob, $c$, \textit{tid}) to
          \alice
          \Repeat
            \State send (\textsc{getNews}) to \alice{}
            \State extract \texttt{newChannels} from reply
          \Until{$\exists (\alice: c, \bob: 0, \mathit{pchid}) \in
          \mathtt{newChannels}$}
          \State $\mathtt{receipt} \gets (\alice: c, \bob: 0, \mathit{pchid})$
          \State $c_{\mathrm{onchain}} \gets c_{\mathrm{onchain}} - c$
          \Statex
          \State \Comment{send and receive}
          \For{$i$ from $1$ to an arbitrary $n_{\mathrm{pays}} \in \mathbb{N}$}
            \State $\overrightarrow{\mathtt{path}} \overset{\$}{\gets}
            \mathit{tup}(E)$
            \State flip a coin
            \If{coin lands heads}
              \State $c_i \overset{\$}{\gets} [-c, 0)$
              \State send (\textsc{pay}, \bob, $-c_i$,
              $\overrightarrow{\mathtt{path}}$) to \alice
            \Else \Comment{\TODO{figure out how to keep track of incoming}}
              \State send (\textsc{getNews}) to \alice{}
              \State extract \texttt{updatesToReport} from reply
              \If{$\exists (\alice: c_A, \bob: c_B, \mathit{pchid}) \in
              \mathtt{updatesToReport}$}
                 \State assign to \texttt{receipt} the last such entry
              \EndIf
              \State $c_i \overset{\$}{\gets} (0, c]$
              \State send (\textsc{pay}, \alice, $c_i$,
              $\overrightarrow{\mathtt{path}}$) to \bob
              \State send (\textsc{getNews}) to \alice{}
              \State extract \texttt{updatesToReport} from reply
              \If{$\exists (\alice: c_A, \bob: c_B, \mathit{pchid}) \in
              \mathtt{updatesToReport}$}
                 \State assign to \texttt{receipt} the last such entry
              \EndIf
            \EndIf
          \EndFor
          \Statex
          \State \Comment{close}
          \State send (\textsc{getNews}) to \alice{}
          \State extract \texttt{updatesToReport} from reply
          \If{$\exists (\alice: c_A, \bob: c_B, \mathit{pchid}) \in
          \mathtt{updatesToReport}$}
             \State assign to \texttt{receipt} the last such entry
          \EndIf
          \State send (\textsc{forceCloseChannel}, \texttt{receipt},
          \textit{pchid}) to \alice
          \State send (\textsc{read}) to \ledger{} and assign reply to
          $\Sigma_0$
          \Repeat
          \label{game:bal-sec:closeloop}
            \State send (\textsc{read}) to \ledger{} and assign reply to
            $\Sigma$
          \Until{$|\Sigma| \geq |\Sigma_0| + a$}
          \State send (\textsc{getNews}) to \alice{}
          \State extract \texttt{closedChannels} from reply
          \If{$\nexists (\alice: c_A', \bob: c_B', \mathit{pchid}) \in
          \mathtt{closedChannels}$}
            \State \Return 1
          \EndIf
          \If{$c_A' < c_A \vee c_A' < c + \sum_{i=1}^{n_{\mathrm{pays}}} c_i$}
            \State \Return 1
          \EndIf
          \State $c_{\mathrm{onchain}} \gets c_{\mathrm{onchain}} + c_A'$
        \EndProcedure
      \end{algorithmic}
    \end{gamebox}
    \caption{Balance Security}
    \label{game:bal-sec}
  \end{figure}

  Informally, if \alice{} opens channels which she funds with a total of
  $c_{\mathrm{init}}$ coins, sends and receives in them payments of total value
  $c_{\mathrm{out}}$, $c_{\mathrm{in}}$ respectively and subsequently closes
  them, then eventually she will be able to spend at least $c_{\mathrm{init}} -
  c_{\mathrm{out}} + c_{\mathrm{in}}$ coins on-chain. In other words, \fpaynet{}
  guarantees that payments facilitated by it can be settled back to \ledger{}
  unilaterally without any loss of funds.
