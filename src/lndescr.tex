\section{Lightning Network high level overview}
  \subsection{Simple channels}
    The aim of LN is to enable fast and cheap transactions that do not have to
    be added to the blockchain, without compromising security. Specifically no
    additional trust between counterparties is assumed. This is achieved in the
    following way: Two parties, \alice{} and \bob, that have recurring monetary
    exchanges create one on-chain transaction that locks up some funds, known as
    the ``funding transaction''. This transaction is funded by one of the two
    parties and has a 2-of-2 multisig output, which needs the signatures of both
    counterparties by their ``funding'' secret keys in order to be spent.
    Before actually submitting this transaction though, both parties
    individually ensure that they hold a transaction that spends the 2-of-2
    funding output in a way that gives the funds to the funder, along with the
    signature of this transaction with the counterparty's funding key. These two
    transactions (one for each counterparty) are called ``commitment
    transactions''. Each party can broadcast her ``local'' commitment
    transaction and has signed the ``remote'' commitment transaction, which is
    the one held by the counterparty.

    Every time they want to make a payment to each other, they exchange a
    sequence of messages (that include specially crafted signatures) that have
    two effects.  Firstly, a new pair of commitment transactions, along with
    their signatures by the funding keys, is created. Each of these transactions
    ensures that, if broadcast, each party will be able to spend their righteous
    share from the coins contained in the funding output.  Secondly, the two old
    commitment transactions are revoked.  This ensures that no party can close a
    channel using an old commitment transaction that is more beneficial to her
    than the latest one.

    Observe that it is impossible to actually make these commitment transactions
    invalid without spending the funding output; but spending it would need an
    on-chain transaction for each update, thus defeating the purpose of LN. The
    following idea is leveraged instead: If \alice{} broadcasts an old
    commitment and \bob{} sees it, he can punish \alice{} by taking all the
    money in the channel. Therefore \alice{} is technically able to broadcast an
    old commitment transaction, but has no benefit in doing so.

    The following technique is used to achieve this: \alice's old local
    commitment has an output that carries her old share of the funds. This
    output can be spent in two ways: either with a signature by \alice's
    ``delayed payment'' secret key which is a usual ECDSA key, or with a
    signature by \bob's ``revocation'' secret key, which is also an ECDSA key,
    but with an additional characteristic that we will explain soon. If \alice{}
    broadcasts an old commitment transaction, \bob{} will be able to take her
    funds by spending her output using his ``revocation'' key.  At the time of
    creation of a new commitment, both parties know \bob's ``revocation'' public
    key, but no party knows its secret part -- it can only be computed by
    combining one secret that \alice{} knows and one secret that \bob{} knows.
    \alice{} therefore sends this secret to \bob{} after the new commitment
    transaction is built and signed, in order to revoke the old commitment. Thus
    \bob{} cannot abuse this output before an old commitment transaction is
    revoked. A new cryptographic construction has been designed by the creators
    of LN in order to enable such ``revocation'' keys, which we define as a new
    primitive with specific security properties named ``combined signature'' and
    prove that their construction realizes it.

    The last element needed to make updates secure is the so called ``relative
    timelock''. If \alice{} broadcasts a commitment transaction, she is not
    allowed to immediately spend her funds with her ``delayed payment'' key.
    Instead, she has to wait for the transaction to reach a pre-agreed block
    depth (the relative timelock, hardcoded in the output script of the
    commitment transaction) in order to give some time to \bob{} to see the
    transaction and, if it does not correspond to the latest version of the
    channel, punish her with his ``revocation'' key. This avoids a scenario in
    which \alice{} broadcasts an old commitment transaction and immediately
    spends her output, which would prevent \bob{} from ever proving that this
    commitment was old.

    Lastly, if \alice{} wants to unilaterally close a channel, all she has to do
    is broadcast her latest local commitment transaction (the only one that is
    not revoked) and wait for the timelock to expire in order to spend her
    funds. The LN specification allows for cooperative channel closure which
    avoids the need to wait for the timelock, but in the current work
    this last type of closure is not considered.

    A possible usability problem that arises is that both parties have to be
    vigilant to punish their counterparty if the latter broadcasts an old
    commitment transaction, i.e. parties have to come regularly online to
    safeguard against theft. LN makes it possible to trustlessly outsource this,
    but this mechanism is not analyzed in the current work.

  \subsection{Multi-hop payments}
    Having funds locked down for exclusive use with a particular counterparty
    would be a serious limitation. Luckily, LN allows for multi-hop payments. In
    a situation where \alice{} has a channel with \bob{} and he has another
    channel with \charlie{}, it is possible for \alice{} to pay \charlie{}
    off-chain by leveraging \bob's help. Remarkably, this can be achieved
    without any one party trusting any of the other two. One can think of
    \alice{} giving some ``marked'' money to \bob{}, who in turn either delivers
    it to \charlie{} or returns it to \alice{} -- it is impossible for \bob{} to
    keep the money. It is also impossible for \alice{} and \charlie{} to make
    \bob{} pay for this transaction out of his pocket.

    We will now give an informal overview of how this counterintuitive dynamic
    is made possible. \alice{} initiates the payment by asking \charlie{} to
    create a new hash for a payment of $x$ coins. \charlie{} chooses a random
    secret, hashes it and sends the hash to \alice. \alice{} promises \bob{} to
    pay him $x$ in their channel if he shows her the preimage of this particular
    hash within a specific time frame. \bob{} makes the same promise to
    \charlie{}: if \charlie{} tells \bob{} the preimage of the same hash within
    a specific time frame (shorter than the one \bob{} has agreed with
    \alice{}), \bob{} will pay him $x$ in their common channel. \charlie{} then
    sends him the preimage (which is the secret he generated initially) and
    \bob{} agrees to update the channel to a new version where $x$ is moved from
    him to \charlie. Similarly, \bob{} sends the preimage to \alice{} and once
    again \alice{} updates their channel to give \bob{} $x$ coins. Therefore $x$
    coins were transmitted from \alice{} to \charlie{} and \bob{} did not gain
    or lose anything, he just increased his balance in the channel with \alice{}
    and reduced his balance by an equal amount in the channel with \charlie.

    This type of promise where a preimage is exchanged for money is called Hash
    TimeLocked Contract (HTLC). It is enforceable on-chain in case the payer
    does not cooperatively update upon disclosure of the preimage, thus no trust
    is needed. Two HTLCs were signed and fulfilled for the payment of the
    previous example, which happened completely off-chain. Two updates happened
    in each channel: one to sign the HTLC and one to fulfill it. The time frames
    were chosen so that every intermediary has had the time to learn the
    preimage and give it to the previous party on the path.

    LN gives the possibility for intermediaries to charge a fee for their
    service, but such fees are not incorporated in the current analysis.
    Furthermore, LN leverages the Sphinx onion packet scheme~\cite{sphinx} to
    increase the privacy of payments, but we do not formaly analyze the privacy
    of LN in this work -- we just use it in our protocol description to
    syntactically match the message format used by LN.
