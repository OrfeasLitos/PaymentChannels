\begin{figure}[H]
  \begin{simulatorbox}{$\simulator$}
    Like $\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$. Differences:
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{closeChannel}, \texttt{receipt},
      \textit{tid}, \alice) from \fpaynet:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:close} receiving
        (\textsc{closeChannel}, \texttt{receipt}, \textit{tid}) with \alice's
        ITI
      \EndIndent
      \Statex

      \State every time \texttt{closedChannels} of \alice{} is updated with
      data from a \texttt{channel} (Fig.~\ref{alg:protocol:close},
      line~\ref{alg:protocol:close:report} and
      Fig.~\ref{alg:protocol:poll:closedch},
      line~\ref{alg:protocol:poll:report}), send (\textsc{closedChannel},
      \texttt{channel}, \alice) to \fpaynet{} and expect (\textsc{continue})
      from \fpaynet{} to resume simulation
      \label{alg:sim:close:report}
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:close}
\end{figure}

\begin{lemma}
  \label{lemma:close}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open - Pay}}, \environment} \overset{c}{\approx}
  \textsc{Exec}^{\fpaynet, \ledger}_{\simulator, \environment}$
\end{lemma}

\begin{proof}
  Like in the previous proof, we here also assume that $\neg P \wedge \neg Q
  \wedge \neg R$ holds.

  When \environment{} sends (\textsc{closeChannel}, \texttt{receipt},
  \textit{tid}) to \alice, in the ideal world, if it is not the first closing
  message to \alice{} the message is ignored (Fig.~\ref{alg:fpaynet:close},
  line~\ref{alg:fpaynet:close:noserve}). Similarly in the real world, if there
  has been another such message, \alice{} ignores it
  (Fig.\ref{alg:protocol:close}, lines~\ref{alg:protocol:close:remove}
  and~\ref{alg:protocol:close:ensure}).

  In the case that it is indeed the first closing message, in the ideal world
  \fpaynet{} takes note that this close is pending
  (Fig.~\ref{alg:fpaynet:close},
  lines~\ref{alg:fpaynet:close:retrieve}-\ref{alg:fpaynet:close:mark}) and stops
  serving more requests for this channel (line~\ref{alg:fpaynet:close:noserve}),
  before asking \simulator{} to carry out channel closing. \simulator{} then
  simulates the response to the original message from \environment{} with
  \alice's ITI (Fig.~\ref{alg:sim:close}). Observe that, since \fpaynet{} has
  ensured that this is the first request for closing this particular channel,
  the simulated check of line~\ref{alg:protocol:close:ensure} in
  Fig.~\ref{alg:protocol:close} always passes and the rest of
  Fig.~\ref{alg:protocol:close} is executed. In the real world, the check also
  passes (since we are in the case where this is the first closing message) and
  Fig.~\ref{alg:protocol:close} is executed by the real \alice{} in its
  entirety. Therefore, when \environment{} sends \textsc{closeChannel}, no
  opportunity for distinguishability arises.

  When \environment{} sends (\textsc{getNews}) to \alice, in the ideal world
  \fpaynet{} sends (\textsc{news}, \texttt{newChannels}(\alice),
  \texttt{closedChannels}(\alice), \texttt{updatesToReport}\linebreak(\alice))
  to \environment{} and empties these fields (Fig.~\ref{alg:fpaynet:daemon},
  lines~\ref{alg:fpaynet:getnews}-\ref{alg:fpaynet:getnews:send}). In the real
  world, \alice{} sends the message (\textsc{news}, \texttt{newChannels},
  \texttt{closedChannels}, \texttt{updatesToReport}) to \environment{} and
  empties these fields as well (Fig.~\ref{alg:protocol:poll},
  lines~\ref{alg:protocol:getnews}-\ref{alg:protocol:getnews:send}).
  \texttt{newChannels}(\alice) in the ideal world is populated in two cases:
  First, when \fpaynet{} receives (\textsc{channelOpened}) after \alice{} has
  previously received (\textsc{checkForNew}) (Fig.~\ref{alg:fpaynet:open},
  line~\ref{alg:fpaynet:channelOpened:report}). This happens when the simulated
  \alice{} ITI handles a \textsc{fundingLocked} message from \bob{}
  (Fig.~\ref{alg:sim:open}, line~\ref{alg:sim:open:channelOpened}). In the real
  world \alice{} would have modified her
  \texttt{new}-\linebreak\texttt{Channels} while handling \bob's
  \textsc{fundingLocked} (Fig.~\ref{alg:protocol:fundingLocked},
  line~\ref{alg:protocol:fundingLocked:report}), thus as far as this case is
  concerned, \texttt{newChannels} has the same contents in the real world as
  does \texttt{newChannels}(\alice) in the ideal. The other case when
  \texttt{newChannels}(\alice) is populated is when \fpaynet{} receives
  (\textsc{fundingLocked}) after \bob{} has previously received
  (\textsc{checkForNew}) (Fig.~\ref{alg:fpaynet:open},
  line~\ref{alg:fpaynet:fundingLocked:report}). This (\textsc{fundingLocked})
  can only be sent by \simulator{} if \alice{} is honest and right before the
  receiving of (\textsc{fundingLocked}) is simulated with her ITI
  (Fig.~\ref{alg:sim:open},
  lines~\ref{alg:sim:fundingLocked:sim:alice}-\ref{alg:sim:fundingLocked:sim:bob}).
  In the real world, \alice's \texttt{newChannels} would be populated upon
  handling the same (\textsc{fundingLocked}). Therefore the \texttt{newChannels}
  part of the message is identical in the real and the ideal world at every
  moment when \environment{} can send (\textsc{getNews}).

  Moving on to \texttt{closedChannels}(\alice), we observe that \fpaynet{} adds
  \texttt{channel} information when it receives (\textsc{closedChannel},
  \texttt{channel}, \alice) from \simulator{} (Fig.~\ref{alg:fpaynet:daemon},
  line~\ref{alg:fpaynet:closedChannel:report}), which in turn happens exactly
  when the simulated \alice{} ITI adds the \texttt{channel} to her
  \texttt{closedChannels} (Fig.~\ref{alg:sim:close},
  line~\ref{alg:sim:close:report}). Therefore the real and ideal
  \texttt{closedChannels} are always synchronized.

  Regarding \texttt{updatesToReport}, in the real world it is populated
  exclusively in line~\ref{alg:protocol:pay:raa:report} of
  Fig.~\ref{alg:protocol:pay:revokeAndAck}. In the ideal world on the other
  hand, it is updated in line~\ref{alg:fpaynet:update} of
  Fig.~\ref{alg:fpaynet:pay}, which is triggered only by an (\textsc{update})
  message by \simulator. This message is sent only when
  line~\ref{alg:protocol:pay:raa:report} of
  Fig.~\ref{alg:protocol:pay:revokeAndAck} is simulated by \simulator{}
  (Fig.~\ref{alg:sim:push}, line~\ref{alg:sim:push:report}). In the real world,
  this happens only after receiving a valid (\textsc{revokeAndAck}) message from
  the channel counterparty and after first having sent a corresponding
  (\textsc{commitmentSigned}) message (Fig.~\ref{alg:protocol:pay:revokeAndAck},
  line~\ref{alg:protocol:pay:revokeAndAck:ensure} and
  Fig.~\ref{alg:protocol:pay:commitmentSigned},
  lines~\ref{alg:protocol:pay:commit:nomark}
  and~\ref{alg:protocol:pay:commit:mark}), which happens only after receiving
  (\textsc{commit}) from \environment. In the ideal world a simulation of the
  same events can only happen in the exact same case, i.e. when \environment{}
  sends an identical (\textsc{commit}) to the same player. Indeed, \fpaynet{}
  simply forwards this message to \simulator{} (Fig.~\ref{alg:fpaynet:daemon},
  line~\ref{alg:fpaynet:daemon:commit}), who in turn simply simulates the
  response to the message with the simulated ITI that corresponds to the player
  that would receive the message in the real world (Fig.~\ref{alg:sim:push},
  line~\ref{alg:sim:push:commit}). We conclude that the \texttt{updatesToReport}
  sent to \environment{} in either the real or the ideal world are always
  identical.

  Lastly, in the ideal world, whenever (\textsc{read}) is sent to \ledger{} and
  a reply is received, the function \texttt{checkClosed}
  (Fig.\ref{alg:fpaynet:close},
  lines~\ref{alg:fpaynet:close:func:start}-\ref{alg:fpaynet:close:func:end}) is
  called with the reply of the \ledger{} as argument. This function does not
  generate new messages, but may cause the \fpaynet{} to halt. We will now prove
  that this never happens.

  \fpaynet{} halts in line~\ref{alg:fpaynet:close:func:malicious} in case a
  malicious closure by the counterparty was successful, in spite of the fact
  that \alice{} polled in time to apply the punishment. A (\textsc{poll})
  message to \alice{} within the prescribed time frame
  (line~\ref{alg:fpaynet:close:func:ifmalicious}) would cause \fpaynet{} to
  alert \simulator{} (Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:send}), who in turn would submit the punishment
  transaction in time to prevent the counterparty from spending the delayed
  payment (Fig.~\ref{alg:protocol:poll:closedch},
  lines~\ref{alg:protocol:poll:mal:tx}-\ref{alg:protocol:poll:mal:submit}).
  Therefore the only way for a malicious counterparty to spend the delayed
  output before \alice{} has the time to punish is by spending the punishment
  output themself. This however can never happen, since this event would be a
  subset of either $R$, if $\mathtt{remoteCom}_n$ (i.e. the counterparty closed
  the channel) is in $\Sigma_{\alice}$, or $Q$, if $\mathtt{localCom}_n$ is in
  $\Sigma_{\alice}$ (i.e. \alice{} closed the channel).

  \fpaynet{} halts in line~\ref{alg:fpaynet:close:func:idle} of
  Fig.~\ref{alg:fpaynet:close} in case \environment{} has asked for the channel
  to close, but too much time has passed since. This event cannot happen, for
  two reasons. First, regarding elements in \texttt{pendingClose}(\alice),
  because \fpaynet{} forwards a (\textsc{closeChannel}) message to \simulator{}
  (Fig.~\ref{alg:fpaynet:close}, line~\ref{alg:fpaynet:close:send}) for every
  element that it adds to \texttt{pendingClose} (Fig~\ref{alg:fpaynet:close},
  line~\ref{alg:fpaynet:close:mark}) and this causes \simulator{} to submit the
  closing transaction to \ledger{} (Fig.~\ref{alg:protocol:close},
  line~\ref{alg:protocol:close:submit}). This transaction is necessarily valid,
  because there is no other transaction that spends the funding transaction of
  the channel, according to the first check of
  line~\ref{alg:fpaynet:close:func:ifidle} of Fig.~\ref{alg:fpaynet:close}.
  \fpaynet{} halts in this case only if it is sure that the chain has grown by
  \tochain{} blocks, and thus if the closing transaction had been submitted when
  (\textsc{closeChannel}) was received, it should have been necessarily included
  (Proposition~\ref{prop:tochain}). Second, every element added to
  \texttt{closedChannels} (Fig.~\ref{alg:protocol:close},
  line~\ref{alg:protocol:close:report} and
  Fig.~\ref{alg:protocol:poll:closedch}, line~\ref{alg:protocol:poll:report})
  corresponds to a submission of a closing transaction for the same channel
  (Fig.~\ref{alg:protocol:close}, line~\ref{alg:protocol:close:submit}), or to a
  channel for which the closing transaction is already in the ledger state
  (Fig.~\ref{alg:protocol:poll:closedch},
  line~\ref{alg:protocol:poll:closedch:loop}). In both cases, the transaction
  has been submitted at least \tochain{} blocks earlier, thus again by
  Proposition~\ref{prop:tochain} it is impossible for the transaction not to be
  in the ledger state. Therefore \fpaynet{} cannot halt in
  line~\ref{alg:fpaynet:close:func:idle} of Fig.~\ref{alg:fpaynet:close}. We
  deduce that, given $\neg P \wedge \neg Q \wedge \neg R$, the execution of
  \texttt{checkClosed} by \fpaynet{} does not contribute any increase to the
  probability of distinguishability.
\end{proof}
