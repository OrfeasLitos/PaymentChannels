\begin{figure}[H]
  \begin{simulatorbox}{$\simulator$}
    Like $\simulator{}_{\mathrm{LN - Reg - Open - Pay}}$. Difference:
    \begin{algorithmic}[1]
      \State Upon receiving (\textsc{closeChannel}, \texttt{receipt}, \alice)
      from \fpaynet:
      \Indent
        \State simulate Fig.~\ref{alg:protocol:close} receiving
        (\textsc{closeChannel}, \texttt{receipt}) with \alice's ITI
      \EndIndent
    \end{algorithmic}
  \end{simulatorbox}
  \caption{}
  \label{alg:sim:close}
\end{figure}

\begin{lemma}
  \label{lemma:close}
  $\textsc{Exec}^{\fpaynet{}_{\mathrm{, Pay}}, \ledger}_{\simulator_{\mathrm{LN
  - Reg - Open - Pay}}, \environment} \overset{c}{\approx}
  \textsc{Exec}^{\fpaynet, \ledger}_{\simulator, \environment}$
\end{lemma}

\begin{proof}
  When \environment{} sends (\textsc{closeChannel}, \texttt{receipt}) to \alice,
  in the ideal world, if it is not the first closing message to \alice{} the
  message is ignored (Fig.~\ref{alg:fpaynet:close},
  line~\ref{alg:fpaynet:close:noserve}). Similarly in the real world, if there
  has been another such message, \alice{} ignores it
  (Fig.\ref{alg:protocol:close}, lines~\ref{alg:protocol:close:remove}
  and~\ref{alg:protocol:close:ensure}).

  In the case that it is indeed the first closing message, in the ideal world
  \fpaynet{} takes note that this close is pending
  (Fig.~\ref{alg:fpaynet:close},
  lines~\ref{alg:fpaynet:close:retrieve}-\ref{alg:fpaynet:close:mark}) and stops
  serving more requests for this channel (line~\ref{alg:fpaynet:close:noserve}),
  before asking \simulator{} to carry out channel closing. \simulator{} then
  simulates the response to the original message from \environment{} with
  \alice's ITI (Fig.~\ref{alg:sim:close}). Observe that, since \fpaynet{} has
  ensured that this is the first request for closing this particular channel,
  the simulated check of line~\ref{alg:protocol:close:ensure} in
  Fig.~\ref{alg:protocol:close} always passes and the rest of
  Fig.~\ref{alg:protocol:close} is executed. In the real world, the check also
  passes (since we are in the case where this is the first closing message) and
  Fig.~\ref{alg:protocol:close} is executed by the real \alice{} in its
  entirety. Therefore, when \environment{} sends \textsc{closeChannel}, no
  opportunity for distinguishability arises.

  When \environment{} sends (\textsc{getNews}) to \alice, \TODO{continue}

  Lastly, in the ideal world, whenever (\textsc{read}) is sent to \ledger{} and
  a reply is received, the function \texttt{checkClosed}
  (Fig.\ref{alg:fpaynet:close},
  lines~\ref{alg:fpaynet:close:func:start}-\ref{alg:fpaynet:close:func:end}) is
  called with the reply of the \ledger{} as argument. This function does not
  generate new messages, but may cause the \fpaynet{} to halt. We will now prove
  that this happens only with negligible probability.

  \fpaynet{} halts in line~\ref{alg:fpaynet:close:func:malicious} in case a
  malicious closure by the counterparty was successful, in spite of the fact
  that \alice{} polled in time to apply the punishment. A (\textsc{poll})
  message to \alice{} within the prescribed time frame
  (line~\ref{alg:fpaynet:close:func:ifmalicious}) would cause \fpaynet{} to
  alert \simulator{} (Fig.~\ref{alg:fpaynet:poll},
  line~\ref{alg:fpaynet:poll:send}), who in turn would submit the punishment
  transaction in time to prevent the counterparty from spending the delayed
  payment (Fig.~\ref{alg:protocol:poll:closedch},
  lines~\ref{alg:protocol:poll:mal:tx}-\ref{alg:protocol:poll:mal:submit}).
  Therefore the only way for a malicious counterparty to spend the delayed
  output before \alice{} has the time to punish is by spending the punishment
  output themself. This however can only happen with negligible probability,
  since the counterparty would need to forge a signature valid by the public
  revocation key.

  \fpaynet{} halts in line~\ref{alg:fpaynet:close:func:idle} of
  Fig.~\ref{alg:fpaynet:close} in case \environment{} has asked for the channel
  to close, but too much time has passed since. This event cannot happen,
  because \fpaynet{} forwards a \textsc{closeChannel} message to \simulator{}
  (Fig.~\ref{alg:fpaynet:close}, line~\ref{alg:fpaynet:close:send}) for every
  element that it adds to \texttt{pendingPay} (Fig~\ref{alg:fpaynet:close},
  line~\ref{alg:fpaynet:close:mark}) and this causes \simulator{} to submit the
  closing transaction to \ledger{} (Fig.~\ref{alg:protocol:close},
  line~\ref{alg:protocol:close:submit}). This transaction is necessarily valid,
  because there is no other transaction that spends the funding transaction of
  the channel, according to the first check of
  line~\ref{alg:fpaynet:close:func:ifidle} of Fig.~\ref{alg:fpaynet:close}.
  \fpaynet{} halts in this case only if it is sure that the chain has grown by
  \tochain{} blocks, and thus if the closing transaction had been submitted when
  \textsc{closeChannel} was received, it should have been necessarily included
  (Proposition~\ref{prop:tochain}). Therefore \fpaynet{} cannot halt in
  line~\ref{alg:fpaynet:close:func:idle} of Fig.~\ref{alg:fpaynet:close}. We
  deduce that the execution of \texttt{checkClosed} by \fpaynet{} increases the
  probability of distinguishability only by a negligible amount.
\end{proof}
